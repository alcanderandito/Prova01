<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Super Fabio bros</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #333;
            font-family: 'Arial', sans-serif;
            color: white;
            overflow: hidden; /* Evita scrollbar indesiderate */
        }
        #gameContainer {
            position: relative; /* Per posizionare pulsanti HTML sopra/sotto */
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        canvas {
            border: 2px solid #000;
            background-color: #70c5ce; /* Colore cielo di default */
            max-width: 100%;
            max-height: calc(100vh - 150px); /* Lascia spazio per UI e controlli */
            aspect-ratio: 16 / 9; /* Mantiene le proporzioni */
            display: block; /* Aiuta con alcuni problemi di layout/spazio extra */
        }
        #ui {
            display: flex;
            justify-content: space-around;
            align-items: center; /* Allinea verticalmente gli elementi UI */
            width: 100%;
            max-width: 800px; /* Stessa larghezza max del canvas se impostata */
            padding: 10px 0;
            font-size: 1.0em; /* Leggermente ridotto per far spazio a tutti gli elementi */
            background-color: rgba(0,0,0,0.5);
            border-radius: 0 0 10px 10px;
            flex-wrap: wrap; /* Permette agli elementi di andare a capo se non c'√® spazio */
        }
        .ui-element {
            margin: 2px 8px; /* Spazio verticale e orizzontale */
        }
        #touchControls {
            display: none; /* Nascosti di default, mostrati via JS per mobile */
            justify-content: space-around;
            width: 100%;
            max-width: 400px;
            margin-top: 15px;
            padding: 10px;
            background-color: rgba(0,0,0,0.3);
            border-radius: 10px;
        }
        .touch-button {
            background-color: #555;
            color: white;
            border: 2px solid #ddd;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        .touch-button:active {
            background-color: #777;
        }
        #homeButtonContainer {
            margin-top: 20px;
        }
        #homeButton {
            padding: 10px 20px;
            font-size: 1em;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            text-decoration: none;
            cursor: pointer;
        }
        #homeButton:hover {
            background-color: #0056b3;
        }

        .overlay-button {
            position: absolute;
            padding: 15px 30px;
            font-size: 1.5em;
            background-color: #4CAF50;
            color: white;
            border: 2px solid #3e8e41;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            z-index: 100;
            display: none; /* Nascosti di default, mostrati da JS */
        }
        .overlay-button:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="ui">
            <div id="lives" class="ui-element">Vite: 5</div>
            <div id="score" class="ui-element">Punteggio: 0</div>
            <div id="timerDisplay" class="ui-element">Tempo: 120</div>
            <div id="levelDisplay" class="ui-element">Livello: 1</div>
            <div id="powerUpTimer" class="ui-element"></div>
        </div>
        <div id="touchControls">
            <button id="leftButton" class="touch-button">‚óÄÔ∏è</button>
            <button id="jumpButton" class="touch-button">üîº</button>
            <button id="rightButton" class="touch-button">‚ñ∂Ô∏è</button>
            <button id="shootButton" class="touch-button" style="display:none;">‚ú®</button>
        </div>

        <button id="startButton" class="overlay-button">Inizia Gioco</button>
        <button id="retryButton" class="overlay-button">Riprova</button>
        <button id="playAgainButton" class="overlay-button">Gioca Ancora</button>
        <button id="nextLevelButton" class="overlay-button">Prossimo Livello</button>
    </div>

    <div id="homeButtonContainer">
        <a href="../index.html" id="homeButton">Torna alla Home</a>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('gameContainer');

        const livesDisplay = document.getElementById('lives');
        const scoreDisplay = document.getElementById('score');
        const powerUpTimerDisplay = document.getElementById('powerUpTimer');
        const timerDisplay = document.getElementById('timerDisplay');
        const levelDisplay = document.getElementById('levelDisplay');

        const startButton = document.getElementById('startButton');
        const retryButton = document.getElementById('retryButton');
        const playAgainButton = document.getElementById('playAgainButton');
        const nextLevelButton = document.getElementById('nextLevelButton');

        const touchControlsDiv = document.getElementById('touchControls');
        const leftButton = document.getElementById('leftButton');
        const rightButton = document.getElementById('rightButton');
        const jumpButton = document.getElementById('jumpButton');
        const shootButton = document.getElementById('shootButton');

        const backgroundMusic = new Audio('../assets/fabiobros_assets/fabiosong.mp3');
        backgroundMusic.loop = true;
        backgroundMusic.onerror = () => {
            console.error("Errore nel caricamento del file audio: fabiosong.mp3.");
        };

        let gameWidth = 800;
        let gameHeight = 450;
        canvas.width = gameWidth;
        canvas.height = gameHeight;

        function positionOverlayButton(button, topFactor = 0.75) {
            button.style.display = 'block';
            const canvasRect = canvas.getBoundingClientRect();
            const gameContainerRect = gameContainer.getBoundingClientRect();
            const canvasTopInContainer = canvasRect.top - gameContainerRect.top;
            const canvasLeftInContainer = canvasRect.left - gameContainerRect.left;
            const buttonLeft = canvasLeftInContainer + (canvasRect.width / 2) - (button.offsetWidth / 2);
            const buttonTop = canvasTopInContainer + (canvasRect.height * topFactor) - (button.offsetHeight / 2);
            button.style.left = `${buttonLeft}px`;
            button.style.top = `${buttonTop}px`;
        }

        function hideOverlayButtons() {
            startButton.style.display = 'none';
            retryButton.style.display = 'none';
            playAgainButton.style.display = 'none';
            nextLevelButton.style.display = 'none';
        }

        window.addEventListener('resize', () => {
            if (startButton.style.display === 'block') positionOverlayButton(startButton, 0.70);
            if (retryButton.style.display === 'block') positionOverlayButton(retryButton, 0.75);
            if (playAgainButton.style.display === 'block') positionOverlayButton(playAgainButton, 0.75);
            if (nextLevelButton.style.display === 'block') positionOverlayButton(nextLevelButton, 0.75);
        });

        const images = {};
        const imageSources = {
            player: '../assets/fabiobros_assets/fabiogame2.PNG',
            enemy: '../assets/fabiobros_assets/mostro.PNG',
            background: '../assets/fabiobros_assets/fabiogame.PNG'
        };
        let imagesLoaded = 0;
        let totalImages = Object.keys(imageSources).length;

        function loadImages(callback) {
            for (let key in imageSources) {
                images[key] = new Image();
                images[key].src = imageSources[key];
                images[key].onload = () => {
                    imagesLoaded++;
                    if (imagesLoaded === totalImages) {
                        callback();
                    }
                };
                images[key].onerror = () => {
                    console.error(`Errore caricamento immagine: ${imageSources[key]}`);
                    imagesLoaded++;
                    if (imagesLoaded === totalImages) {
                        callback();
                    }
                }
            }
        }

        let player;
        let platforms = [];
        let enemies = [];
        let collectibles = [];
        let projectiles = [];
        let powerUpCollectible = null;

        let score = 0;
        let lives = 5;
        let currentLevel = 0;
        let gameState = 'LOADING';

        const gravity = 0.8;
        const groundFriction = 0.8;

        let powerUpActive = false;
        let powerUpDuration = 15000;
        let powerUpTimer = 0;
        let enemiesKilledForPowerUp = 0;
        const powerUpSpawnThreshold = 4;

        let boss = null;
        const bossMaxHealth = 15;

        const PLAYER_DEFAULT_HEIGHT = 60;

        const LEVEL_TIME_LIMIT = 120000;
        let currentLevelTimeRemaining = LEVEL_TIME_LIMIT;

        let nextLifeScoreThreshold = 1000;

        const levels = [
            { 
                bgColor: '#70c5ce', themeName: "Cielo Sereno",
                playerStartX: 60, playerStartPlatformTopY: gameHeight - 120,
                platforms: [
                    { x: 0, y: gameHeight - 40, width: gameWidth, height: 40, color: '#8FBC8F' },
                    { x: 30, y: gameHeight - 120, width: 100, height: 20, color: '#A0522D' },
                    { x: 200, y: gameHeight - 140, width: 150, height: 20, color: '#A0522D' },
                    { x: 400, y: gameHeight - 200, width: 200, height: 20, color: '#A0522D' },
                    { x: 650, y: gameHeight - 100, width: 100, height: 20, color: '#A0522D' }
                ],
                enemies: [ 
                    { x: 300, y: gameHeight - 80 }, { x: 500, y: gameHeight - 80 },
                    { x: 450, y: gameHeight - 240 }
                ],
                collectibles: [
                    { x: 80, y: gameHeight - 160 }, { x: 250, y: gameHeight - 180 },
                    { x: 480, y: gameHeight - 240 }, { x: 680, y: gameHeight - 140 },
                    { x: 150, y: gameHeight - 80 },  { x: 550, y: gameHeight - 80 }
                ]
            },
            { 
                bgColor: '#F4A460', themeName: "Deserto Infuocato",
                playerStartX: 60, playerStartPlatformTopY: gameHeight - 150,
                platforms: [
                    { x: 0, y: gameHeight - 40, width: gameWidth, height: 40, color: '#D2B48C' },
                    { x: 30, y: gameHeight - 150, width: 100, height: 20, color: '#CD853F' },
                    { x: 200, y: gameHeight - 120, width: 100, height: 20, color: '#CD853F' },
                    { x: 350, y: gameHeight - 180, width: 180, height: 20, color: '#CD853F' },
                    { x: 600, y: gameHeight - 100, width: 150, height: 20, color: '#CD853F' },
                    { x: 250, y: gameHeight - 280, width: 120, height: 20, color: '#CD853F' },
                ],
                enemies: [
                    { x: 250, y: gameHeight - 80 }, { x: 450, y: gameHeight - 80 },
                    { x: 650, y: gameHeight - 80 }, { x: 380, y: gameHeight - 220 },
                    { x: 280, y: gameHeight - 320 }
                ],
                collectibles: [
                    { x: 70, y: gameHeight - 190 }, { x: 220, y: gameHeight - 160 },
                    { x: 400, y: gameHeight - 220 }, { x: 630, y: gameHeight - 140 },
                    { x: 280, y: gameHeight - 320, isDifficult: true },
                    { x: 150, y: gameHeight - 80 }, { x: 350, y: gameHeight - 80 },
                    { x: 500, y: gameHeight - 80 }, { x: 750, y: gameHeight - 80 }
                ]
            },
            { 
                bgColor: '#228B22', themeName: "Foresta Omrbosa", powerUpEnabled: true,
                playerStartX: 70, playerStartPlatformTopY: gameHeight - 150,
                platforms: [
                    { x: 0, y: gameHeight - 40, width: gameWidth, height: 40, color: '#556B2F' },
                    { x: 50, y: gameHeight - 150, width: 150, height: 20, color: '#8B4513' },
                    { x: 250, y: gameHeight - 220, width: 100, height: 20, color: '#8B4513' },
                    { x: 400, y: gameHeight - 120, width: 200, height: 20, color: '#8B4513' },
                    { x: 650, y: gameHeight - 250, width: 120, height: 20, color: '#8B4513' },
                    { x: 300, y: gameHeight - 320, width: 80, height: 20, color: '#8B4513'}
                ],
                enemies: [
                    { x: 150, y: gameHeight - 80 }, { x: 350, y: gameHeight - 80 },
                    { x: 500, y: gameHeight - 80 }, { x: 700, y: gameHeight - 80 },
                    { x: 280, y: gameHeight - 260 }, { x: 450, y: gameHeight - 160 },
                    { x: 680, y: gameHeight - 290 }
                ],
                collectibles: [
                    { x: 100, y: gameHeight - 190 }, { x: 280, y: gameHeight - 260 },
                    { x: 450, y: gameHeight - 160 }, { x: 680, y: gameHeight - 290 },
                    { x: 330, y: gameHeight - 360, isDifficult: true },
                    { x: 80, y: gameHeight - 80 }, { x: 200, y: gameHeight - 80 },
                    { x: 320, y: gameHeight - 80 }, { x: 550, y: gameHeight - 80 },
                    { x: 650, y: gameHeight - 80 }, { x: 750, y: gameHeight - 80 }
                ]
            },
            { 
                bgColor: '#778899', themeName: "Metropoli Grigia", powerUpEnabled: true,
                playerStartX: 40, playerStartPlatformTopY: gameHeight - 180,
                platforms: [
                    { x: 0, y: gameHeight - 40, width: gameWidth, height: 40, color: '#A9A9A9' },
                    { x: 0, y: gameHeight - 180, width: 120, height: 20, color: '#696969' },
                    { x: gameWidth - 180, y: gameHeight - 180, width: 180, height: 20, color: '#696969' },
                    { x: 180, y: gameHeight - 120, width: 100, height: 20, color: '#696969' },
                    { x: 320, y: gameHeight - 250, width: 150, height: 20, color: '#696969' },
                    { x: 500, y: gameHeight - 120, width: 100, height: 20, color: '#696969' },
                    { x: 250, y: gameHeight - 340, width: 80, height: 20, color: '#696969'},
                    { x: gameWidth/2 + 80, y: gameHeight - 200, width: 100, height: 20, color: '#696969'}
                ],
                enemies: [ 
                    { x: 100, y: gameHeight - 80 }, { x: 250, y: gameHeight - 80 },
                    { x: 550, y: gameHeight - 80 }, { x: 700, y: gameHeight - 80 },
                    { x: gameWidth - 120, y: gameHeight - 220 }, 
                    { x: 350, y: gameHeight - 290 }, 
                    { x: 200, y: gameHeight - 160 },
                    { x: 260, y: gameHeight - 380 } 
                ],
                collectibles: [ 
                    { x: 50, y: gameHeight - 220 }, { x: gameWidth - 100, y: gameHeight - 220 },
                    { x: 210, y: gameHeight - 160 }, { x: 530, y: gameHeight - 160 },
                    { x: 380, y: gameHeight - 290, isDifficult: true }, 
                    { x: 270, y: gameHeight - 380 }, 
                    { x: 150, y: gameHeight - 80 }, { x: 450, y: gameHeight - 80 },
                    { x: 650, y: gameHeight - 80 },
                    { x: gameWidth/2 + 100, y: gameHeight - 240 } 
                ]
            },
            { 
                bgColor: '#483D8B', themeName: "Castello Oscuro", powerUpEnabled: true, isBossLevel: true,
                playerStartX: 120, playerStartPlatformTopY: gameHeight - 150,
                platforms: [
                    { x: 0, y: gameHeight - 40, width: gameWidth, height: 40, color: '#2F4F4F' },
                    { x: 100, y: gameHeight - 150, width: 150, height: 20, color: '#708090' },
                    { x: gameWidth - 250, y: gameHeight - 150, width: 150, height: 20, color: '#708090' },
                    { x: gameWidth/2 - 75, y: gameHeight - 250, width: 150, height: 20, color: '#708090' }
                ],
                enemies: [
                    { x: 250, y: gameHeight - 80 },
                    { x: gameWidth - 300, y: gameHeight - 80 }
                ],
                bossData: {
                    x: gameWidth / 2 - 50, y: gameHeight - 120, health: bossMaxHealth,
                    speedX: 3, speedY: 2.5, 
                    minY: gameHeight - 320, maxY: gameHeight - 100
                },
                collectibles: [
                    { x: 150, y: gameHeight - 190 }, { x: gameWidth - 200, y: gameHeight - 190 },
                    { x: gameWidth/2 - 15, y: gameHeight - 290, isDifficult: true },
                    { x: 50, y: gameHeight - 80 }, { x: gameWidth - 100, y: gameHeight - 80 }
                ]
            }
        ];

        class Player {
            constructor(x, y) {
                this.width = 40; this.height = PLAYER_DEFAULT_HEIGHT;
                this.x = x; this.y = y;
                this.dx = 0; this.dy = 0;
                this.speed = 5; this.jumpForce = 15;
                this.isJumping = false; this.onGround = false;
                this.image = images.player;
                this.shootCooldown = 0; this.shootDelay = 300;
                this.lastDirection = 'right';
            }

            jump() {
                if (this.onGround) {
                    this.dy = -this.jumpForce;
                    this.isJumping = true; this.onGround = false;
                }
            }

            shoot() {
                if (powerUpActive && this.shootCooldown <= 0) {
                    const projectileType = '‚ú®'; 
                    const projectileSpeed = 8;
                    let dir = (this.lastDirection === 'left') ? -1 : 1;
                    projectiles.push(new Projectile(this.x + this.width / 2, this.y + this.height / 2, projectileType, dir * projectileSpeed));
                    this.shootCooldown = this.shootDelay;
                }
            }

            update(deltaTime) {
                if (keys.ArrowLeft || keys.KeyA || touchLeft) {
                    this.dx = -this.speed; this.lastDirection = 'left';
                } else if (keys.ArrowRight || keys.KeyD || touchRight) {
                    this.dx = this.speed; this.lastDirection = 'right';
                } else { this.dx *= groundFriction; }

                this.dy += gravity;
                this.y += this.dy; this.x += this.dx;

                if (this.x < 0) this.x = 0;
                if (this.x + this.width > gameWidth) this.x = gameWidth - this.width;
                if (this.y > gameHeight) { loseLife(); }
                if (this.shootCooldown > 0) { this.shootCooldown -= deltaTime; }
            }

            draw() {
                if (this.image && this.image.complete && this.image.naturalWidth !== 0) {
                    ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
                } else {
                    ctx.fillStyle = 'blue'; ctx.fillRect(this.x, this.y, this.width, this.height);
                }
            }
        }

        class Platform {
            constructor(x, y, width, height, color) {
                this.x = x; this.y = y; this.width = width; this.height = height; this.color = color;
            }
            draw() { ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, this.width, this.height); }
        }

        class Enemy {
            constructor(x, y, isBoss = false, bossData = null) {
                this.isBoss = isBoss;
                this.width = isBoss ? 100 : 40; this.height = isBoss ? 100 : 40;
                this.x = x; this.y = y - (this.height - 40);
                this.image = images.enemy;

                if (isBoss && bossData) {
                    this.health = bossData.health; this.maxHealth = bossData.health;
                    this.dx = bossData.speedX * (Math.random() < 0.5 ? 1 : -1);
                    this.dyBoss = bossData.speedY;
                    this.minY = bossData.minY; this.maxY = bossData.maxY;
                } else {
                    this.health = 1; this.maxHealth = 1;
                    this.dx = (Math.random() < 0.5 ? 1 : -1) * 2;
                }
            }

            update() {
                this.x += this.dx;
                if (this.isBoss) {
                    this.y += this.dyBoss;
                    if (this.y + this.height > this.maxY || this.y < this.minY) {
                        this.dyBoss *= -1; this.y += this.dyBoss;
                    }
                    if (this.x + this.width < 0) this.x = gameWidth;
                    else if (this.x > gameWidth) this.x = -this.width;
                } else {
                    if (this.x < 0 || this.x + this.width > gameWidth) { this.dx *= -1; }
                    let onPlatform = false; let groundAhead = false;
                    for (const platform of platforms) {
                        if (this.x + this.width > platform.x && this.x < platform.x + platform.width &&
                            this.y + this.height >= platform.y && this.y + this.height <= platform.y + platform.height + 5) {
                            onPlatform = true;
                            const lookAheadX = this.x + (this.dx > 0 ? this.width + 5 : -5);
                            for (const p of platforms) {
                                if (lookAheadX + (this.dx > 0 ? 0 : this.width) > p.x && lookAheadX + (this.dx > 0 ? 0 : this.width) < p.x + p.width &&
                                    this.y + this.height >= p.y && this.y + this.height <= p.y + p.height + 5) {
                                    groundAhead = true; break;
                                }
                            }
                            if (!groundAhead && onPlatform) { this.dx *= -1; }
                            break;
                        }
                    }
                }
            }
            draw() {
                if (this.image && this.image.complete && this.image.naturalWidth !== 0) {
                    ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
                } else {
                    ctx.fillStyle = this.isBoss ? 'purple' : 'red';
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                }
                if (this.isBoss && this.health < this.maxHealth) {
                    const barWidth = this.width; const barHeight = 10;
                    const barX = this.x; const barY = this.y - barHeight - 5;
                    ctx.fillStyle = '#555'; ctx.fillRect(barX, barY, barWidth, barHeight);
                    ctx.fillStyle = 'green'; ctx.fillRect(barX, barY, barWidth * (this.health / this.maxHealth), barHeight);
                }
            }
            takeDamage(amount) { this.health -= amount; return this.health <= 0; }
        }

        class Collectible {
            constructor(x, y, isDifficult = false) {
                this.x = x; this.y = y; this.width = 30; this.height = 30;
                this.emoji = 'ü•ó'; this.fontSize = 30;
                this.isDifficult = isDifficult;
            }
            draw() {
                ctx.font = `${this.fontSize}px Arial`; ctx.textAlign = "center";
                ctx.fillText(this.emoji, this.x + this.width/2, this.y + this.height - 5);
            }
        }

        class PowerUpCollectible {
            constructor(x, y) {
                this.x = x; this.y = y; this.width = 40; this.height = 40;
                this.emoji = 'üç≤'; this.fontSize = 40;
            }
            draw() {
                ctx.font = `${this.fontSize}px Arial`; ctx.textAlign = "center";
                ctx.fillText(this.emoji, this.x + this.width/2, this.y + this.height - 5);
            }
        }

        class Projectile {
            constructor(x, y, type, dx) {
                this.x = x; this.y = y; this.width = 20; this.height = 20;
                this.emoji = type; this.fontSize = 20; this.dx = dx;
            }
            update() { this.x += this.dx; }
            draw() {
                ctx.font = `${this.fontSize}px Arial`; ctx.textAlign = "center";
                ctx.fillText(this.emoji, this.x + this.width/2, this.y + this.height/2 + 5);
            }
        }

        const keys = {};
        let touchLeft = false, touchRight = false;

        window.addEventListener('keydown', (e) => { keys[e.code] = true; });
        window.addEventListener('keyup', (e) => { keys[e.code] = false; });

        function handleJumpPress() { if (gameState === 'PLAYING') player.jump(); }
        function handleShootPress() { if (gameState === 'PLAYING' && powerUpActive) player.shoot(); }

        window.addEventListener('keydown', (e) => {
            if (gameState !== 'PLAYING') return;
            if (e.code === 'ArrowUp' || e.code === 'KeyW') { e.preventDefault(); handleJumpPress(); }
            if (powerUpActive) {
                if (e.code === 'ArrowDown' || e.code === 'Space') { e.preventDefault(); handleShootPress(); }
            } else {
                if (e.code === 'Space') { e.preventDefault(); handleJumpPress(); }
            }
        });

        function setupTouchControls() {
            if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
                touchControlsDiv.style.display = 'flex';
                leftButton.addEventListener('touchstart', (e) => { e.preventDefault(); touchLeft = true; });
                leftButton.addEventListener('touchend', (e) => { e.preventDefault(); touchLeft = false; });
                rightButton.addEventListener('touchstart', (e) => { e.preventDefault(); touchRight = true; });
                rightButton.addEventListener('touchend', (e) => { e.preventDefault(); touchRight = false; });
                jumpButton.addEventListener('touchstart', (e) => { e.preventDefault(); handleJumpPress(); });
                shootButton.addEventListener('touchstart', (e) => { e.preventDefault(); handleShootPress(); });
            }
        }
        setupTouchControls();

        function AABB(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width && rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height && rect1.y + rect1.height > rect2.y;
        }
        
        function checkAndGrantExtraLife() {
            if (score >= nextLifeScoreThreshold) {
                lives++;
                nextLifeScoreThreshold += 1000;
                updateUI(); 
            }
        }

        function handleCollisions() {
            player.onGround = false;
            for (const platform of platforms) {
                if (AABB(player, platform)) {
                    if (player.dy > 0 && player.y + player.height - player.dy <= platform.y) {
                        player.y = platform.y - player.height; player.dy = 0; player.onGround = true; player.isJumping = false;
                    } else if (player.dx > 0 && player.x + player.width - player.dx <= platform.x) {
                        player.x = platform.x - player.width; player.dx = 0;
                    } else if (player.dx < 0 && player.x - player.dx >= platform.x + platform.width) {
                        player.x = platform.x + platform.width; player.dx = 0;
                    } else if (player.dy < 0 && player.y - player.dy >= platform.y + platform.height) {
                        player.y = platform.y + platform.height; player.dy = 0;
                    }
                }
            }

            for (let i = collectibles.length - 1; i >= 0; i--) {
                if (AABB(player, collectibles[i])) {
                    collectibles.splice(i, 1); score += 100;
                    checkAndGrantExtraLife(); 
                }
            }

            if (powerUpCollectible && AABB(player, powerUpCollectible)) {
                activatePowerUp(); powerUpCollectible = null;
            }

            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                if (AABB(player, enemy)) {
                    if (player.dy > 0 && (player.y + player.height - player.dy) <= enemy.y + enemy.height / 2) {
                        enemies.splice(i, 1); score += 200;
                        checkAndGrantExtraLife();
                        player.dy = -player.jumpForce / 2;
                        enemiesKilledForPowerUp++; checkSpawnPowerUp();
                        updateUI(); 
                    } else {
                        if (powerUpActive) { 
                            powerUpActive = false;
                            powerUpTimer = 0;
                            updateUI(); 
                        }
                        loseLife();
                    }
                }
            }

            if (boss && AABB(player, boss)) {
                if (player.dy > 0 && (player.y + player.height - player.dy) <= boss.y + boss.height / 3) {
                    if (boss.takeDamage(1)) {
                        defeatBoss(); 
                    } else {
                        player.dy = -player.jumpForce / 1.5;
                    }
                } else {
                     if (powerUpActive) { 
                        powerUpActive = false;
                        powerUpTimer = 0;
                        updateUI();
                    }
                    loseLife();
                }
            }

            for (let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];
                let projectileHit = false;
                for (let j = enemies.length - 1; j >= 0; j--) {
                    if (AABB(proj, enemies[j])) {
                        enemies.splice(j, 1); projectiles.splice(i, 1); projectileHit = true;
                        score += 250; 
                        checkAndGrantExtraLife(); 
                        enemiesKilledForPowerUp++; checkSpawnPowerUp();
                        updateUI();
                        break;
                    }
                }
                if (projectileHit) continue;
                if (boss && AABB(proj, boss)) {
                     if (boss.takeDamage(0.5)) { 
                        defeatBoss();
                    }
                    projectiles.splice(i, 1);
                }
                if (proj.x < 0 || proj.x > gameWidth) { projectiles.splice(i, 1); }
            }
        }

        function defeatBoss() {
            score += 5000;
            checkAndGrantExtraLife(); 
            boss = null;
            updateUI();
        }

        function loseLife() {
            lives--;
            updateUI(); 
            if (lives <= 0) {
                gameState = 'GAME_OVER';
                setTimeout(() => positionOverlayButton(retryButton, 0.75), 0);
            } else {
                const levelData = levels[currentLevel];
                player.x = levelData.playerStartX;
                player.y = levelData.playerStartPlatformTopY - player.height;
                player.dx = 0; player.dy = 0;
            }
        }
        
        function resetLevelTimer() {
            currentLevelTimeRemaining = LEVEL_TIME_LIMIT;
        }

        function updateUI() {
            livesDisplay.textContent = `Vite: ${lives}`;
            scoreDisplay.textContent = `Punteggio: ${score}`;
            timerDisplay.textContent = `Tempo: ${Math.max(0, Math.ceil(currentLevelTimeRemaining / 1000))}`;
            levelDisplay.textContent = `Livello: ${currentLevel + 1}`;

            if (powerUpActive) {
                powerUpTimerDisplay.textContent = `Chef Furioso: ${Math.ceil(powerUpTimer / 1000)}s`;
                if (currentLevel >= 0 && ('ontouchstart' in window || navigator.maxTouchPoints > 0)) { 
                    shootButton.style.display = 'flex';
                }
            } else {
                powerUpTimerDisplay.textContent = '';
                shootButton.style.display = 'none';
            }
        }

        function activatePowerUp() {
            powerUpActive = true;
            powerUpTimer = powerUpDuration;
            enemiesKilledForPowerUp = 0;
            updateUI();
        }

        function checkSpawnPowerUp() {
            const levelData = levels[currentLevel];
            if (levelData.powerUpEnabled && !powerUpActive && !powerUpCollectible && enemiesKilledForPowerUp >= powerUpSpawnThreshold) {
                let spawnX, spawnY;
                if (platforms.length > 1) {
                    const p = platforms[Math.floor(Math.random() * (platforms.length -1)) + 1];
                    spawnX = p.x + p.width / 2 - 20; spawnY = p.y - 50;
                } else {
                    spawnX = gameWidth / 2; spawnY = gameHeight - 150;
                }
                powerUpCollectible = new PowerUpCollectible(spawnX, spawnY);
                enemiesKilledForPowerUp = 0;
            }
        }

        function loadLevelElements(levelIndex) {
            const levelData = levels[levelIndex];
            platforms = levelData.platforms.map(p => new Platform(p.x, p.y, p.width, p.height, p.color));
            enemies = levelData.enemies.map(e => new Enemy(e.x, e.y, false));
            collectibles = levelData.collectibles.map(c => new Collectible(c.x, c.y, c.isDifficult));
            projectiles = [];
            powerUpCollectible = null;
            enemiesKilledForPowerUp = 0;
            resetLevelTimer();

            if (levelData.isBossLevel && levelData.bossData) {
                boss = new Enemy(levelData.bossData.x, levelData.bossData.y, true, levelData.bossData);
            } else {
                boss = null;
            }
            // Assicurati che player esista prima di accedervi
            if (player) {
                player.x = levelData.playerStartX;
                player.y = levelData.playerStartPlatformTopY - PLAYER_DEFAULT_HEIGHT;
                player.dx = 0; player.dy = 0;
            }
        }

        function loadLevel(levelIndex) {
            if (levelIndex >= levels.length) {
                gameState = 'VICTORY';
                setTimeout(() => positionOverlayButton(playAgainButton, 0.75), 0);
                return;
            }
            currentLevel = levelIndex;
            const levelData = levels[currentLevel];

            if (!player) { 
                 player = new Player(levelData.playerStartX, levelData.playerStartPlatformTopY - PLAYER_DEFAULT_HEIGHT);
            }
            loadLevelElements(currentLevel);

            canvas.style.backgroundColor = levelData.bgColor;
            updateUI();
            hideOverlayButtons();
            gameState = 'PLAYING';
        }

        function resetGame() {
            lives = 5;
            score = 0;
            nextLifeScoreThreshold = 1000; 
            powerUpActive = false; // Assicurati che il power-up sia disattivato all'inizio
            powerUpTimer = 0;
            currentLevel = 0;
            if (!player) { 
                 const firstLevelData = levels[0];
                 player = new Player(firstLevelData.playerStartX, firstLevelData.playerStartPlatformTopY - PLAYER_DEFAULT_HEIGHT);
            }
            loadLevel(currentLevel);
        }
        
        function checkLevelCompletion() {
            if (gameState !== 'PLAYING') return; // Non controllare se non si sta giocando

            const levelData = levels[currentLevel];
            const allCollectiblesTaken = collectibles.length === 0;
            const allEnemiesDefeated = enemies.length === 0;
            const bossDefeated = !levelData.isBossLevel || (levelData.isBossLevel && boss === null);

            if (allCollectiblesTaken && allEnemiesDefeated && bossDefeated) {
                gameState = 'LEVEL_COMPLETE';
                setTimeout(() => positionOverlayButton(nextLevelButton, 0.75), 0);
            }
        }

        let lastTime = 0;
        let titleFabioX = gameWidth * 0.1, titleFabioDir = 1;
        let titleEnemyX = gameWidth * 0.8, titleEnemyDir = -1;

        function gameLoop(timestamp) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            ctx.clearRect(0, 0, gameWidth, gameHeight);

            if (gameState === 'LOADING') {
                ctx.fillStyle = 'black'; ctx.fillRect(0,0,gameWidth, gameHeight);
                ctx.fillStyle = 'white'; ctx.font = '30px Arial';
                ctx.textAlign = 'center'; ctx.fillText('Caricamento Risorse...', gameWidth / 2, gameHeight / 2);
            } else if (gameState === 'TITLE') {
                ctx.fillStyle = '#70c5ce'; ctx.fillRect(0, 0, gameWidth, gameHeight);
                const bgImg = images.background;
                if (bgImg && bgImg.complete && bgImg.naturalWidth !== 0) {
                    const aspectRatio = bgImg.naturalWidth / bgImg.naturalHeight;
                    let drawHeight = gameHeight * 0.8; let drawWidth = drawHeight * aspectRatio;
                    if (drawWidth > gameWidth) { drawWidth = gameWidth * 0.9; drawHeight = drawWidth / aspectRatio; }
                    const drawX = (gameWidth - drawWidth) / 2; const drawY = gameHeight - drawHeight;
                    ctx.drawImage(bgImg, drawX, drawY, drawWidth, drawHeight);
                }
                ctx.textAlign = 'center';
                const titleY1 = gameHeight * 0.15; const titleOffset3D = Math.max(2, Math.floor(gameHeight * 0.008));
                const mainTextColor = '#FFD700'; const strokeColor = '#A0522D';
                const extrusionColor = '#502D0D'; const shadowColor = 'rgba(0, 0, 0, 0.5)';
                function drawEpicText(text, x, y, font, lineWidth) {
                    ctx.font = font; ctx.shadowColor = 'transparent';
                    ctx.fillStyle = extrusionColor; ctx.fillText(text, x + titleOffset3D, y + titleOffset3D);
                    ctx.shadowColor = shadowColor; ctx.shadowBlur = 6;
                    ctx.shadowOffsetX = titleOffset3D > 2 ? 2 : 1; ctx.shadowOffsetY = titleOffset3D > 2 ? 2 : 1;
                    ctx.strokeStyle = strokeColor; ctx.lineWidth = lineWidth; ctx.strokeText(text, x, y);
                    ctx.fillStyle = mainTextColor; ctx.fillText(text, x, y);
                    ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; ctx.shadowOffsetX = 0; ctx.shadowOffsetY = 0;
                }
                let fontSize1 = Math.max(35, Math.min(70, Math.floor(gameHeight * 0.14)));
                drawEpicText("Super Fabio", gameWidth / 2, titleY1, `bold ${fontSize1}px 'Comic Sans MS', cursive, sans-serif`, Math.max(3, fontSize1 * 0.05));
                let fontSize2 = Math.max(30, Math.floor(fontSize1 * 0.9));
                const titleY2 = titleY1 + Math.floor(fontSize1 * 0.95);
                drawEpicText("bros", gameWidth / 2, titleY2, `bold ${fontSize2}px 'Comic Sans MS', cursive, sans-serif`, Math.max(2, fontSize2 * 0.05));
                const playerSpriteHeight = PLAYER_DEFAULT_HEIGHT * (gameHeight / 450) * 0.8;
                const playerSpriteWidth = (images.player && images.player.naturalWidth > 0 ? (images.player.naturalWidth / images.player.naturalHeight) * playerSpriteHeight : playerSpriteHeight * 0.7);
                if (images.player && images.player.complete) {
                    titleFabioX += titleFabioDir * 0.8 * (deltaTime / 16);
                    if (titleFabioX > gameWidth * 0.3 || titleFabioX < gameWidth * 0.05) titleFabioDir *= -1;
                    ctx.drawImage(images.player, titleFabioX, gameHeight * 0.55, playerSpriteWidth, playerSpriteHeight);
                }
                const enemySpriteSize = 40 * (gameHeight / 450) * 0.9;
                if (images.enemy && images.enemy.complete) {
                    titleEnemyX += titleEnemyDir * 1.0 * (deltaTime / 16);
                    if (titleEnemyX > gameWidth * 0.9 || titleEnemyX < gameWidth * 0.65) titleEnemyDir *= -1;
                    ctx.drawImage(images.enemy, titleEnemyX, gameHeight * 0.6, enemySpriteSize, enemySpriteSize);
                }
                let saladFontSize = Math.max(25, Math.min(45, Math.floor(gameHeight * 0.09)));
                ctx.font = `${saladFontSize}px Arial`;
                ctx.fillText('ü•ó', gameWidth * 0.35, gameHeight * 0.7); ctx.fillText('ü•ó', gameWidth * 0.65, gameHeight * 0.45);
                if (startButton.style.display === 'none') { setTimeout(() => positionOverlayButton(startButton, 0.80), 0); }

            } else if (gameState === 'PLAYING') {
                currentLevelTimeRemaining -= deltaTime;
                if (currentLevelTimeRemaining <= 0) {
                    currentLevelTimeRemaining = 0; 
                    updateUI(); 
                    gameState = 'GAME_OVER'; 
                    setTimeout(() => positionOverlayButton(retryButton, 0.75), 0);
                }
                
                if (gameState === 'PLAYING') { 
                    const currentLevelData = levels[currentLevel];
                    ctx.fillStyle = currentLevelData.bgColor; ctx.fillRect(0, 0, gameWidth, gameHeight);
                    ctx.save();
                    if (currentLevelData.themeName === "Cielo Sereno") {
                        ctx.fillStyle = "white"; ctx.globalAlpha = 0.7;
                        ctx.beginPath(); ctx.arc(gameWidth * 0.15, gameHeight * 0.2, 30, 0, Math.PI * 2); ctx.fill();
                        ctx.beginPath(); ctx.arc(gameWidth * 0.2, gameHeight * 0.18, 40, 0, Math.PI * 2); ctx.fill();
                        ctx.beginPath(); ctx.arc(gameWidth * 0.7, gameHeight * 0.25, 50, 0, Math.PI * 2); ctx.fill();
                        ctx.beginPath(); ctx.arc(gameWidth * 0.75, gameHeight * 0.22, 35, 0, Math.PI * 2); ctx.fill();
                    } else if (currentLevelData.themeName === "Deserto Infuocato") {
                        ctx.fillStyle = "orange"; ctx.globalAlpha = 0.8;
                        ctx.beginPath(); ctx.arc(gameWidth - 80, 80, 50, 0, Math.PI * 2); ctx.fill();
                        ctx.fillStyle = "#A0522D"; ctx.globalAlpha = 0.6;
                        ctx.fillRect(gameWidth * 0.2, gameHeight - 100, 15, 60);
                        ctx.fillRect(gameWidth * 0.2 - 10, gameHeight - 80, 35, 15);
                        ctx.fillRect(gameWidth * 0.8, gameHeight - 120, 20, 80);
                    } else if (currentLevelData.themeName === "Foresta Omrbosa"){
                        ctx.globalAlpha = 0.5; const treeColors = ["#3A5F0B", "#556B2F", "#2E8B57"];
                        for(let i=0; i<3; i++){
                            ctx.fillStyle = treeColors[i % treeColors.length];
                            ctx.fillRect(gameWidth * (0.1 + i * 0.3), gameHeight - 140, 40, 100);
                            ctx.beginPath(); ctx.arc(gameWidth * (0.1 + i * 0.3) + 20, gameHeight - 140, 50, 0, Math.PI * 2); ctx.fill();
                        }
                    } else if (currentLevelData.themeName === "Metropoli Grigia") {
                        ctx.globalAlpha = 0.4; const buildingColors = ["#505050", "#606060", "#707070"];
                        for(let i=0; i<4; i++){
                            ctx.fillStyle = buildingColors[i % buildingColors.length];
                            ctx.fillRect(gameWidth * (0.05 + i * 0.25), gameHeight - (150 + Math.random()*100), 60, (150 + Math.random()*100));
                        }
                    } else if (currentLevelData.themeName === "Castello Oscuro") {
                        ctx.globalAlpha = 0.3; ctx.fillStyle = "#101010";
                        for(let i=0; i<3; i++){
                            ctx.fillRect(gameWidth * (0.2 + i * 0.3) , gameHeight * 0.3, 30, 50);
                            ctx.fillRect(gameWidth * (0.2 + i * 0.3) + 10 , gameHeight * 0.28, 10, 70);
                        }
                    }
                    ctx.restore();

                    for (const platform of platforms) platform.draw();
                    for (const collectible of collectibles) collectible.draw();
                    if (powerUpCollectible) powerUpCollectible.draw();
                    
                    if (player) player.update(deltaTime); // Assicura che player esista
                    if (player) player.draw();

                    for (const enemy of enemies) { enemy.update(); enemy.draw(); }
                    if (boss) { boss.update(); boss.draw(); }
                    for (const projectile of projectiles) { projectile.update(); projectile.draw(); }
                    
                    if (gameState === 'PLAYING') { 
                        handleCollisions();
                        if (powerUpActive) {
                            powerUpTimer -= deltaTime;
                            if (powerUpTimer <= 0) { powerUpActive = false; powerUpTimer = 0; }
                        }
                        updateUI();
                        checkLevelCompletion();
                    }
                }

            } else if (gameState === 'LEVEL_COMPLETE') {
                ctx.fillStyle = 'rgba(0,0,0,0.7)'; ctx.fillRect(0,0,gameWidth, gameHeight);
                ctx.fillStyle = 'white'; ctx.font = '40px Arial'; ctx.textAlign = 'center';
                ctx.fillText('Livello Completato!', gameWidth / 2, gameHeight / 2 - 30);
                ctx.font = '20px Arial';
                ctx.fillText(`Punteggio: ${score}`, gameWidth / 2, gameHeight / 2 + 20);
            } else if (gameState === 'GAME_OVER') {
                if (images.background && images.background.complete) {
                    ctx.drawImage(images.background, 0, 0, gameWidth, gameHeight);
                } else { ctx.fillStyle = 'black'; ctx.fillRect(0,0,gameWidth, gameHeight); }
                ctx.fillStyle = 'rgba(0,0,0,0.7)'; ctx.fillRect(0,0,gameWidth, gameHeight);
                ctx.fillStyle = 'red'; ctx.font = `bold ${Math.min(60, gameWidth*0.1)}px Arial`; ctx.textAlign = 'center';
                ctx.fillText('GAME OVER', gameWidth / 2, gameHeight / 2 - 40);
                ctx.fillStyle = 'white'; ctx.font = `${Math.min(30, gameWidth*0.05)}px Arial`;
                ctx.fillText(`Punteggio Finale: ${score}`, gameWidth / 2, gameHeight / 2 + 20);
            } else if (gameState === 'VICTORY') {
                 if (images.background && images.background.complete) {
                    ctx.drawImage(images.background, 0, 0, gameWidth, gameHeight);
                } else { ctx.fillStyle = '#FFD700'; ctx.fillRect(0,0,gameWidth, gameHeight); }
                ctx.fillStyle = 'rgba(0,100,0,0.4)'; ctx.fillRect(0,0,gameWidth, gameHeight);
                ctx.fillStyle = 'gold'; ctx.font = `bold ${Math.min(60, gameWidth*0.1)}px Arial`; ctx.textAlign = 'center';
                ctx.strokeStyle = 'darkgreen'; ctx.lineWidth = 3;
                ctx.strokeText('HAI VINTO!', gameWidth / 2, gameHeight / 2 - 40);
                ctx.fillText('HAI VINTO!', gameWidth / 2, gameHeight / 2 - 40);
                ctx.fillStyle = 'white'; ctx.font = `${Math.min(30, gameWidth*0.05)}px Arial`;
                ctx.fillText(`Punteggio Finale: ${score}`, gameWidth / 2, gameHeight / 2 + 20);
            }
            requestAnimationFrame(gameLoop);
        }

        startButton.addEventListener('click', () => {
            hideOverlayButtons();
            resetGame();
            if (backgroundMusic.paused) {
                backgroundMusic.play().catch(error => { console.warn("Riproduzione musica bloccata:", error); });
            }
        });
        retryButton.addEventListener('click', () => { hideOverlayButtons(); resetGame(); });
        playAgainButton.addEventListener('click', () => { hideOverlayButtons(); resetGame(); });
        nextLevelButton.addEventListener('click', () => {
            hideOverlayButtons(); currentLevel++; loadLevel(currentLevel);
        });

        loadImages(() => {
            console.log("Immagini caricate!");
            gameState = 'TITLE';
            setTimeout(() => {
                window.dispatchEvent(new Event('resize'));
                if (startButton.style.display !== 'block') { positionOverlayButton(startButton, 0.80); }
            }, 100);
            lastTime = performance.now();
            requestAnimationFrame(gameLoop);
        });
    </script>
</body>
</html>
