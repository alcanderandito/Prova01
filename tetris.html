<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tetris Polenta e Formai</title>
    <style>
        body {
            background-color: #4a3b31;
            color: #fff;
            font-family: 'Georgia', serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            margin: 0;
            padding: 10px;
            box-sizing: border-box;
            overflow-x: hidden;
        }

        .game-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: rgba(60, 45, 35, 0.85);
            padding: 15px;
            border-radius: 15px;
            box-shadow: 0 0 15px #ffcc66, 0 0 30px #ffcc66, inset 0 0 10px #ffcc66;
            width: 100%;
            max-width: 500px;
        }

        h1 {
            font-size: 2.2em;
            margin-bottom: 10px;
            color: #FFD700;
            text-shadow: 0 0 4px #DAA520, 0 0 8px #DAA520, 0 0 12px #DAA520, 0 0 16px #FFBF00, 0 0 24px #FFBF00;
            text-align: center;
            font-variant: small-caps;
        }

        .main-content {
            display: flex;
            align-items: flex-start;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            width: 100%;
        }

        .game-board-container {
            /* Contenitore per il canvas principale */
        }

        #gameCanvas {
            border: 3px solid #DAA520;
            box-shadow: 0 0 8px #DAA520, 0 0 12px #DAA520;
            background-color: #2a1f17;
            border-radius: 6px;
        }

        .info-and-next { /* Ora contiene solo il pannello info */
            display: flex;
            flex-direction: column;
            align-items: center; /* Centra info-panel su desktop se non c'è 'next' */
            gap: 10px;
            min-width: 120px; /* Mantiene una larghezza minima per il pannello info */
            flex-grow: 1;
        }

        .info-panel {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            font-size: 1.1em;
            background-color: rgba(90, 70, 55, 0.7);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 0 6px #FFA500, inset 0 0 4px #FFA500;
            width: 100%; /* Occupa lo spazio del genitore .info-and-next */
            max-width: 200px; /* Limita larghezza del pannello info su desktop */
        }

        .info-panel span {
            color: #FFFACD;
            text-shadow: 0 0 2px #F0E68C, 0 0 4px #F0E68C;
        }

        /* Rimosse le regole per .next-piece-container e #nextCanvas */

        .message-overlay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(42, 31, 23, 0.9);
            color: #FFFACD;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            z-index: 100;
            font-size: 1.2em;
            box-shadow: 0 0 8px #FFFACD, 0 0 15px #FFFACD;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 15px;
            min-width: 250px;
            max-width: 90%;
        }
        .message-overlay p { margin: 0; line-height: 1.3; }
        .message-overlay button {
            margin-top: 0;
            font-size: 0.7em !important;
            padding: 10px 18px !important;
        }

        .controls {
            margin-top: 20px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 8px;
            width: 180px;
            height: 230px;
        }

        .control-btn {
            background-color: rgba(255, 215, 0, 0.15);
            border: 2px solid #FFD700;
            color: #FFD700;
            font-size: 1.1em;
            border-radius: 8px;
            cursor: pointer;
            user-select: none;
            box-shadow: 0 0 4px #FFD700, 0 0 8px #FFD700, inset 0 0 4px rgba(255,215,0,0.5);
            transition: background-color 0.2s, box-shadow 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 5px;
        }
        .control-btn:active {
            background-color: rgba(255, 215, 0, 0.3);
            box-shadow: 0 0 6px #FFD700, 0 0 12px #FFD700, inset 0 0 6px rgba(255,215,0,0.7);
        }

        #up-btn    { grid-column: 2; grid-row: 1; }
        #left-btn  { grid-column: 1; grid-row: 2; }
        #right-btn { grid-column: 3; grid-row: 2; }
        #down-btn  { grid-column: 2; grid-row: 2; }
        #drop-btn  { grid-column: 2; grid-row: 3; }

        .empty-dpad-tl { grid-column: 1; grid-row: 1; visibility: hidden;}
        .empty-dpad-tr { grid-column: 3; grid-row: 1; visibility: hidden;}
        .empty-dpad-bl { grid-column: 1; grid-row: 3; visibility: hidden;}
        .empty-dpad-br { grid-column: 3; grid-row: 3; visibility: hidden;}


        .home-btn {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 1em;
            background-color: rgba(218, 165, 32, 0.3);
            border: 2px solid #DAA520;
            color: #DAA520;
            text-decoration: none;
            border-radius: 8px;
            box-shadow: 0 0 4px #DAA520, 0 0 8px #DAA520;
            transition: background-color 0.2s, box-shadow 0.2s;
        }
        .home-btn:hover, .home-btn:active {
            background-color: rgba(218, 165, 32, 0.5);
            box-shadow: 0 0 6px #DAA520, 0 0 12px #DAA520;
        }

        /* Media query per layout su schermi piccoli */
        @media (max-width: 520px) {
            .game-area {
                padding: 10px;
                padding-top: 15px; /* Mantiene un po' di spazio sopra il titolo */
            }
            h1 {
                font-size: 1.8em;
                margin-bottom: 15px; /* Spazio per l'info panel che si sposta sopra */
            }
            .main-content {
                flex-direction: column;
                align-items: center;
            }
            .info-and-next { /* Contenitore per info-panel */
                order: -1; /* Mette info prima del canvas */
                width: 100%;
                display: flex;
                justify-content: center; /* Centra .info-panel al suo interno */
                margin-bottom: 15px; /* Spazio tra info-panel e canvas */
            }
            .info-panel {
                 /* Gli stili di base rimangono (colore, ombra, etc) */
                 flex-direction: row; /* Dispone gli span interni orizzontalmente */
                 justify-content: space-around; /* Distribuisce gli span */
                 align-items: center;
                 width: auto; /* Larghezza basata sul contenuto */
                 max-width: 95%; /* Limita la larghezza massima del pannello info */
                 padding: 8px 10px; /* Padding interno del pannello */
                 flex-wrap: wrap; /* Se gli span sono troppi, vanno a capo */
                 gap: 10px; /* Spazio tra gli span se vanno a capo */
            }
            .info-panel span {
                white-space: nowrap; /* Evita che il testo dello span vada a capo */
            }
            .controls {
                margin-top: 15px; /* Ridotto spazio sopra i controlli */
            }
        }

    </style>
</head>
<body>
    <div class="game-area">
        <h1>Tetris Polenta e Formai</h1>
        <div class="main-content">
            <div class="game-board-container">
                <canvas id="gameCanvas"></canvas>
            </div>
            <div class="info-and-next">
                <div class="info-panel">
                    <span id="score">Score: 0</span>
                    <span id="lives">Vite: 3</span>
                    <span id="level">Livello: 1</span>
                </div>
                <!-- next-piece-container rimosso -->
            </div>
        </div>
         <div id="messageOverlay" class="message-overlay">
            <p id="messageText"></p>
            <button id="restartButton" class="control-btn">Ricomincia</button>
        </div>
        <div class="controls">
            <div class="empty-dpad-tl"></div>
            <button id="up-btn" class="control-btn">GIRA</button>
            <div class="empty-dpad-tr"></div>

            <button id="left-btn" class="control-btn">◄</button>
            <button id="down-btn" class="control-btn">▼</button>
            <button id="right-btn" class="control-btn">►</button>

            <div class="empty-dpad-bl"></div>
            <button id="drop-btn" class="control-btn">CADE</button>
            <div class="empty-dpad-br"></div>
        </div>
        <a href="index.html" class="home-btn">Torna alla Home</a>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        // Rimosso nextCanvas e nextCtx

        const scoreDisplay = document.getElementById('score');
        const livesDisplay = document.getElementById('lives');
        const levelDisplay = document.getElementById('level');

        const messageOverlay = document.getElementById('messageOverlay');
        const messageText = document.getElementById('messageText');
        const restartButton = document.getElementById('restartButton');

        const COLS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = 24;
        // Rimosso NEXT_CANVAS_GRID_SIZE

        canvas.width = COLS * BLOCK_SIZE;
        canvas.height = ROWS * BLOCK_SIZE;
        // Rimosse impostazioni dimensioni nextCanvas

        const COLORS = [ null, '#FFD700', '#FFFACD', '#FFA500', '#F0E68C', '#DAA520', '#FFFFE0', '#FFBF00' ];
        const SHADOW_COLORS = [ null, '#DAA520', '#F0E68C', '#E69500', '#D8C970', '#B8860B', '#E0DDB0', '#D9A300' ];

        const TETROMINOES = {
            'I': { shape: [[1,1,1,1]], colorIndex: 1 },
            'O': { shape: [[2,2],[2,2]], colorIndex: 2 },
            'T': { shape: [[0,3,0],[3,3,3]], colorIndex: 3 },
            'S': { shape: [[0,4,4],[4,4,0]], colorIndex: 4 },
            'Z': { shape: [[5,5,0],[0,5,5]], colorIndex: 5 },
            'J': { shape: [[6,0,0],[6,6,6]], colorIndex: 6 },
            'L': { shape: [[0,0,7],[7,7,7]], colorIndex: 7 }
        };
        const PIECE_KEYS = 'IOTZSLJ';

        let board = createBoard();
        let currentPiece;
        let nextPiece; // Variabile ancora necessaria per la logica di gioco
        let score;
        let lives;
        let level;
        let dropCounter;
        let dropInterval;
        let gameRunning;
        let gamePausedForMessage = false;

        const initialLives = 3;
        const initialDropInterval = 1000;
        const levelSpeedIncrease = 100;

        function createBoard() {
            return Array.from({ length: ROWS }, () => Array(COLS).fill(0));
        }

        function getRandomPiece() {
            const rand = Math.floor(Math.random() * PIECE_KEYS.length);
            const key = PIECE_KEYS[rand];
            const pieceData = TETROMINOES[key];
            return {
                shape: pieceData.shape.map(row => row.slice()),
                colorIndex: pieceData.colorIndex,
                x: Math.floor(COLS / 2) - Math.floor(pieceData.shape[0].length / 2),
                y: 0
            };
        }

        function drawBlock(ctxInstance, x, y, colorIndex, bs = BLOCK_SIZE, isGhost = false) {
            if (colorIndex === 0) return;
            ctxInstance.fillStyle = COLORS[colorIndex];
            if (isGhost) {
                ctxInstance.globalAlpha = 0.25;
                ctxInstance.strokeStyle = COLORS[colorIndex];
                ctxInstance.lineWidth = 1;
                ctxInstance.strokeRect(x * bs + 0.5, y * bs + 0.5, bs -1, bs -1);
            } else {
                ctxInstance.globalAlpha = 1.0;
                ctxInstance.shadowColor = SHADOW_COLORS[colorIndex];
                ctxInstance.shadowBlur = 6;
                ctxInstance.fillRect(x * bs, y * bs, bs, bs);

                ctxInstance.shadowBlur = 0;
                ctxInstance.strokeStyle = 'rgba(0,0,0,0.2)';
                ctxInstance.lineWidth = 1;
                ctxInstance.strokeRect(x * bs + 0.5, y * bs + 0.5, bs-1, bs-1);
            }
             ctxInstance.globalAlpha = 1.0;
        }

        function drawBoard() {
            board.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        drawBlock(ctx, x, y, value);
                    }
                });
            });
        }

        // drawPiece ora usa solo ctx per il tabellone principale
        function drawPiece(piece, ctxInstance = ctx, customOffsetX = 0, customOffsetY = 0, bs = BLOCK_SIZE) {
            piece.shape.forEach((row, yRel) => {
                row.forEach((value, xRel) => {
                    if (value !== 0) {
                        // Disegna solo sul canvas principale
                        let drawX = piece.x + xRel;
                        let drawY = piece.y + yRel;
                        drawBlock(ctxInstance, drawX, drawY, piece.colorIndex, bs);
                    }
                });
            });
        }

        function drawGhostPiece() {
            if (!currentPiece || !gameRunning) return;
            let ghostY = currentPiece.y;
            const ghostPieceShape = currentPiece.shape;
            const ghostPieceX = currentPiece.x;

            while (isValidMove(ghostPieceShape, ghostPieceX, ghostY + 1)) {
                ghostY++;
            }
            ghostPieceShape.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        drawBlock(ctx, ghostPieceX + x, ghostY + y, currentPiece.colorIndex, BLOCK_SIZE, true);
                    }
                });
            });
        }

        // Rimossa la funzione drawNextPiece()

        function clearCanvas() {
            ctx.fillStyle = '#2a1f17';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function update() {
            if (!gameRunning || gamePausedForMessage) return;

            dropCounter += (performance.now() - lastTime);
            lastTime = performance.now();

            if (dropCounter > dropInterval) {
                pieceDrop();
            }
        }

        function pieceMove(dir) {
            if (!gameRunning || gamePausedForMessage || !currentPiece) return;
            if (isValidMove(currentPiece.shape, currentPiece.x + dir, currentPiece.y)) {
                currentPiece.x += dir;
            }
        }

        function pieceRotate() {
            if (!gameRunning || gamePausedForMessage || !currentPiece) return;
            const originalShape = currentPiece.shape;
            const rotated = [];
            for (let y = 0; y < originalShape[0].length; y++) {
                rotated[y] = [];
                for (let x = 0; x < originalShape.length; x++) {
                    rotated[y][x] = originalShape[originalShape.length - 1 - x][y];
                }
            }
            if (isValidMove(rotated, currentPiece.x, currentPiece.y)) {
                currentPiece.shape = rotated;
            } else {
                if (isValidMove(rotated, currentPiece.x + 1, currentPiece.y)) {
                    currentPiece.x += 1; currentPiece.shape = rotated;
                } else if (isValidMove(rotated, currentPiece.x - 1, currentPiece.y)) {
                    currentPiece.x -= 1; currentPiece.shape = rotated;
                } else if (currentPiece.shape[0].length > 2 && isValidMove(rotated, currentPiece.x - 2, currentPiece.y)) {
                    currentPiece.x -= 2; currentPiece.shape = rotated;
                } else if (currentPiece.shape[0].length > 2 && isValidMove(rotated, currentPiece.x + 2, currentPiece.y)) {
                    currentPiece.x += 2; currentPiece.shape = rotated;
                }
            }
        }

        function pieceDrop(isHardDrop = false) {
            if (!gameRunning || gamePausedForMessage || !currentPiece) return;
            if (isHardDrop) {
                let moved = 0;
                while (isValidMove(currentPiece.shape, currentPiece.x, currentPiece.y + 1)) {
                    currentPiece.y++;
                    moved++;
                }
                if (moved > 0) score += Math.min(moved, 5);
                solidifyPiece();
            } else {
                if (isValidMove(currentPiece.shape, currentPiece.x, currentPiece.y + 1)) {
                    currentPiece.y++;
                } else {
                    solidifyPiece();
                }
            }
            dropCounter = 0;
            updateUI();
        }

        function isValidMove(shape, x, y) {
            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[r].length; c++) {
                    if (shape[r][c] !== 0) {
                        let newX = x + c;
                        let newY = y + r;
                        if (newX < 0 || newX >= COLS || newY >= ROWS || (newY >= 0 && board[newY][newX] !== 0) ) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        function solidifyPiece() {
            if(!currentPiece) return;
            currentPiece.shape.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        if (currentPiece.y + y < 0) {
                            handleGameOverCondition();
                            return;
                        }
                        board[currentPiece.y + y][currentPiece.x + x] = currentPiece.colorIndex;
                    }
                });
            });

            if (!gameRunning) return;

            clearLines();

            currentPiece = nextPiece; // nextPiece è stato generato in precedenza
            nextPiece = getRandomPiece(); // Genera il nuovo "nextPiece" per il ciclo successivo
            // Non c'è più drawNextPiece()

            if (currentPiece && !isValidMove(currentPiece.shape, currentPiece.x, currentPiece.y)) {
                handleGameOverCondition();
            }
        }

        function handleGameOverCondition() {
            gameRunning = false;
            lives--;
            updateUI();
            if (lives > 0) {
                showMessage(`Polenta bruciata! Vite: ${lives}`, true);
            } else {
                showMessage(`Game Over! Formaggio finito! Punteggio: ${score}`, true);
            }
        }

        function resetBoard() {
            hideMessage();
            gamePausedForMessage = false;
            board = createBoard();
            currentPiece = getRandomPiece();
            nextPiece = getRandomPiece();
            // Non c'è più drawNextPiece()
            dropCounter = 0;
            lastTime = performance.now();
            gameRunning = true;
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            gameLoop();
        }


        function clearLines() {
            let linesCleared = 0;
            for (let r = ROWS - 1; r >= 0; r--) {
                if (board[r].every(cell => cell !== 0)) {
                    linesCleared++;
                    board.splice(r, 1);
                    board.unshift(Array(COLS).fill(0));
                    r++;
                }
            }
            if (linesCleared > 0) {
                if (linesCleared === 1) score += 40 * level;
                else if (linesCleared === 2) score += 100 * level;
                else if (linesCleared === 3) score += 300 * level;
                else if (linesCleared >= 4) score += 1200 * level;

                let newLevel = Math.floor(score / 800) + 1;
                if (newLevel > level) {
                    level = newLevel;
                    dropInterval = Math.max(150, initialDropInterval - (level -1) * levelSpeedIncrease);
                }
            }
        }

        function showMessage(text, showRestartBtn = true) {
            messageText.textContent = text;
            restartButton.style.display = showRestartBtn ? 'inline-block' : 'none';
            messageOverlay.style.display = 'flex';
            gamePausedForMessage = true;
        }

        function hideMessage() {
            messageOverlay.style.display = 'none';
        }


        function updateUI() {
            scoreDisplay.textContent = `Score: ${score}`;
            livesDisplay.textContent = `Vite: ${lives}`;
            levelDisplay.textContent = `Livello: ${level}`;
        }

        let lastTime = 0;
        let animationFrameId = null;
        function gameLoop(time = 0) {
            if (gamePausedForMessage) {
                animationFrameId = requestAnimationFrame(gameLoop);
                return;
            }
            if (!gameRunning) {
                 if (animationFrameId) cancelAnimationFrame(animationFrameId);
                 animationFrameId = null;
                return;
            }

            update();

            clearCanvas();
            drawBoard();
            if(currentPiece) {
                drawGhostPiece();
                drawPiece(currentPiece);
            }

            lastTime = time;
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function initGame() {
            hideMessage();
            gamePausedForMessage = false;
            board = createBoard();
            score = 0;
            lives = initialLives;
            level = 1;
            dropInterval = initialDropInterval;
            currentPiece = getRandomPiece();
            nextPiece = getRandomPiece(); // Prepara il pezzo successivo per la logica interna
            // Non c'è più drawNextPiece()
            updateUI();
            dropCounter = 0;
            gameRunning = true;
            lastTime = performance.now();
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            gameLoop();
        }

        document.addEventListener('keydown', event => {
            if (!gameRunning || gamePausedForMessage || !currentPiece) return;
            if (event.key === 'ArrowLeft' || event.key === 'a') pieceMove(-1);
            else if (event.key === 'ArrowRight' || event.key === 'd') pieceMove(1);
            else if (event.key === 'ArrowDown' || event.key === 's') pieceDrop();
            else if (event.key === 'ArrowUp' || event.key === 'w' || event.key === 'x') pieceRotate();
            else if (event.key === ' ') {
                 event.preventDefault();
                 pieceDrop(true);
            }
        });

        document.getElementById('left-btn').addEventListener('click', () => pieceMove(-1));
        document.getElementById('right-btn').addEventListener('click', () => pieceMove(1));
        document.getElementById('down-btn').addEventListener('click', () => pieceDrop());
        document.getElementById('up-btn').addEventListener('click', () => pieceRotate());
        document.getElementById('drop-btn').addEventListener('click', () => pieceDrop(true));

        restartButton.addEventListener('click', () => {
            if (lives > 0 && !gameRunning) {
                resetBoard();
            } else if (lives <= 0) {
                initGame();
            }
        });

        initGame();
    </script>
</body>
</html>
