<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Home • Team Due Mori</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@500;700&family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
  <style>
    /* CSS INVARIATO DALLA VERSIONE "NUOVA BELLA" */
    :root {
      --font-primary: 'Roboto', -apple-system, Segoe UI, Arial, sans-serif;
      --font-secondary: 'Oswald', sans-serif;

      --color-text-light: #ffffff;
      --color-text-dark: #333;
      --color-text-muted: #6c757d;
      --color-text-placeholder: #888;
      --color-text-error: #dc3545;

      --color-bg-navbar: rgba(40, 40, 40, 0.85);
      --color-bg-navbar-solid: #282828;
      --color-bg-dropdown: #ffffff;
      --color-bg-dropdown-hover: #f8f9fa;
      --color-bg-dropdown-submenu: #f1f1f1;
      --color-bg-dynamic-fallback: #1a1a1a;
      --color-bg-overlay: rgba(0, 0, 0, 0.6);

      --color-accent-primary: #5cb85c;
      --color-accent-primary-light: #81c784;
      --color-accent-primary-dark: #388e3c;

      --color-chat-button: #25d366;
      --color-chat-button-hover: #2ecc71;
      --color-chat-button-active: #22b85b;

      --shadow-soft: rgba(0,0,0,0.1);
      --shadow-medium: rgba(0,0,0,0.2);
      --shadow-strong: rgba(0,0,0,0.3);
      --shadow-text-hero: rgba(0, 0, 0, 0.7);
      --shadow-text-hero-hover: rgba(255, 255, 255, 0.3);

      --navbar-height: 60px;
      --border-radius-small: 4px;
      --border-radius-medium: 8px;

      --transition-duration-fast: 0.2s;
      --transition-duration-normal: 0.3s;

      --z-index-background: 0;
      --z-index-snow: 1; /* Riutilizzato per il nuovo effetto particelle */
      --z-index-main-content: 2;
      --z-index-hero-title: 3;
      --z-index-page-overlay: 490;
      --z-index-navbar: 500;
      --z-index-dropdown-content: 501;
      --z-index-chat-button: 1000;
    }

    *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
    html { scroll-behavior: smooth; font-size: 16px; }
    body {
      font-family: var(--font-primary);
      height: 100%;
      overflow-x: hidden;
      background-color: var(--color-bg-dynamic-fallback);
      line-height: 1.6;
      color: var(--color-text-dark);
    }
    body.menu-open { overflow-y: hidden; }

    .navbar {
      background-color: var(--color-bg-navbar);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      padding: 0 20px;
      height: var(--navbar-height);
      position: fixed; top: 0; left: 0; width: 100%;
      z-index: var(--z-index-navbar);
      display: flex; align-items: center;
      box-shadow: 0 2px 10px var(--shadow-medium);
      transition: background-color var(--transition-duration-fast) ease;
    }

    .dropdown-button {
      background: transparent; color: var(--color-text-light);
      padding: 10px; font-size: 1rem; font-weight: 500;
      border: none; cursor: pointer; border-radius: var(--border-radius-small);
      font-family: var(--font-primary);
      transition: background-color var(--transition-duration-fast) ease, color var(--transition-duration-fast) ease;
      display: flex; align-items: center;
      text-shadow: 0 1px 2px var(--shadow-medium);
      position: relative;
    }
    .dropdown-button:hover, .dropdown-button:focus-visible {
      background-color: rgba(255,255,255,0.1); outline: none;
    }
    .menu-icon-container {
      width: 24px; height: 20px;
      display: flex; flex-direction: column; justify-content: space-between;
      margin-right: 10px; cursor: pointer; z-index: 1;
    }
    .menu-icon-container .line {
      display: block; height: 3px; width: 100%;
      background-color: var(--color-text-light); border-radius: 3px;
      transition: transform var(--transition-duration-normal) ease-in-out,
                  opacity var(--transition-duration-normal) ease-in-out;
    }
    .dropdown-button[aria-expanded="true"] .menu-icon-container .line1 { transform: translateY(8.5px) rotate(45deg); }
    .dropdown-button[aria-expanded="true"] .menu-icon-container .line2 { opacity: 0; }
    .dropdown-button[aria-expanded="true"] .menu-icon-container .line3 { transform: translateY(-8.5px) rotate(-45deg); }
    .dropdown-button-text { transition: color var(--transition-duration-fast) ease; }

    .dropdown-content {
      display: none; position: absolute;
      top: calc(var(--navbar-height) - 10px); left: 10px;
      background-color: var(--color-bg-dropdown);
      min-width: 250px; box-shadow: 0 8px 25px var(--shadow-strong);
      z-index: var(--z-index-dropdown-content);
      border-radius: var(--border-radius-medium);
      overflow: hidden; opacity: 0; transform: translateY(10px);
      transition: opacity var(--transition-duration-fast) ease-out, transform var(--transition-duration-fast) ease-out;
      max-height: calc(100vh - var(--navbar-height) - 20px); overflow-y: auto;
    }
    .dropdown-content.show { display: block; opacity: 1; transform: translateY(0); }
    .dropdown-content .menu-loading-placeholder, .dropdown-content .menu-message {
      padding: 20px; color: var(--color-text-placeholder); font-style: italic; text-align: center;
    }
    .dropdown-content ul { list-style-type: none; }
    .dropdown-content ul li a { /* Stile generale per link nel menu */
      color: var(--color-text-dark); padding: 12px 20px; text-decoration: none;
      display: block; font-size: 0.95rem; font-weight: 400;
      transition: background-color var(--transition-duration-fast) ease, color var(--transition-duration-fast) ease, padding-left var(--transition-duration-fast) ease;
      border-bottom: 1px solid #eee;
    }
    .dropdown-content ul li:last-child > a { border-bottom: none; } /* Solo se l'ultimo figlio è un 'a' diretto */
    .dropdown-content ul li > a:hover, 
    .dropdown-content ul li > a:focus-visible {
      background-color: var(--color-bg-dropdown-hover); color: var(--color-accent-primary);
      padding-left: 25px; outline: none;
    }

    /* Stili specifici per sottomenu e trigger */
    .dropdown-content ul li.submenu-item > .submenu-trigger { /* Stile per il trigger se è un 'a' diretto */
       /* Eredita stili da .dropdown-content ul li a, ma puoi sovrascrivere */
       display: flex; align-items: center; justify-content: space-between; width: 100%;
    }
    .dropdown-content ul li.submenu-item > .submenu-trigger .arrow {
      transition: transform var(--transition-duration-normal) ease; font-size: 0.8em; margin-left: 8px;
    }
    .dropdown-content ul li.submenu-item > .submenu-trigger.open .arrow { transform: rotate(180deg); }

    .dropdown-content ul li.submenu-item .submenu {
      display: none; padding-left: 0; background-color: var(--color-bg-dropdown-submenu);
      border-left: 3px solid var(--color-accent-primary);
      margin: 5px 10px 5px 15px; border-radius: var(--border-radius-small);
    }
    .dropdown-content ul li.submenu-item .submenu ul li a { /* Link dentro un sottomenu */
      padding: 10px 15px 10px 20px; font-size: 0.9em; border-bottom: 1px solid #e0e0e0;
    }
    .dropdown-content ul li.submenu-item .submenu ul li:last-child a { border-bottom: none; }
    .dropdown-content ul li.submenu-item .submenu ul li a:hover,
    .dropdown-content ul li.submenu-item .submenu ul li a:focus-visible {
      background-color: #e9e9e9; color: var(--color-text-dark); padding-left: 25px;
    }
    .dropdown-content ul li.submenu-item .submenu.open { display: block; }


    .page-overlay {
      display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background-color: var(--color-bg-overlay);
      z-index: var(--z-index-page-overlay);
      opacity: 0; transition: opacity var(--transition-duration-normal) ease;
    }
    .page-overlay.active { display: block; opacity: 1; }

    #goChatContainer { position: fixed; bottom: 25px; right: 25px; z-index: var(--z-index-chat-button); }
    #goChat{
      width: 60px; height: 60px; border: none; border-radius: 50%;
      background: var(--color-chat-button) url("https://img.icons8.com/ios-filled/50/ffffff/chat--v1.png") center/50% no-repeat;
      box-shadow: 0 5px 15px var(--shadow-medium), 0 2px 8px var(--shadow-soft);
      cursor: pointer; transition: all var(--transition-duration-fast) ease-out;
    }
    #goChat:hover, #goChat:focus-visible {
      transform: translateY(-4px) scale(1.1);
      box-shadow: 0 8px 20px var(--color-chat-button-hover), 0 4px 10px var(--shadow-medium);
      background-color: var(--color-chat-button-hover);
      outline: 3px solid rgba(255,255,255,0.3); outline-offset: 2px;
    }
    #goChat:active{ transform: translateY(0px) scale(1); background-color: var(--color-chat-button-active); }

    #dynamic-background-container {
      position: fixed; top: 0; left: 0; width: 100%; height: 100vh;
      z-index: var(--z-index-background); overflow: hidden;
      background-color: var(--color-bg-dynamic-fallback);
    }
    .background-slide {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background-size: cover; background-position: center center;
      opacity: 0; transition: opacity 1.8s cubic-bezier(0.4, 0, 0.2, 1);
      transform: scale(1.03);
    }
    .background-slide.active {
      opacity: 1; animation: kenburns 20s infinite alternate ease-in-out;
    }
    @keyframes kenburns { 0% { transform: scale(1.03) translate(0%, 0%); } 100% { transform: scale(1.10) translate(-1%, 1%); } }
    .background-slide.active.even-slide-kenburns { animation-name: kenburns-alt; }
    @keyframes kenburns-alt { 0% { transform: scale(1.03) translate(0%, 0%); } 100% { transform: scale(1.10) translate(1%, -1%); } }

    #hero-title-container {
      position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      text-align: center; color: var(--color-text-light);
      z-index: var(--z-index-hero-title);
      padding: 20px; width: 90%; max-width: 900px;
      transition: text-shadow var(--transition-duration-fast) ease;
    }
    #hero-title-container:hover {
      text-shadow: 0 0 15px var(--shadow-text-hero-hover), 0 0 25px var(--shadow-text-hero-hover);
    }
    #hero-title-container h1, #hero-title-container p {
      opacity: 0; transform: translateY(20px);
    }
    #hero-title-container h1 {
      font-family: var(--font-secondary); font-size: 2.8rem; font-weight: 700;
      margin-bottom: 0.5em; line-height: 1.2; letter-spacing: 1.5px; text-transform: uppercase;
      background: linear-gradient(45deg, var(--color-text-light), #f0e0c0);
      -webkit-background-clip: text; background-clip: text; color: transparent;
      filter: drop-shadow(0px 4px 8px var(--shadow-text-hero));
      animation: fadeInUp 0.8s 0.5s ease-out forwards;
    }
    #hero-title-container p {
      font-family: var(--font-primary); font-size: 1.1rem; font-weight: 300;
      line-height: 1.7; opacity: 0; /* Opacità iniziale a 0 per animazione */
      text-shadow: 0px 2px 6px var(--shadow-text-hero);
      max-width: 700px; margin-left: auto; margin-right: auto;
      animation: fadeInUp 0.8s 0.8s ease-out forwards;
    }
    @keyframes fadeInUp { to { opacity: 1; transform: translateY(0); } }

    .main-content {
      position: relative; z-index: var(--z-index-main-content);
      padding-top: calc(var(--navbar-height) + 30px);
      padding-left: 25px; padding-right: 25px; padding-bottom: 80px;
      min-height: 100vh;
    }

    #particle-effect-canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: var(--z-index-snow);
    }

    @media (max-width: 768px) {
      :root { --navbar-height: 55px; }
      .dropdown-button { padding: 8px; }
      .menu-icon-container { margin-right: 8px; width: 22px; height: 18px;}
      .menu-icon-container .line { height: 2.5px; }
      .dropdown-button[aria-expanded="true"] .menu-icon-container .line1 { transform: translateY(7.75px) rotate(45deg); }
      .dropdown-button[aria-expanded="true"] .menu-icon-container .line3 { transform: translateY(-7.75px) rotate(-45deg); }

      .dropdown-content {
        position: fixed; top: var(--navbar-height); left: 0;
        width: 100vw; max-width: 100vw; min-width: auto;
        height: calc(100vh - var(--navbar-height)); max-height: calc(100vh - var(--navbar-height));
        border-radius: 0; margin-top: 0;
        box-shadow: none; border-top: 1px solid rgba(255,255,255,0.1);
        transform: translateX(-100%);
        transition: transform var(--transition-duration-normal) ease-in-out;
      }
      .dropdown-content.show { transform: translateX(0); }
      .dropdown-content ul li a { padding: 15px 25px; font-size: 1rem; }
      .dropdown-content ul li.submenu-item .submenu {
        margin: 0; border-radius: 0; border-left: none; border-top: 2px solid var(--color-accent-primary);
      }
      .dropdown-content ul li.submenu-item .submenu ul li a { padding-left: 35px; }

      #hero-title-container h1 { font-size: 2.2rem; letter-spacing: 1px; }
      #hero-title-container p { font-size: 1rem; line-height: 1.6; }
      #goChat { width: 55px; height: 55px; background-size: 45%; }
      #goChatContainer { bottom: 20px; right: 20px; }
    }
    @media (min-width: 769px) {
      #hero-title-container h1 { font-size: 3.5rem; letter-spacing: 2px;}
      #hero-title-container p { font-size: 1.25rem; }
    }
    @media (min-width: 993px) {
      #hero-title-container h1 { font-size: 4.2rem; }
      #hero-title-container p { font-size: 1.4rem; }
    }
  </style>
</head>
<body>
  <div class="page-overlay" id="pageOverlay"></div>
  <header class="navbar">
    <nav class="dropdown">
        <button class="dropdown-button" id="menuButton" aria-haspopup="true" aria-expanded="false" aria-controls="menuContent">
            <span class="menu-icon-container" aria-hidden="true">
                <span class="line line1"></span>
                <span class="line line2"></span>
                <span class="line line3"></span>
            </span>
            <span class="dropdown-button-text">Menu</span>
        </button>
        <div id="menuContent" class="dropdown-content" role="menu" aria-labelledby="menuButton">
            <p class="menu-loading-placeholder">Caricamento menu...</p>
        </div>
    </nav>
  </header>

  <canvas id="particle-effect-canvas"></canvas>
  <div id="dynamic-background-container"></div>
  <div id="hero-title-container"><h1>Team Due Mori</h1><p>Il Dream Team (almeno la mattina, dopo il caffè).</p></div>
  <main class="main-content">
      <!-- IL TUO CONTENUTO VA QUI! -->
   </main>
  <div id="goChatContainer"><a href="chat.html" aria-label="Apri chat"><button id="goChat" aria-label="Avvia chat"></button></a></div>
  <audio id="indexPageSong" src="indexsong.mp3" loop preload="metadata"></audio>

  <script>
    console.log("SCRIPT: Inizio esecuzione blocco script.");

    const ready = (callback) => {
        console.log("SCRIPT: Funzione ready definita.");
        if (document.readyState !== "loading") {
            console.log("SCRIPT: DOM già caricato, eseguo callback di ready.");
            callback();
        } else {
            console.log("SCRIPT: DOM non ancora caricato, aggiungo listener DOMContentLoaded.");
            document.addEventListener("DOMContentLoaded", () => {
                console.log("SCRIPT: Evento DOMContentLoaded scattato, eseguo callback di ready.");
                callback();
            });
        }
    };

    // --- GESTIONE MENU ---
    const menuButton = document.getElementById("menuButton");
    const menuContent = document.getElementById("menuContent");
    const pageOverlay = document.getElementById("pageOverlay");

    function closeAllSubmenus(container) {
      console.log("SUBMENU: closeAllSubmenus chiamata.");
      if (!container) {
        console.error("SUBMENU: Errore in closeAllSubmenus - container non definito.");
        return;
      }
      container.querySelectorAll('.submenu.open').forEach(submenu => {
        submenu.classList.remove('open');
        const parentItem = submenu.closest('.submenu-item');
        if (parentItem) {
          const trigger = parentItem.querySelector('.submenu-trigger');
          if (trigger) {
            trigger.classList.remove('open');
            trigger.setAttribute('aria-expanded', 'false');
          }
        }
      });
    }

    function toggleSubmenu(event, triggerElement) {
      event.preventDefault();
      event.stopPropagation(); // Evita che il click chiuda immediatamente il menu principale
      console.log("SUBMENU: toggleSubmenu chiamata per:", triggerElement);

      const parentItem = triggerElement.closest('.submenu-item');
      if (!parentItem) {
        console.error("SUBMENU: Elemento .submenu-item genitore non trovato per il trigger:", triggerElement);
        return;
      }
      const submenu = parentItem.querySelector('.submenu');
      if (!submenu) {
        console.error("SUBMENU: Elemento .submenu non trovato dentro:", parentItem);
        return;
      }

      const isCurrentlyOpen = submenu.classList.contains('open');

      // Chiudi altri sottomenu aperti nello stesso menu principale (ma non in sottomenu annidati)
      if (!isCurrentlyOpen) {
          const menuRoot = triggerElement.closest('.dropdown-content'); // o un selettore più specifico se hai sottomenu di sottomenu
          if(menuRoot){
            menuRoot.querySelectorAll('.submenu-item > .submenu-trigger.open').forEach(otherTrigger => {
                if (otherTrigger !== triggerElement) {
                    const otherParentItem = otherTrigger.closest('.submenu-item');
                    if(otherParentItem){
                        const otherSubmenu = otherParentItem.querySelector('.submenu');
                        if (otherSubmenu && otherSubmenu.classList.contains('open')) {
                            otherSubmenu.classList.remove('open');
                            otherTrigger.classList.remove('open');
                            otherTrigger.setAttribute('aria-expanded', 'false');
                        }
                    }
                }
            });
          }
      }
      
      submenu.classList.toggle('open', !isCurrentlyOpen);
      triggerElement.classList.toggle('open', !isCurrentlyOpen);
      triggerElement.setAttribute('aria-expanded', String(!isCurrentlyOpen));
    }

    function setupSubmenuEventListeners(container) {
        console.log("SUBMENU: setupSubmenuEventListeners chiamata.");
        if (!container) {
            console.error("SUBMENU: Errore in setupSubmenuEventListeners - container non definito.");
            return;
        }
        const submenuTriggers = container.querySelectorAll('.submenu-trigger');
        submenuTriggers.forEach(trigger => {
            // Per evitare di aggiungere listener multipli se la funzione viene chiamata più volte
            // sullo stesso contenuto (improbabile con innerHTML, ma per sicurezza).
            // Una semplice alternativa è non fare nulla se il listener è già stato "taggato".
            if (trigger.dataset.submenuListenerAttached === 'true') {
                return;
            }

            trigger.addEventListener('click', (event) => {
                toggleSubmenu(event, trigger);
            });
            trigger.dataset.submenuListenerAttached = 'true'; // Segna che il listener è stato aggiunto

            // Assicura stato ARIA iniziale corretto basato sulla classe 'open' (se presente da HTML statico)
            const parentItem = trigger.closest('.submenu-item');
            const submenu = parentItem ? parentItem.querySelector('.submenu') : null;
            const isInitiallyOpen = submenu && submenu.classList.contains('open');
            trigger.setAttribute('aria-expanded', String(isInitiallyOpen));

        });
        console.log(`SUBMENU: Aggiunti listener a ${submenuTriggers.length} trigger di sottomenu.`);
    }

    function toggleMenu() {
      console.log("MENU: toggleMenu chiamata.");
      const isCurrentlyExpanded = menuButton.getAttribute("aria-expanded") === "true";
      menuButton.setAttribute("aria-expanded", String(!isCurrentlyExpanded));
      menuContent.classList.toggle("show", !isCurrentlyExpanded);
      pageOverlay.classList.toggle("active", !isCurrentlyExpanded);
      document.body.classList.toggle("menu-open", !isCurrentlyExpanded);

      if (!isCurrentlyExpanded && (menuContent.querySelector('.menu-loading-placeholder') || menuContent.innerHTML.trim() === '')) {
        console.log("MENU: Fetching menu.html...");
        fetch('menu.html')
          .then(response => { 
            if (!response.ok) { throw new Error(`Network response not ok: ${response.status} ${response.statusText}`); } 
            return response.text(); 
          })
          .then(data => { 
            menuContent.innerHTML = data.trim() === '' ? `<p class="menu-message">Menu vuoto.</p>` : data;
            // FONDAMENTALE: Aggancia gli event listener ai sottomenu appena caricati
            setupSubmenuEventListeners(menuContent); 
          })
          .catch(error => { 
            menuContent.innerHTML = `<p class="menu-message" style="color: var(--color-text-error);">Errore caricamento menu.</p>`; 
            console.error('MENU: Errore fetch menu.html:', error); 
          });
      } else if (isCurrentlyExpanded) {
        // Se il menu si sta chiudendo, chiudi tutti i sottomenu aperti al suo interno
        closeAllSubmenus(menuContent);
      }
    }

    if (menuButton) {
        menuButton.addEventListener('click', toggleMenu);
    } else {
        console.error("MENU: Bottone menu (#menuButton) non trovato!");
    }

    if (pageOverlay) {
        pageOverlay.addEventListener('click', () => {
            if (menuButton && menuButton.getAttribute("aria-expanded") === "true") {
                toggleMenu();
            }
        });
    } else {
        console.warn("MENU: Page overlay (#pageOverlay) non trovato.");
    }
    
    window.addEventListener('keydown', (event) => {
        if (event.key === 'Escape' && menuButton && menuButton.getAttribute("aria-expanded") === "true") {
            toggleMenu();
        }
    });
    console.log("SCRIPT: Gestori eventi menu e sottomenu definiti.");

    // --- SFONDO DINAMICO ---
    function initDynamicBackground() {
      console.log("SFONDO: initDynamicBackground chiamata.");
      const container = document.getElementById('dynamic-background-container');
      if (!container) { console.error("SFONDO: #dynamic-background-container non trovato!"); return; }
      const images = ['home.PNG', 'home1.PNG', 'home2.PNG', 'home3.PNG', 'home4.PNG', 'home5.PNG', 'home6.PNG', 'home7.PNG'];
      if (images.length === 0) { console.warn("SFONDO: Nessuna immagine definita."); container.innerHTML = '<p style="color:white; text-align:center; padding-top:20px;">Nessuna immagine per lo sfondo.</p>'; return; }
      
      let currentIndex = -1; 
      const slideDuration = 7000; // Durata di visualizzazione di una slide prima del cambio
      const animDurationCSS = 20; // Deve corrispondere alla durata dell'animazione Ken Burns nel CSS (in secondi)

      images.forEach((imgName, i) => { 
        const slide = document.createElement('div'); 
        slide.classList.add('background-slide'); 
        try { 
          // Verifica base se il nome è valido come parte di un URL. Non valida l'esistenza del file.
          new URL(imgName, window.location.origin + window.location.pathname); 
          slide.style.backgroundImage = `url('${imgName}')`; 
        } catch (e) { 
          console.error(`SFONDO: Nome immagine non valido o percorso problematico "${imgName}". Errore: ${e.message}. Slide non aggiunta.`); 
          return; // Salta questa immagine
        } 
        if (i % 2 !== 0) slide.classList.add('even-slide-kenburns'); 
        container.appendChild(slide); 
      });
      
      const slides = container.querySelectorAll('.background-slide');
      if (slides.length === 0) { console.error("SFONDO: Nessuna slide valida creata/aggiunta. Lo sfondo dinamico non partirà."); return; }
      
      function nextSlide() { 
        if (currentIndex >= 0 && slides[currentIndex]) { 
          slides[currentIndex].classList.remove('active'); 
          slides[currentIndex].style.animation = 'none'; // Resetta l'animazione per poterla riapplicare
          void slides[currentIndex].offsetHeight; // Forza reflow per riavviare l'animazione correttamente
        } 
        currentIndex = (currentIndex + 1) % slides.length; 
        if (slides[currentIndex]) { 
          slides[currentIndex].classList.add('active'); 
          const animName = slides[currentIndex].classList.contains('even-slide-kenburns') ? 'kenburns-alt' : 'kenburns'; 
          slides[currentIndex].style.animation = `${animName} ${animDurationCSS}s infinite alternate ease-in-out`; 
        } 
      }
      nextSlide(); // Mostra la prima slide immediatamente
      setInterval(nextSlide, slideDuration);
      console.log(`SFONDO: Inizializzazione completata con ${slides.length} slide.`);
    }

    // --- NUOVO EFFETTO PARTICELLE LUMINOSE ---
    function initParticleEffect() {
        console.log("PARTICLES: initParticleEffect chiamata.");
        const canvas = document.getElementById('particle-effect-canvas');
        if (!canvas) {
            console.error("PARTICLES: #particle-effect-canvas NON TROVATO!");
            return;
        }
        const ctx = canvas.getContext('2d');
        let particlesArray = []; // Dichiarata qui per essere accessibile in tutto lo scope di initParticleEffect

        function setCanvasSize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        setCanvasSize();

        class Particle {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.size = Math.random() * 2 + 0.5;
                this.speedX = (Math.random() * 0.8 - 0.4);
                this.speedY = (Math.random() * 0.8 - 0.4);
                this.baseOpacity = Math.random() * 0.4 + 0.2;
                this.opacity = this.baseOpacity;
                this.opacitySpeed = (Math.random() - 0.5) * 0.01;
            }

            update() {
                this.x += this.speedX;
                this.y += this.speedY;
                this.opacity += this.opacitySpeed;
                if (this.opacity > this.baseOpacity + 0.2 || this.opacity < this.baseOpacity - 0.2) {
                    this.opacitySpeed *= -1;
                }
                if (this.opacity < 0) this.opacity = 0;
                if (this.opacity > 1) this.opacity = 1;

                if (this.x < -this.size) this.x = canvas.width + this.size;
                if (this.x > canvas.width + this.size) this.x = -this.size;
                if (this.y < -this.size) this.y = canvas.height + this.size;
                if (this.y > canvas.height + this.size) this.y = -this.size;
            }

            draw() {
                ctx.fillStyle = `rgba(255, 255, 230, ${this.opacity})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function initParticles() {
            particlesArray = []; // Svuota e ricrea l'array
            const numberOfParticles = Math.max(50, Math.floor((canvas.width * canvas.height) / 15000));
            console.log("PARTICLES: Creando", numberOfParticles, "particelle.");
            for (let i = 0; i < numberOfParticles; i++) {
                particlesArray.push(new Particle());
            }
        }

        let animationFrameId = null; // Per poter cancellare il frame se necessario
        function animateParticles() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (let i = 0; i < particlesArray.length; i++) {
                particlesArray[i].update();
                particlesArray[i].draw();
            }
            animationFrameId = requestAnimationFrame(animateParticles);
        }

        initParticles();
        animateParticles();
        console.log("PARTICLES: Animazione particelle avviata.");

        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                console.log("PARTICLES: Finestra ridimensionata, riadatto canvas e particelle.");
                setCanvasSize();
                // Cancella il vecchio loop di animazione prima di iniziarne uno nuovo
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                }
                initParticles(); 
                animateParticles(); // Riavvia l'animazione con le nuove particelle
            }, 250);
        });
        console.log("PARTICLES: Inizializzazione effetto particelle completata.");
    }

    // --- AUDIO PLAYER ---
    function initAudioPlayer() {
      console.log("AUDIO: initAudioPlayer chiamata.");
      const song = document.getElementById('indexPageSong');
      if (!song) { console.error("AUDIO: #indexPageSong non trovato."); return; }
      
      let hasInteracted = false;
      const interactionEvents = ['click', 'scroll', 'touchstart', 'keydown'];
      let eventListeners = [];

      const tryPlayMusic = (eventSource) => {
        // Se la musica sta già suonando o è già stata avviata da interazione, non fare nulla
        if (song.currentTime > 0 && !song.paused && !song.ended || hasInteracted) {
          removeInteractionListeners(); // Rimuovi i listener una volta che la musica è partita o l'interazione è avvenuta
          return;
        }
        
        hasInteracted = true; // Segna che c'è stata un'interazione
        song.play().then(() => {
          console.log(`AUDIO: Riproduzione avviata (${eventSource}).`);
          removeInteractionListeners(); // Successo, rimuovi i listener
        }).catch(e => {
          console.warn(`AUDIO: Play fallito (${eventSource}): ${e.name} - ${e.message}. L'utente potrebbe dover interagire di nuovo o il browser potrebbe averlo bloccato.`);
          hasInteracted = false; // Play fallito, resetta per permettere un altro tentativo
          // Non rimuovere i listener se il play fallisce, l'utente potrebbe provare un'altra interazione
        });
      };

      function addInteractionListener(target, eventType) {
        const handler = () => tryPlayMusic(eventType);
        target.addEventListener(eventType, handler, { once: true, passive: true });
        eventListeners.push({ target, eventType, handler });
      }

      function removeInteractionListeners() {
        if (eventListeners.length > 0) {
          console.log("AUDIO: Rimozione listener di interazione.");
          eventListeners.forEach(listener => {
            listener.target.removeEventListener(listener.eventType, listener.handler);
          });
          eventListeners = []; // Svuota l'array
        }
      }

      // Tenta l'autoplay immediato
      song.play().then(() => {
        console.log("AUDIO: Autoplay riuscito all'avvio.");
        hasInteracted = true; // Considera l'autoplay come un'interazione riuscita
      }).catch((error) => {
        console.warn(`AUDIO: Autoplay iniziale bloccato: ${error.name} - ${error.message}. In attesa di interazione utente.`);
        // Se l'autoplay fallisce, aggiungi i listener per le interazioni utente
        interactionEvents.forEach(eventType => {
          // Per 'scroll' e 'keydown', ascolta su window. Per gli altri su document.body.
          const target = (eventType === 'scroll' || eventType === 'keydown') ? window : document.body;
          addInteractionListener(target, eventType);
        });
        console.log("AUDIO: Listener di interazione aggiunti.");
      });
      console.log("AUDIO: Inizializzazione completata.");
    }

    // --- ESECUZIONE SCRIPT AL CARICAMENTO DEL DOM ---
    console.log("SCRIPT: Aggiungo listener per 'ready'.");
    ready(() => {
      console.log("SCRIPT: Callback di 'ready' ESEGUITA. Avvio funzioni principali.");
      
      console.log("SCRIPT: Chiamata a initDynamicBackground...");
      if (typeof initDynamicBackground === 'function') initDynamicBackground(); else console.error("Errore: initDynamicBackground non è una funzione.");
      
      console.log("SCRIPT: Chiamata a initParticleEffect...");
      if (typeof initParticleEffect === 'function') initParticleEffect(); else console.error("Errore: initParticleEffect non è una funzione.");
      
      console.log("SCRIPT: Chiamata a initAudioPlayer...");
      if (typeof initAudioPlayer === 'function') initAudioPlayer(); else console.error("Errore: initAudioPlayer non è una funzione.");
      
      // Non è necessario chiamare setupSubmenuEventListeners qui perché il menu
      // viene caricato solo quando l'utente clicca il bottone del menu.
      // Viene chiamato DENTRO toggleMenu() dopo il fetch.

      console.log("SCRIPT: Tutte le funzioni principali (tranne quelle legate al menu dinamico) sono state chiamate.");
    });

    console.log("SCRIPT: Fine blocco script.");
  </script>
</body>
</html>
