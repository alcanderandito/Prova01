<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <!-- Titolo Aggiornato -->
  <title>Home • Team Due Mori - Magia & Gusto</title>

  <!-- Importazione Font da Google Fonts (Aggiunto Orbitron, mantenuto Roboto) -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto:wght@300;400&display=swap" rel="stylesheet">

  <style>
    /* mini‑reset */
    *{margin:0;padding:0;box-sizing:border-box}
    html,body{
      /* Mantenuto font-family base Roboto */
      font-family: 'Roboto', -apple-system, Segoe UI, Arial, sans-serif;
      height: 100%;
      width: 100%; /* Aggiunto per sicurezza */
      overflow: hidden; /* Impedisce scroll sulla pagina principale */
      background-color: #0a0514; /* Fallback background scuro */
      color: #fff; /* Colore testo default bianco */
    }

    /* === Contenitore Canvas Three.js (NUOVO) === */
    #three-canvas-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -1; /* Dietro tutto il resto */
    }
    canvas {
        display: block; /* Rimuove spazio extra sotto il canvas */
    }

    /* === NAVBAR STILIZZATA (Modifica stili esistenti .navbar) === */
    .navbar {
      /* Mantenuti: position, top, left, width, z-index, display, align-items */
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      z-index: 1000; /* Aumentato z-index per stare sopra canvas 3D */
      display: flex;
      align-items: center;
      /* Stili Magici (Sostituiscono/Aggiungono) */
      padding: 12px 25px;
      background: linear-gradient(180deg, rgba(15, 5, 35, 0.85) 0%, rgba(26, 10, 42, 0.75) 100%);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px); /* Per Safari */
      box-shadow: 0 4px 20px rgba(128, 0, 255, 0.4), 0 1px 5px rgba(50, 150, 255, 0.3);
      border-bottom: 1px solid rgba(170, 100, 255, 0.6);
    }

    /* === DROPDOWN (Contenitore originale - Nessuna modifica necessaria qui) === */
    .dropdown {
      position: relative;
      display: inline-block;
    }

    /* === BOTTONE MENU STILIZZATO (Modifica stili esistenti .dropdown-button) === */
    .dropdown-button {
      /* Reset/Modifica stili precedenti */
      padding: 0; /* Rimosso padding testo */
      font-size: 22px; /* Dimensione icona placeholder */
      border: 1px solid rgba(170, 100, 255, 0.7); /* Bordo luminoso */
      /* font-family rimosso, non più testo */
      /* Stili magici */
      background: rgba(255, 255, 255, 0.1); /* Sfondo leggero */
      color: #e0c0ff; /* Colore icona */
      border-radius: 50%; /* Forma circolare */
      width: 45px;
      height: 45px;
      cursor: pointer;
      display: flex; /* Usato per centrare l'icona */
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
      box-shadow: 0 0 10px rgba(170, 100, 255, 0.5); /* Glow iniziale */
    }

    .dropdown-button:hover, .dropdown-button:focus {
      /* Stili magici hover */
      background: rgba(255, 255, 255, 0.2); /* Cambio sfondo */
      box-shadow: 0 0 18px rgba(170, 100, 255, 0.8); /* Aumento glow */
      transform: scale(1.05); /* Leggero scale */
      outline: none; /* Rimuove outline di default su focus */
    }

    /* Selettore per icona dentro bottone per animazione */
    .dropdown-button .menu-icon {
         transition: transform 0.3s ease;
         display: inline-block; /* Necessario per transform */
    }
    .dropdown-button:hover .menu-icon {
         transform: rotate(15deg) scale(1.1); /* Rotazione/scala icona */
    }

    /* === DROPDOWN CONTENT STILIZZATO (Modifica stili esistenti #menuContent) === */
    /* Usiamo ID perché è nel tuo HTML originale, anche se classe sarebbe più flessibile */
    #menuContent.dropdown-content { /* Specifica maggiore per sicurezza */
      /* Mantenuti: display: none; position: absolute; z-index: 999 (aumentato sotto); min-width */
      display: none;
      position: absolute;
      z-index: 1001; /* Sopra la navbar */
      /* Stili Magici (Sostituiscono/Aggiungono) */
      background-color: rgba(26, 10, 42, 0.95);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      min-width: 240px; /* Leggermente aumentato */
      box-shadow: 0px 10px 25px 0px rgba(0,0,0,0.5);
      border-radius: 8px; /* Aggiunto radius */
      margin-top: 10px; /* Leggermente aumentato spazio */
      left: 0; /* Assicura allineamento a sx */
      border: 1px solid rgba(170, 100, 255, 0.5); /* Bordo colorato */
      max-height: 70vh; /* Limita altezza su schermi piccoli */
      overflow-y: auto; /* Scroll se necessario */
    }
    /* Scrollbar stilizzata (Opzionale ma carina) */
    #menuContent.dropdown-content::-webkit-scrollbar { width: 5px; }
    #menuContent.dropdown-content::-webkit-scrollbar-track { background: rgba(255,255,255,0.1); border-radius: 10px;}
    #menuContent.dropdown-content::-webkit-scrollbar-thumb { background: rgba(170, 100, 255, 0.6); border-radius: 10px;}
    #menuContent.dropdown-content::-webkit-scrollbar-thumb:hover { background: rgba(170, 100, 255, 0.9); }

    /* Stili link interni al menu */
    #menuContent.dropdown-content ul { list-style-type: none; }
    #menuContent.dropdown-content ul li a {
      /* Modifica stili link */
      color: #e0c0ff; /* Colore testo link */
      padding: 14px 20px; /* Padding aggiornato */
      text-decoration: none;
      display: block;
      font-family: 'Roboto', sans-serif; /* Mantenuto */
      font-weight: 400; /* Aggiunto per consistenza */
      font-size: 0.95rem; /* Leggermente aggiustato */
      transition: background-color 0.2s ease, color 0.2s ease;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1); /* Bordo separatore sottile */
    }
    #menuContent.dropdown-content ul li:last-child a { border-bottom: none; } /* Rimuove bordo da ultimo item */
    #menuContent.dropdown-content ul li a:hover {
        background-color: rgba(170, 100, 255, 0.2); /* Sfondo hover */
        color: #fff; /* Colore testo hover */
    }
    /* Stili per messaggi (Caricamento/Errore) */
    #menuContent.dropdown-content p {
         padding: 15px 20px;
         color: #aaa;
         font-style: italic;
    }
    /* Stile specifico per errore */
     #menuContent.dropdown-content p[style*="color: red"] {
         color: #ff8080 !important; /* Rosso più brillante */
         font-weight: bold;
     }

    /* Classe .show originale per visualizzare */
    #menuContent.dropdown-content.show { display: block; }

    /* Stili Sottomenu (Mantenuti dal tuo codice, leggermente adattati ai colori) */
    #menuContent.dropdown-content ul li.submenu-item { position: relative; }
    #menuContent.dropdown-content ul li.submenu-item .submenu {
        display: none;
        padding-left: 0; /* Rimosso padding extra */
        background-color: rgba(15, 5, 35, 0.9); /* Sfondo sottomenu più scuro */
        border-top: 1px solid rgba(255, 255, 255, 0.1); /* Separatore */
     }
    #menuContent.dropdown-content ul li.submenu-item .submenu ul li a {
        padding: 12px 20px 12px 35px; /* Padding con indentazione */
        font-size: 0.9em;
        border-bottom: 1px solid rgba(255, 255, 255, 0.08); /* Bordo più sottile */
        color: #c0a0ff; /* Colore leggermente diverso per sottomenu */
    }
     #menuContent.dropdown-content ul li.submenu-item .submenu ul li:last-child a { border-bottom: none; }
    #menuContent.dropdown-content ul li.submenu-item .submenu ul li a:hover {
        background-color: rgba(170, 100, 255, 0.3); /* Hover sottomenu */
        color: #fff;
    }
    #menuContent.dropdown-content ul li.submenu-item .submenu.open { display: block; }

    /* Stili trigger sottomenu (Mantenuti, adattati) */
    .submenu-trigger { /* Assumendo che questa classe sia usata nel menu.html caricato */
        display: flex; /* Permette di allineare testo e freccia */
        justify-content: space-between; /* Spazio tra testo e freccia */
        align-items: center;
    }
    .submenu-trigger .arrow {
        display: inline-block;
        margin-left: 10px; /* Spazio aumentato */
        transition: transform 0.3s ease;
        font-size: 0.8em;
        color: #a080cc; /* Colore freccia */
    }
    .submenu-trigger.open .arrow { transform: rotate(180deg); }


    /* === BOTTONE CHAT STILIZZATO (Modifica stili esistenti #goChat) === */
    #goChatContainer {
        /* Mantenuti: position, bottom, right, z-index */
        position: fixed;
        bottom: 25px; /* Leggermente alzato */
        right: 25px;
        z-index: 1000;
    }
    #goChat{
        /* Mantenuti: border-radius, cursor */
        cursor:pointer;
        border-radius:50%;
        /* Stili Magici (Sostituiscono/Aggiungono) */
        width: 65px; /* Dimensione aggiornata */
        height: 65px;
        border: none;
        /* Sostituito background con gradiente */
        background: radial-gradient(circle, rgba(200, 120, 255, 1) 0%, rgba(130, 50, 255, 1) 100%);
        /* Aggiornato box-shadow per glow */
        box-shadow: 0 0 25px rgba(170, 100, 255, 0.8), 0 5px 15px rgba(0, 0, 0, 0.4);
        display: flex; /* Per centrare icona */
        align-items: center;
        justify-content: center;
        transition: all 0.3s ease;
        animation: chatPulse 2.5s infinite ease-in-out; /* Aggiunta animazione pulse */
    }
    #goChat:active{
        /* Mantenuto transform originale per click */
        transform:scale(.9);
    }
    #goChat:hover { /* Aggiunto stile hover magico */
        transform: scale(1.1); /* Sovrascrive :active se hover e active coincidono */
        box-shadow: 0 0 35px rgba(200, 150, 255, 1), 0 8px 20px rgba(0, 0, 0, 0.5); /* Glow aumentato */
        animation-play-state: paused; /* Ferma pulsazione su hover */
    }
    /* Icona dentro il bottone chat */
    #goChat .chat-icon {
         font-size: 30px; /* Dimensione icona */
         color: #fff; /* Colore icona */
         filter: drop-shadow(0 1px 2px rgba(0,0,0,0.5)); /* Ombra icona */
    }
    /* Keyframes per animazione pulse */
    @keyframes chatPulse {
        0% { box-shadow: 0 0 25px rgba(170, 100, 255, 0.8), 0 5px 15px rgba(0, 0, 0, 0.4); }
        50% { box-shadow: 0 0 35px rgba(200, 150, 255, 1), 0 7px 20px rgba(0, 0, 0, 0.5); }
        100% { box-shadow: 0 0 25px rgba(170, 100, 255, 0.8), 0 5px 15px rgba(0, 0, 0, 0.4); }
    }


    /* === SFONDO DINAMICO (REGOLE CSS RIMOSSE) === */
    /* #dynamic-background-container { ... } */
    /* .background-slide { ... } */
    /* @keyframes kenburns { ... } */
    /* @keyframes kenburns-alt { ... } */
    /* Le regole CSS per lo slideshow sono state rimosse */


    /* === TITOLO EROE STILIZZATO (Modifica stili esistenti #hero-title-container) === */
    #hero-title-container {
        /* Mantenuti: position, left, transform, text-align, color, z-index, padding, width, max-width */
        position: fixed;
        /* top: 48%; // Leggermente aggiustato */
        top: 50%; /* Centrato verticalmente */
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        color: #ffffff;
        z-index: 10; /* Sopra canvas 3D, sotto navbar/menu */
        padding: 20px;
        width: 90%;
        max-width: 900px; /* Aumentato leggermente */
        /* Stili Magici (Sostituiscono/Aggiungono) */
        text-shadow: none; /* Rimosso vecchio text-shadow statico */
        user-select: none; /* Impedisce selezione testo */
    }

    #hero-title-container h1 {
        /* Mantenuti: font-weight, margin-bottom, line-height, letter-spacing, text-transform */
        font-weight: 700;
        margin-bottom: 0.5em; /* Leggermente aumentato */
        line-height: 1.2; /* Leggermente aumentato */
        letter-spacing: 2px; /* Aumentato */
        text-transform: uppercase;
        /* Stili Magici (Sostituiscono/Aggiungono) */
        font-family: 'Orbitron', sans-serif; /* Nuovo font */
        font-size: 4rem; /* Dimensione aggiornata */
        color: #fff; /* Assicura bianco */
        animation: heroGlow 3s ease-in-out infinite alternate; /* Animazione glow */
    }

    #hero-title-container p {
        /* Mantenuti: font-family, font-weight, line-height, opacity */
        font-family: 'Roboto', sans-serif;
        font-weight: 300;
        line-height: 1.6;
        opacity: 0.9;
         /* Stili Magici (Sostituiscono/Aggiungono) */
        font-size: 1.4rem; /* Dimensione aggiornata */
        color: #e0c0ff; /* Colore aggiornato */
        text-shadow: 0 0 8px rgba(0, 0, 0, 0.7); /* Leggero shadow per leggibilità */
    }
    /* Keyframes per animazione glow */
    @keyframes heroGlow {
         0% { text-shadow: 0 0 5px rgba(255,255,255,0.8), 0 0 10px rgba(255,255,255,0.7), 0 0 15px rgba(220,180,255,0.6), 0 0 25px rgba(170,100,255,0.5), 0 0 40px rgba(170,100,255,0.4); }
         100% { text-shadow: 0 0 8px rgba(255,255,255,1), 0 0 18px rgba(255,255,255,0.9), 0 0 30px rgba(220,180,255,0.8), 0 0 50px rgba(170,100,255,0.7), 0 0 70px rgba(170,100,255,0.6); }
    }
    /* Media query originali per H1/P adattate alle nuove dimensioni base */
    @media (max-width: 992px) {
        #hero-title-container h1 { font-size: 3.2rem; }
        #hero-title-container p { font-size: 1.2rem; }
    }
    @media (max-width: 768px) {
         #hero-title-container { top: 48%; } /* Sposta leggermente su */
         #hero-title-container h1 { font-size: 2.5rem; letter-spacing: 1.5px; }
         #hero-title-container p { font-size: 1.1rem; }
    }
    @media (max-width: 480px) {
         #hero-title-container { top: 45%; } /* Ancora più su */
         #hero-title-container h1 { font-size: 2rem; letter-spacing: 1px; }
         #hero-title-container p { font-size: 1rem; }
    }


    /* === CONTENUTO PRINCIPALE (Mantenuto selettore, ma probabilmente non usato/visibile) === */
    .main-content {
        position: relative;
        z-index: 2;
        padding-top: 70px; /* Potrebbe necessitare aggiustamento se navbar cambia altezza */
        padding-left: 20px;
        padding-right: 20px;
        padding-bottom: 20px;
        /* Potrebbe essere nascosto o rimosso se tutto è gestito dal 3D e UI fissa */
        display: none; /* Esempio: nascondilo se non serve */
    }

     /* --- Pulsante Richiesta Permessi (NUOVO, per iOS Device Orientation) --- */
     #request-orientation-button {
        position: fixed;
        bottom: 100px; /* Posizionato sopra il pulsante chat */
        left: 50%;
        transform: translateX(-50%);
        padding: 10px 20px;
        background-color: rgba(170, 100, 255, 0.8);
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        z-index: 1001; /* Sopra navbar/chat, sotto menu aperto */
        font-family: 'Roboto', sans-serif;
        box-shadow: 0 2px 10px rgba(0,0,0,0.4);
        display: none; /* Mostrato solo se necessario dal JS */
     }
     #request-orientation-button:hover {
         background-color: rgba(200, 150, 255, 1);
     }

    /* === RESPONSIVNESS GENERALE (Aggiustamenti UI Magica) === */
    @media (max-width: 992px) {
        /* Già gestito sopra per Hero Title */
        .dropdown-button { width: 42px; height: 42px; font-size: 20px; } /* Dimensione icona */
        #goChat { width: 60px; height: 60px; }
        #goChat .chat-icon { font-size: 28px; }
        .navbar { padding: 10px 20px; }
    }

    @media (max-width: 768px) {
        /* Già gestito sopra per Hero Title */
    }

    @media (max-width: 480px) {
        /* Già gestito sopra per Hero Title */
        .dropdown-button { width: 40px; height: 40px; font-size: 18px; }
        #goChat { width: 55px; height: 55px; bottom: 20px; right: 20px;}
        #goChat .chat-icon { font-size: 25px; }
        .navbar { padding: 8px 15px; }
        #menuContent.dropdown-content { min-width: 200px; }
        #menuContent.dropdown-content ul li a { padding: 12px 15px; font-size: 0.9rem;}
        #request-orientation-button { bottom: 85px; padding: 8px 15px; font-size: 0.9rem; }
    }

  </style>
</head>
<body>

  <!-- Contenitore Canvas Three.js (NUOVO) -->
  <div id="three-canvas-container"></div>

  <!-- Navbar Originale (Stili modificati via CSS) -->
  <div class="navbar">
    <div class="dropdown">
      <!-- Bottone Originale (Testo sostituito con icona span) -->
      <button onclick="toggleMenu()" class="dropdown-button" aria-label="Apri menu">
          <span class="menu-icon">🪄</span> <!-- Placeholder Icona Menu -->
      </button>
      <!-- Contenuto Dropdown Originale (Stili modificati via CSS) -->
      <div id="menuContent" class="dropdown-content">
        <!-- Il contenuto di menu.html verrà caricato qui dallo script originale -->
        <p style="padding: 10px; color: #555;">Caricamento menu...</p>
      </div>
    </div>
  </div>

  <!-- Contenitore Sfondo Dinamico Originale (RIMOSSO dal DOM) -->
  <!-- <div id="dynamic-background-container"></div> -->

  <!-- Titolo Hero Originale (Testo P aggiornato, Stili modificati via CSS) -->
  <div id="hero-title-container">
      <h1>Team Due Mori</h1>
      <!-- Testo Sottotitolo Aggiornato -->
      <p>Dove la magia incontra il gusto... dopo il caffè!</p>
  </div>

  <!-- Contenuto Principale Originale (Nascosto di default nel CSS sopra) -->
  <div class="main-content"> <!-- IL TUO CONTENUTO VA QUI! --> </div>

  <!-- Bottone Chat Originale (Icona aggiunta come span interno, Stili modificati via CSS) -->
  <div id="goChatContainer">
      <a href="chat.html" aria-label="Apri chat">
          <button id="goChat">
              <span class="chat-icon">💬</span> <!-- Placeholder Icona Chat -->
          </button>
      </a>
  </div>

  <!-- Bottone per richiesta permessi iOS (NUOVO) -->
  <button id="request-orientation-button">Abilita Controllo Inclinazione</button>

  <!-- === SCRIPT ORIGINALE (MENU + CHIUSURA ESTERNA) === -->
  <!-- Logica per lo sfondo dinamico originale RIMOSSA -->
  <script>
    // --- SCRIPT PER IL MENU A TENDINA (MANTENUTO E LEGGERMENTE ADATTATO) ---
    function toggleMenu() {
      const menuContent = document.getElementById("menuContent");
      if (!menuContent) return; // Sicurezza
      const isCurrentlyShown = menuContent.classList.contains("show");

      // CONDIZIONE PER IL FETCH ESATTAMENTE COME NEL TUO CODICE ORIGINALE FUNZIONANTE:
      if (!isCurrentlyShown && (menuContent.querySelector('p') || menuContent.innerHTML.trim() === '')) {
        fetch('menu.html') // Assicurati che menu.html sia nella stessa cartella
          .then(response => {
            if (!response.ok) {
              throw new Error('Errore nel caricamento di menu.html: ' + response.status + ' ' + response.statusText);
            }
            return response.text();
          })
          .then(data => {
            menuContent.innerHTML = data.trim() === '' ? '<p style="padding: 10px; color: #888;">Menu vuoto.</p>' : data;
          })
          .catch(error => {
            // Usa stile CSS per errore (rosso)
            menuContent.innerHTML = '<p style="padding: 10px; color: red;">Errore caricamento menu.</p>';
            console.error('Dettagli errore fetch menu.html:', error);
          });
      }

      menuContent.classList.toggle("show"); // Mostra o nascondi il menu

      // Chiudi sottomenu aperti se il menu principale si chiude
      if (!menuContent.classList.contains("show")) {
        closeAllSubmenus(menuContent);
      }
    }

    // Funzione per mostrare/nascondere i sottomenu (Globale per essere chiamata da HTML caricato)
    window.toggleSubmenu = function(event, triggerElement) {
      event.preventDefault();
      event.stopPropagation();
      const submenu = triggerElement.nextElementSibling;
      if (submenu && submenu.classList.contains('submenu')) {
        const wasOpen = submenu.classList.contains('open');
        // Chiudi tutti gli altri sottomenu allo stesso livello prima di aprirne uno nuovo
        const parentLi = triggerElement.closest('.submenu-item');
        if (parentLi && parentLi.parentElement) {
            const siblings = parentLi.parentElement.querySelectorAll(':scope > .submenu-item');
            siblings.forEach(sib => {
                if (sib !== parentLi) {
                    const otherSubmenu = sib.querySelector(':scope > .submenu');
                    const otherTrigger = sib.querySelector(':scope > .submenu-trigger');
                    if (otherSubmenu && otherSubmenu.classList.contains('open')) {
                        otherSubmenu.classList.remove('open');
                    }
                     if (otherTrigger && otherTrigger.classList.contains('open')) {
                        otherTrigger.classList.remove('open');
                    }
                }
            });
        }
        // Apri/chiudi quello cliccato
        submenu.classList.toggle('open', !wasOpen);
        triggerElement.classList.toggle('open', !wasOpen);
      }
    }

    // Funzione helper per chiudere tutti i sottomenu (richiamata da toggleMenu e click esterno)
    function closeAllSubmenus(menuContainer) {
         const openSubmenus = menuContainer.querySelectorAll('.submenu.open');
         openSubmenus.forEach(submenu => {
             submenu.classList.remove('open');
             // Trova il trigger corrispondente (potrebbe non essere l'elemento precedente diretto se la struttura cambia)
             const trigger = submenu.closest('.submenu-item')?.querySelector('.submenu-trigger');
             if (trigger && trigger.classList.contains('open')) {
                 trigger.classList.remove('open');
             }
         });
    }


    // Chiudi il menu principale (e i sottomenu) se l'utente clicca fuori da esso (Logica Originale Mantenuta)
    window.onclick = function(event) {
      const menuContent = document.getElementById("menuContent");
      const dropdownButton = document.querySelector('.dropdown-button'); // Selettore corretto
      // Aggiunto controllo per assicurarsi che esistano prima di accedere a .contains
      if (menuContent && dropdownButton && !dropdownButton.contains(event.target) && !menuContent.contains(event.target)) {
        if (menuContent.classList.contains("show")) {
          menuContent.classList.remove('show');
          closeAllSubmenus(menuContent); // Chiudi anche i sottomenu
        }
      }
    }

    // --- SCRIPT PER SFONDO DINAMICO ORIGINALE (RIMOSSO) ---
    // La parte document.addEventListener('DOMContentLoaded', ...) che gestiva lo slideshow è stata eliminata.

  </script>

  <!-- === SCRIPT THREE.JS E INTERATTIVITÀ (NUOVO) === -->
  <script type="importmap">
      {
          "imports": {
              "three": "https://unpkg.com/three@0.162.0/build/three.module.js",
              "three/addons/": "https://unpkg.com/three@0.162.0/examples/jsm/"
          }
      }
  </script>

  <script type="module">
      import * as THREE from 'three';
      // Non importiamo OrbitControls perché non le usiamo attivamente qui

      // --- Variabili Globali Scena 3D ---
      let scene, camera, renderer, clock;
      let spaceBackgroundSphere;
      let floatingEmojis = [];
      let particles;
      let geometricShapes = [];
      let mouseX = 0, mouseY = 0;
      let targetRotationX = 0, targetRotationY = 0;
      let windowHalfX = window.innerWidth / 2;
      let windowHalfY = window.innerHeight / 2;
      let deviceOrientationAvailable = false;
      let deviceOrientationPermissionGranted = false;
      let permissionButton = document.getElementById('request-orientation-button');

      // --- Configurazioni ---
      const emojiTextures = {}; // Oggetto per tenere le texture caricate
      // Lista dei file PNG degli emoji (assicurati che esistano nella cartella!)
      const emojiList = [
          'spaghetti.png', 'steak.png', 'sushi.png', 'salad.png', 'soup.png',
          'broccoli.png', 'carrot.png', 'tomato.png', 'mushroom.png',
          'chef-male.png', 'chef-female.png',
          'plate.png', 'wine-glass.png', 'champagne-glass.png', 'salt-shaker.png'
      ];
      // Immagine base per lo sfondo 3D (scegli una delle tue immagini originali)
      const backgroundTextureBase = 'home.PNG'; // Cambia se necessario

      // --- Inizializzazione Three.js ---
      function initThreeJS() {
          scene = new THREE.Scene();
          clock = new THREE.Clock();

          // Camera
          camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
          camera.position.z = 50; // Posizione iniziale camera

          // Renderer
          const container = document.getElementById('three-canvas-container');
          if (!container) {
              console.error("Elemento #three-canvas-container non trovato!");
              return;
          }
          renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
          renderer.setSize(window.innerWidth, window.innerHeight);
          renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
          container.appendChild(renderer.domElement);

          // Luci
          const ambientLight = new THREE.AmbientLight(0x401060, 1.5); // Viola scuro ambientale
          scene.add(ambientLight);
          const pointLight1 = new THREE.PointLight(0xaa64ff, 2, 800, 1); // Viola luminoso
          pointLight1.position.set(100, 200, 150);
          scene.add(pointLight1);
          const pointLight2 = new THREE.PointLight(0xffa07a, 1.5, 600, 1); // Pesca/Arancio
          pointLight2.position.set(-150, -100, -100);
          scene.add(pointLight2);

           // Nebbia Cosmica
           scene.fog = new THREE.FogExp2(0x0A0514, 0.0018); // Colore scuro, densità

          // Caricamento Texture e Creazione Elementi
          const textureLoader = new THREE.TextureLoader();

          // 1. Sfondo Universo (Sfera Invertita basata su tua immagine)
          textureLoader.load(
              backgroundTextureBase,
              (texture) => {
                  texture.wrapS = THREE.RepeatWrapping;
                  texture.wrapT = THREE.RepeatWrapping;
                  texture.repeat.set(1, 1);
                  texture.colorSpace = THREE.SRGBColorSpace; // Correzione colore

                  const backgroundMaterial = new THREE.MeshBasicMaterial({
                      map: texture,
                      side: THREE.BackSide, // Mostra interno
                      fog: false, // Sfondo non affetto da nebbia
                  });
                  // Applica tinta/modifica creativa base
                  backgroundMaterial.color.setRGB(0.8, 0.7, 1.0); // Tinta viola/blu chiaro

                  const backgroundGeometry = new THREE.SphereGeometry(1000, 64, 32); // Sfera grande
                  spaceBackgroundSphere = new THREE.Mesh(backgroundGeometry, backgroundMaterial);
                  scene.add(spaceBackgroundSphere);
              },
              undefined, // Progress callback (non usato)
              (error) => {
                  console.error(`Errore caricamento texture di sfondo (${backgroundTextureBase}):`, error);
                  scene.background = new THREE.Color(0x0a0514); // Fallback colore solido
              }
          );

          // 2. Caricamento Texture Emoji (asincrono)
          let texturesLoadedCount = 0;
          const totalTextures = emojiList.length;
          if (totalTextures > 0) {
              emojiList.forEach(emojiFile => {
                  textureLoader.load(
                      emojiFile,
                      (texture) => {
                          texture.colorSpace = THREE.SRGBColorSpace;
                          emojiTextures[emojiFile] = texture; // Salva texture nell'oggetto
                          texturesLoadedCount++;
                          if (texturesLoadedCount === totalTextures) {
                              console.log("Tutte le texture emoji caricate.");
                              createFloatingEmojis(); // Crea emoji solo quando tutte sono caricate
                          }
                      },
                      undefined,
                      (error) => {
                          console.warn(`Errore caricamento texture emoji: ${emojiFile}`, error);
                          texturesLoadedCount++; // Incrementa anche in caso di errore per non bloccare
                          if (texturesLoadedCount === totalTextures) {
                              console.warn("Caricamento texture emoji completato (con alcuni errori).");
                              createFloatingEmojis(); // Crea comunque gli emoji con le texture disponibili
                          }
                      }
                  );
              });
          } else {
              console.log("Nessun emoji nella lista, non verranno caricati/creati.");
              createFloatingEmojis(); // Chiama comunque per consistenza (non farà nulla)
          }

          // 3. Particelle Scintillanti
          createParticles();

          // 4. Forme Geometriche Astratte
          createGeometricShapes();

          // --- Aggiungi Listener Eventi ---
          window.addEventListener('resize', onWindowResize);
          document.addEventListener('mousemove', onDocumentMouseMove);

          // Gestione Device Orientation (con richiesta permessi)
          setupDeviceOrientation();

          // --- Inizia Loop di Animazione ---
          animate();
      }

      // --- Funzione Creazione Emoji Fluttuanti ---
      function createFloatingEmojis() {
           const numEmojis = 30; // Numero di emoji da creare
           const spawnRadius = 150;
           const minSpawnDist = 40;

           console.log(`Tentativo creazione di ${numEmojis} emoji 3D...`);
           let createdCount = 0;

           // Se non ci sono texture valide caricate, esci
           const availableTextures = Object.keys(emojiTextures);
           if (availableTextures.length === 0) {
                if (emojiList.length > 0) console.warn("Nessuna texture emoji valida caricata, impossibile creare emoji.");
                else console.log("Lista emoji vuota, nessun emoji da creare.");
                return;
           }

           for (let i = 0; i < numEmojis; i++) {
               // Scegli una texture casuale TRA QUELLE CARICATE con successo
               const randomTextureKey = availableTextures[Math.floor(Math.random() * availableTextures.length)];
               const texture = emojiTextures[randomTextureKey];

              // Usa SpriteMaterial per billboard effect
              const material = new THREE.SpriteMaterial({
                  map: texture,
                  transparent: true,
                  alphaTest: 0.1, // Aiuta con bordi PNG
                  depthWrite: false, // Per blending
                  fog: true, // Influenzato da nebbia
                  sizeAttenuation: true // Scala con distanza
                  // blending: THREE.AdditiveBlending // Prova per effetto più luminoso
              });

              const emojiSprite = new THREE.Sprite(material);

              // Posizione casuale sferica (non troppo vicina al centro)
              let x, y, z, distance;
              do {
                  x = (Math.random() - 0.5) * 2 * spawnRadius;
                  y = (Math.random() - 0.5) * 2 * spawnRadius;
                  z = (Math.random() - 0.5) * 2 * spawnRadius;
                  distance = Math.sqrt(x*x + y*y + z*z);
              } while (distance < minSpawnDist || distance > spawnRadius);

              emojiSprite.position.set(x, y, z);
              emojiSprite.scale.set(8, 8, 8); // Dimensione sprite

              // Dati custom per animazione
               emojiSprite.userData = {
                   initialY: y,
                   driftSpeed: (Math.random() - 0.5) * 0.4, // Velocità deriva verticale (positiva o negativa)
                   // rotationSpeed non ha effetto visibile sugli Sprite
               };

              scene.add(emojiSprite);
              floatingEmojis.push(emojiSprite);
              createdCount++;
          }
           console.log(`${createdCount} emoji creati con successo.`);
      }

      // --- Funzione Creazione Particelle ---
      function createParticles() {
          const particleCount = 8000;
          const positions = new Float32Array(particleCount * 3);
          const colors = new Float32Array(particleCount * 3);
          const spawnRange = 500; // Ampiezza distribuzione

          const baseColor1 = new THREE.Color(0x6a0dad); // Viola
          const baseColor2 = new THREE.Color(0x4169e1); // Blu Royal
          const baseColor3 = new THREE.Color(0xff00ff); // Magenta

          for (let i = 0; i < particleCount; i++) {
              const i3 = i * 3;

              // Posizione
              positions[i3] = (Math.random() - 0.5) * spawnRange * 2;
              positions[i3 + 1] = (Math.random() - 0.5) * spawnRange * 2;
              positions[i3 + 2] = (Math.random() - 0.5) * spawnRange * 2;

              // Colore casuale tra i 3 base con variazione luminosità
               const randomChoice = Math.random();
               let targetColor = (randomChoice < 0.33) ? baseColor1 : (randomChoice < 0.66 ? baseColor2 : baseColor3);
               const color = new THREE.Color(targetColor);
               color.multiplyScalar(Math.random() * 0.5 + 0.7); // Variazione luminosità

              colors[i3] = color.r;
              colors[i3 + 1] = color.g;
              colors[i3 + 2] = color.b;
          }

          const particleGeometry = new THREE.BufferGeometry();
          particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
          particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

          const particleMaterial = new THREE.PointsMaterial({
              size: 0.8, // Dimensione particella
              vertexColors: true, // Usa colori da attributo
              blending: THREE.AdditiveBlending, // Effetto luminoso
              transparent: true,
              depthWrite: false, // Importante per blending additivo
              fog: true, // Influenzato da nebbia
              sizeAttenuation: true // Scala con distanza
          });

          particles = new THREE.Points(particleGeometry, particleMaterial);
          scene.add(particles);
      }

      // --- Funzione Creazione Forme Geometriche ---
      function createGeometricShapes() {
           const shapeCount = 25;
           const geometries = [
               new THREE.TetrahedronGeometry(5, 0),
               new THREE.OctahedronGeometry(6, 0),
               new THREE.IcosahedronGeometry(7, 0),
               new THREE.TorusKnotGeometry(4, 1, 100, 12, 2, 3) // Nodo più complesso
           ];
           const spawnRadius = 180;
           const minSpawnDist = 50;

           for (let i = 0; i < shapeCount; i++) {
               const geometry = geometries[Math.floor(Math.random() * geometries.length)];
               let material;

               // Materiale casuale: 60% Solido Riflettente, 40% Wireframe Luminoso
               if (Math.random() > 0.4) {
                   material = new THREE.MeshStandardMaterial({
                       color: new THREE.Color(Math.random() * 0x888888 + 0x444444), // Colori metallici scuri/medi
                       metalness: Math.random() * 0.5 + 0.5,
                       roughness: Math.random() * 0.4 + 0.1,
                       fog: true
                   });
               } else {
                   material = new THREE.MeshBasicMaterial({
                       color: new THREE.Color(Math.random() * 0x8040ff + 0x8040ff), // Viola/Blu/Magenta luminosi
                       wireframe: true,
                       transparent: true,
                       opacity: 0.6,
                       blending: THREE.AdditiveBlending,
                       depthWrite: false,
                       fog: true
                   });
               }

               const mesh = new THREE.Mesh(geometry, material);

               // Posizione casuale
              let x, y, z, distance;
              do {
                  x = (Math.random() - 0.5) * 2 * spawnRadius;
                  y = (Math.random() - 0.5) * 2 * spawnRadius;
                  z = (Math.random() - 0.5) * 2 * spawnRadius;
                  distance = Math.sqrt(x*x + y*y + z*z);
              } while (distance < minSpawnDist || distance > spawnRadius);
              mesh.position.set(x, y, z);

              // Rotazione iniziale e velocità di rotazione casuali
               mesh.rotation.set(Math.random() * Math.PI * 2, Math.random() * Math.PI * 2, Math.random() * Math.PI * 2);
               mesh.userData = {
                   rotationSpeed: new THREE.Vector3(
                       (Math.random() - 0.5) * 0.01,
                       (Math.random() - 0.5) * 0.01,
                       (Math.random() - 0.5) * 0.01
                   )
               };
               scene.add(mesh);
               geometricShapes.push(mesh);
           }
       }

      // --- Handler Ridimensionamento Finestra ---
      function onWindowResize() {
          windowHalfX = window.innerWidth / 2;
          windowHalfY = window.innerHeight / 2;
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
          renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      }

      // --- Handler Movimento Mouse ---
      function onDocumentMouseMove(event) {
          // Aggiorna solo se l'orientamento del dispositivo non è attivo/disponibile
          if (!deviceOrientationAvailable || !deviceOrientationPermissionGranted) {
              mouseX = (event.clientX - windowHalfX) * 0.1; // Scala l'effetto
              mouseY = (event.clientY - windowHalfY) * 0.1;
          }
      }

       // --- Setup Device Orientation (con richiesta permessi iOS) ---
      function setupDeviceOrientation() {
          // Controlla se l'API per richiedere il permesso esiste (iOS 13+)
          if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
               permissionButton.style.display = 'block'; // Mostra bottone
               permissionButton.onclick = requestOrientationPermission; // Assegna handler al click
          } else {
               // Se non serve permesso (Android, iOS < 13, Desktop), prova ad aggiungere listener direttamente
               // Potrebbe non funzionare ovunque o non fornire dati
               window.addEventListener('deviceorientation', onDeviceOrientation, true);
               // Assumiamo sia disponibile finché non riceviamo un evento senza dati
               deviceOrientationAvailable = true;
               deviceOrientationPermissionGranted = true; // Non serve permesso esplicito
               console.log("DeviceOrientation: Permesso non richiesto esplicitamente o API non supportata per richiederlo.");
          }
      }

      // --- Richiesta Permesso Orientamento (iOS 13+) ---
      function requestOrientationPermission() {
          DeviceOrientationEvent.requestPermission()
              .then(permissionState => {
                  if (permissionState === 'granted') {
                      window.addEventListener('deviceorientation', onDeviceOrientation, true);
                      deviceOrientationAvailable = true;
                      deviceOrientationPermissionGranted = true;
                      permissionButton.style.display = 'none'; // Nascondi bottone
                      console.log("DeviceOrientation: Permesso concesso.");
                  } else {
                       deviceOrientationAvailable = false; // Permesso negato esplicitamente
                       deviceOrientationPermissionGranted = false;
                       permissionButton.style.display = 'none'; // Nascondi comunque
                       console.warn("DeviceOrientation: Permesso negato.");
                  }
              })
              .catch(error => {
                   deviceOrientationAvailable = false;
                   deviceOrientationPermissionGranted = false;
                   permissionButton.style.display = 'none';
                   console.error("DeviceOrientation: Errore richiesta permesso:", error);
              });
      }

      // --- Handler Device Orientation ---
      function onDeviceOrientation(event) {
           // Controlla se gamma e beta sono null o undefined, indica sensore non utilizzabile o dati incompleti
          if (event.gamma == null || event.beta == null) {
               // console.warn("DeviceOrientation: Dati gamma/beta null/undefined ricevuti.");
               // Non impostare available = false, altrimenti l'event listener viene perso se il permesso era stato dato
               // Semplicemente non aggiornare targetRotation
               return;
          }

           // Se arriviamo qui con dati validi, i sensori funzionano
           deviceOrientationAvailable = true;
           deviceOrientationPermissionGranted = true; // Se riceviamo dati, il permesso è implicitamente ok o è stato concesso

          // Mappa inclinazione a rotazione camera (sottile)
          const tiltX = THREE.MathUtils.clamp(event.beta, -90, 90); // Fronte-Retro
          const tiltY = THREE.MathUtils.clamp(event.gamma, -90, 90); // Sinistra-Destra
          const scaleFactor = 0.005; // Fattore di sensibilità
          targetRotationX = THREE.MathUtils.degToRad(tiltX) * scaleFactor * 3; // Effetto verticale
          targetRotationY = THREE.MathUtils.degToRad(tiltY) * scaleFactor * 5; // Effetto orizzontale

          // Resetta valori mouse se l'orientamento è attivo per evitare conflitti
           mouseX = 0;
           mouseY = 0;
      }

      // --- Loop di Animazione Principale ---
      function animate() {
          requestAnimationFrame(animate); // Richiede il prossimo frame
          const delta = clock.getDelta(); // Tempo trascorso dall'ultimo frame
          const elapsedTime = clock.getElapsedTime(); // Tempo totale trascorso

          // 1. Animazione Elementi Fluttuanti
          floatingEmojis.forEach(emoji => {
               // Movimento verticale oscillante + deriva
               emoji.position.y = emoji.userData.initialY + Math.sin(elapsedTime * 0.5 + emoji.position.x * 0.1) * 5;
               emoji.position.y += emoji.userData.driftSpeed * delta * 10; // Deriva (velocità * tempo)
               // Loop verticale (se esce troppo, riappare dall'altra parte)
               if (emoji.position.y > 200) {
                   emoji.position.y = -200;
                   emoji.userData.initialY = -200; // Resetta posizione base Y
                   emoji.position.x = (Math.random() - 0.5) * 300; // Riposiziona orizzontalmente
                   emoji.position.z = (Math.random() - 0.5) * 300;
               } else if (emoji.position.y < -200) {
                   emoji.position.y = 200;
                   emoji.userData.initialY = 200;
                   emoji.position.x = (Math.random() - 0.5) * 300;
                   emoji.position.z = (Math.random() - 0.5) * 300;
               }
          });

          geometricShapes.forEach(shape => {
               // Rotazione continua basata su velocità userData
               shape.rotation.x += shape.userData.rotationSpeed.x * delta * 60; // Moltiplica per 60 per normalizzare a velocità al secondo circa
               shape.rotation.y += shape.userData.rotationSpeed.y * delta * 60;
               shape.rotation.z += shape.userData.rotationSpeed.z * delta * 60;
           });

          // 2. Animazione Particelle (Opzionale: rotazione globale lenta)
           // if (particles) particles.rotation.y += delta * 0.01;

          // 3. Aggiornamento Camera (Interazione Mouse/Tilt con Interpolazione)
           const lerpFactor = 0.05; // Fattore di "smorzamento" per movimento fluido
           if (deviceOrientationAvailable && deviceOrientationPermissionGranted) {
               // Usa Device Orientation se attiva e permessa
               camera.rotation.x = THREE.MathUtils.lerp(camera.rotation.x, targetRotationX, lerpFactor);
               camera.rotation.y = THREE.MathUtils.lerp(camera.rotation.y, targetRotationY, lerpFactor);
           } else {
               // Altrimenti, usa Mouse Movement
               targetRotationY = mouseX * 0.0005; // Scala ulteriormente per movimento mouse
               targetRotationX = mouseY * 0.0005;
               camera.rotation.x = THREE.MathUtils.lerp(camera.rotation.x, targetRotationX, lerpFactor);
               camera.rotation.y = THREE.MathUtils.lerp(camera.rotation.y, targetRotationY, lerpFactor);
           }
           // Manteniamo la Z della rotazione a 0
           camera.rotation.z = 0;


          // 4. Render della scena
          renderer.render(scene, camera);
      }

      // --- Avvio Inizializzazione ---
      // Verifica che il DOM sia pronto prima di iniziare (anche se script è alla fine)
      if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', initThreeJS);
      } else {
          initThreeJS();
      }

  </script>

</body>
</html>
