<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tetris Polenta e Formai</title>
    <style>
        body {
            background-color: #4a3b31; /* Marrone scuro, come una tavola rustica */
            color: #fff;
            font-family: 'Georgia', serif; /* Un font più classico/rustico */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Allinea all'inizio per vedere il titolo */
            min-height: 100vh;
            margin: 0;
            padding: 15px;
            box-sizing: border-box;
            overflow-x: hidden;
        }

        .game-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: rgba(60, 45, 35, 0.85); /* Sfondo area gioco leggermente trasparente */
            padding: 20px;
            border-radius: 20px;
            box-shadow: 0 0 20px #ffcc66, 0 0 40px #ffcc66, inset 0 0 15px #ffcc66; /* Ombra calda, colore miele/polenta chiara */
        }

        h1 {
            font-size: 2.8em;
            margin-bottom: 15px;
            color: #FFD700; /* Oro - Polenta brillante */
            text-shadow: 0 0 5px #DAA520, 0 0 10px #DAA520, 0 0 15px #DAA520, 0 0 20px #FFBF00, 0 0 30px #FFBF00;
            text-align: center;
            font-variant: small-caps;
        }

        .main-content {
            display: flex;
            flex-direction: row; /* Canvas e info affiancati su schermi più grandi */
            align-items: flex-start;
            gap: 20px;
            flex-wrap: wrap; /* Permette di andare a capo su schermi piccoli */
            justify-content: center;
        }
        
        .game-board-container {
            /* Contenitore per il canvas principale */
        }

        #gameCanvas {
            border: 4px solid #DAA520; /* Bordo ocra/polenta scura */
            box-shadow: 0 0 10px #DAA520, 0 0 15px #DAA520;
            background-color: #2a1f17; /* Sfondo canvas molto scuro, terra bruciata */
            border-radius: 8px;
        }
        
        .info-and-next {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            min-width: 150px; /* Per dare spazio all'anteprima */
        }

        .info-panel {
            display: flex;
            flex-direction: column; /* Score e Vite uno sopra l'altro */
            align-items: center;
            gap: 10px;
            font-size: 1.3em;
            background-color: rgba(90, 70, 55, 0.7); /* Sfondo pannello info */
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 0 8px #FFA500, inset 0 0 5px #FFA500; /* Arancio chiaro */
            width: 100%;
        }

        .info-panel span {
            color: #FFFACD; /* LemonChiffon - Formaggio cremoso */
            text-shadow: 0 0 3px #F0E68C, 0 0 5px #F0E68C; /* Khaki - Giallo formaggio */
        }
        
        .next-piece-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .next-piece-container p {
            margin: 0 0 5px 0;
            font-size: 1.1em;
            color: #FFA500; /* Arancio */
            text-shadow: 0 0 3px #DAA520;
        }
        #nextCanvas {
            border: 2px solid #F0E68C; /* Giallo formaggio */
            background-color: rgba(42, 31, 23, 0.8); /* Sfondo scuro trasparente */
            border-radius: 5px;
            box-shadow: 0 0 5px #F0E68C;
        }
        
        .message-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(42, 31, 23, 0.9);
            color: #FFFACD;
            padding: 25px;
            border-radius: 10px;
            text-align: center;
            z-index: 100;
            font-size: 1.4em;
            box-shadow: 0 0 10px #FFFACD, 0 0 20px #FFFACD;
            display: none; 
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 20px;
            min-width: 280px;
        }
        .message-overlay p { margin: 0; line-height: 1.4; }
        .message-overlay button {
            margin-top: 0;
            font-size: 0.8em !important; 
            padding: 12px 20px !important;
        }

        .controls {
            margin-top: 25px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr); /* Un row in più per rotazione/drop */
            gap: 10px;
            width: 200px; /* Leggermente più grande */
            height: 260px;
        }

        .control-btn {
            background-color: rgba(255, 215, 0, 0.15); /* Oro trasparente */
            border: 2px solid #FFD700;
            color: #FFD700;
            font-size: 1.8em; /* Carattere un po' più piccolo per più testo */
            border-radius: 10px;
            cursor: pointer;
            user-select: none;
            box-shadow: 0 0 5px #FFD700, 0 0 10px #FFD700, inset 0 0 5px rgba(255,215,0,0.5);
            transition: background-color 0.2s, box-shadow 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .control-btn:active {
            background-color: rgba(255, 215, 0, 0.3);
            box-shadow: 0 0 8px #FFD700, 0 0 15px #FFD700, inset 0 0 8px rgba(255,215,0,0.7);
        }

        #up-btn    { grid-column: 2; grid-row: 1; font-size: 1.2em; } /* ROTATE */
        #left-btn  { grid-column: 1; grid-row: 2; }
        #right-btn { grid-column: 3; grid-row: 2; }
        #down-btn  { grid-column: 2; grid-row: 2; } /* SOFT DROP */
        #drop-btn  { grid-column: 2; grid-row: 3; font-size: 1.2em; } /* HARD DROP */
        
        /* Spazi vuoti per il D-pad a croce */
        .empty-dpad-tl { grid-column: 1; grid-row: 1; visibility: hidden;}
        .empty-dpad-tr { grid-column: 3; grid-row: 1; visibility: hidden;}
        .empty-dpad-bl { grid-column: 1; grid-row: 3; visibility: hidden;}
        .empty-dpad-br { grid-column: 3; grid-row: 3; visibility: hidden;}


        .home-btn {
            margin-top: 30px;
            padding: 12px 25px;
            font-size: 1.1em;
            background-color: rgba(218, 165, 32, 0.3); /* GoldenRod trasparente */
            border: 2px solid #DAA520;
            color: #DAA520;
            text-decoration: none;
            border-radius: 8px;
            box-shadow: 0 0 5px #DAA520, 0 0 10px #DAA520;
            transition: background-color 0.2s, box-shadow 0.2s;
        }
        .home-btn:hover, .home-btn:active {
            background-color: rgba(218, 165, 32, 0.5);
            box-shadow: 0 0 8px #DAA520, 0 0 15px #DAA520;
        }
    </style>
</head>
<body>
    <div class="game-area">
        <h1>Tetris Polenta e Formai</h1>
        <div class="main-content">
            <div class="game-board-container">
                <canvas id="gameCanvas"></canvas>
            </div>
            <div class="info-and-next">
                <div class="info-panel">
                    <span id="score">Score: 0</span>
                    <span id="lives">Vite: 3</span>
                    <span id="level">Livello: 1</span>
                </div>
                <div class="next-piece-container">
                    <p>Prossimo:</p>
                    <canvas id="nextCanvas"></canvas>
                </div>
            </div>
        </div>
         <div id="messageOverlay" class="message-overlay">
            <p id="messageText"></p>
            <button id="restartButton" class="control-btn">Ricomincia</button>
        </div>
        <div class="controls">
            <div class="empty-dpad-tl"></div>
            <button id="up-btn" class="control-btn">GIRA</button> <!-- Rotate -->
            <div class="empty-dpad-tr"></div>

            <button id="left-btn" class="control-btn">◄</button>
            <button id="down-btn" class="control-btn">▼</button> <!-- Soft Drop -->
            <button id="right-btn" class="control-btn">►</button>
            
            <div class="empty-dpad-bl"></div>
            <button id="drop-btn" class="control-btn">CADE</button> <!-- Hard Drop -->
            <div class="empty-dpad-br"></div>
        </div>
        <a href="index.html" class="home-btn">Torna alla Home</a>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const nextCanvas = document.getElementById('nextCanvas');
        const nextCtx = nextCanvas.getContext('2d');

        const scoreDisplay = document.getElementById('score');
        const livesDisplay = document.getElementById('lives');
        const levelDisplay = document.getElementById('level');
        
        const messageOverlay = document.getElementById('messageOverlay');
        const messageText = document.getElementById('messageText');
        const restartButton = document.getElementById('restartButton');

        const COLS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = 30; // Dimensione di ogni blocco in px
        const NEXT_CANVAS_SIZE = 4; // Griglia 4x4 per il prossimo pezzo

        canvas.width = COLS * BLOCK_SIZE;
        canvas.height = ROWS * BLOCK_SIZE;
        nextCanvas.width = NEXT_CANVAS_SIZE * BLOCK_SIZE;
        nextCanvas.height = NEXT_CANVAS_SIZE * BLOCK_SIZE;

        // Colori "Polenta e Formai" per i tetramini
        // Polenta: gialli, arancioni. Formaggio: bianchi, gialli chiari
        const COLORS = [
            null, // 0 è vuoto
            '#FFD700', // I: Oro (Polenta brillante)
            '#FFFACD', // O: LemonChiffon (Formaggio crema)
            '#FFA500', // T: Arancio (Polenta)
            '#F0E68C', // S: Khaki (Formaggio stagionato)
            '#DAA520', // Z: GoldenRod (Polenta scura)
            '#FFFFE0', // J: LightYellow (Formaggio fresco)
            '#FFBF00'  // L: Ambra/Arancio Giallo (Polenta)
        ];
        const SHADOW_COLORS = [ // Ombre più intense per effetto luminoso
            null,
            '#DAA520', 
            '#F0E68C', 
            '#E69500', 
            '#D8C970',
            '#B8860B',
            '#E0DDB0',
            '#D9A300'
        ];


        // Forme dei Tetramini (matrici)
        const TETROMINOES = {
            'I': { shape: [[1,1,1,1]], colorIndex: 1 }, // Colore I
            'O': { shape: [[2,2],[2,2]], colorIndex: 2 }, // Colore O
            'T': { shape: [[0,3,0],[3,3,3]], colorIndex: 3 }, // Colore T
            'S': { shape: [[0,4,4],[4,4,0]], colorIndex: 4 }, // Colore S
            'Z': { shape: [[5,5,0],[0,5,5]], colorIndex: 5 }, // Colore Z
            'J': { shape: [[6,0,0],[6,6,6]], colorIndex: 6 }, // Colore J
            'L': { shape: [[0,0,7],[7,7,7]], colorIndex: 7 }  // Colore L
        };
        const PIECE_KEYS = 'IOTZSLJ';

        let board = createBoard();
        let currentPiece;
        let nextPiece;
        let score;
        let lives;
        let level;
        let dropCounter;
        let dropInterval; // Tempo per la discesa automatica
        let gameRunning;
        let gamePausedForMessage = false;

        const initialLives = 3;
        const initialDropInterval = 1000; // 1 secondo
        const levelSpeedIncrease = 100; // Millisecondi in meno per livello

        function createBoard() {
            return Array.from({ length: ROWS }, () => Array(COLS).fill(0));
        }

        function getRandomPiece() {
            const rand = Math.floor(Math.random() * PIECE_KEYS.length);
            const key = PIECE_KEYS[rand];
            const pieceData = TETROMINOES[key];
            return {
                shape: pieceData.shape.map(row => row.slice()), // Copia profonda della forma
                colorIndex: pieceData.colorIndex,
                x: Math.floor(COLS / 2) - Math.floor(pieceData.shape[0].length / 2),
                y: 0
            };
        }

        function drawBlock(ctxInstance, x, y, colorIndex, bs = BLOCK_SIZE, isGhost = false) {
            if (colorIndex === 0) return;
            ctxInstance.fillStyle = COLORS[colorIndex];
            if (isGhost) {
                ctxInstance.globalAlpha = 0.3; // Trasparenza per il ghost piece
                ctxInstance.strokeStyle = COLORS[colorIndex];
                ctxInstance.lineWidth = 2;
                ctxInstance.strokeRect(x * bs, y * bs, bs, bs);
            } else {
                ctxInstance.globalAlpha = 1.0;
                // Effetto luminoso
                ctxInstance.shadowColor = SHADOW_COLORS[colorIndex];
                ctxInstance.shadowBlur = 8;
                ctxInstance.fillRect(x * bs, y * bs, bs, bs);
                
                // Bordo più scuro per definizione
                ctxInstance.shadowBlur = 0;
                ctxInstance.strokeStyle = 'rgba(0,0,0,0.3)';
                ctxInstance.lineWidth = 1;
                ctxInstance.strokeRect(x * bs, y * bs, bs, bs);
            }
             ctxInstance.globalAlpha = 1.0; // Reset alpha
        }

        function drawBoard() {
            board.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        drawBlock(ctx, x, y, value);
                    }
                });
            });
        }

        function drawPiece(piece, ctxInstance = ctx, offsetX = 0, offsetY = 0, bs = BLOCK_SIZE) {
            piece.shape.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        drawBlock(ctxInstance, piece.x + x + offsetX, piece.y + y + offsetY, piece.colorIndex, bs);
                    }
                });
            });
        }
        
        function drawGhostPiece() {
            if (!currentPiece) return;
            let ghostY = currentPiece.y;
            while (isValidMove(currentPiece.shape, currentPiece.x, ghostY + 1)) {
                ghostY++;
            }
            currentPiece.shape.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        drawBlock(ctx, currentPiece.x + x, ghostY + y, currentPiece.colorIndex, BLOCK_SIZE, true);
                    }
                });
            });
        }


        function drawNextPiece() {
            nextCtx.fillStyle = '#2a1f17'; // Sfondo canvas next
            nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
            if (nextPiece) {
                 // Centra il pezzo nell'area di anteprima
                const shape = nextPiece.shape;
                const offsetX = Math.floor((NEXT_CANVAS_SIZE - shape[0].length) / 2);
                const offsetY = Math.floor((NEXT_CANVAS_SIZE - shape.length) / 2);
                drawPiece(nextPiece, nextCtx, offsetX, offsetY, BLOCK_SIZE);
            }
        }
        
        function clearCanvas() {
            ctx.fillStyle = '#2a1f17'; // Sfondo principale del canvas
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function update() { // Discesa automatica
            if (!gameRunning || gamePausedForMessage) return;
            
            dropCounter += (performance.now() - lastTime); // Usa deltaTime per discesa più fluida
            lastTime = performance.now();

            if (dropCounter > dropInterval) {
                pieceDrop();
            }
        }

        function pieceMove(dir) {
            if (!gameRunning || gamePausedForMessage) return;
            if (isValidMove(currentPiece.shape, currentPiece.x + dir, currentPiece.y)) {
                currentPiece.x += dir;
            }
        }

        function pieceRotate() {
            if (!gameRunning || gamePausedForMessage) return;
            const originalShape = currentPiece.shape;
            const rotated = [];
            for (let y = 0; y < originalShape[0].length; y++) {
                rotated[y] = [];
                for (let x = 0; x < originalShape.length; x++) {
                    rotated[y][x] = originalShape[originalShape.length - 1 - x][y];
                }
            }
            if (isValidMove(rotated, currentPiece.x, currentPiece.y)) {
                currentPiece.shape = rotated;
            } else {
                // Wall kick (semplice)
                if (isValidMove(rotated, currentPiece.x + 1, currentPiece.y)) {
                    currentPiece.x += 1; currentPiece.shape = rotated;
                } else if (isValidMove(rotated, currentPiece.x - 1, currentPiece.y)) {
                    currentPiece.x -= 1; currentPiece.shape = rotated;
                } else if (currentPiece.shape.length > 2 && isValidMove(rotated, currentPiece.x - 2, currentPiece.y)) { // Per pezzo I
                    currentPiece.x -= 2; currentPiece.shape = rotated;
                } else if (currentPiece.shape.length > 2 && isValidMove(rotated, currentPiece.x + 2, currentPiece.y)) { // Per pezzo I
                    currentPiece.x += 2; currentPiece.shape = rotated;
                }
            }
        }

        function pieceDrop(isHardDrop = false) {
            if (!gameRunning || gamePausedForMessage) return;
            if (isHardDrop) {
                while (isValidMove(currentPiece.shape, currentPiece.x, currentPiece.y + 1)) {
                    currentPiece.y++;
                    score += 1; // Piccoli punti per hard drop
                }
                solidifyPiece(); // Solidifica immediatamente dopo hard drop
            } else { // Soft drop o discesa automatica
                if (isValidMove(currentPiece.shape, currentPiece.x, currentPiece.y + 1)) {
                    currentPiece.y++;
                } else {
                    solidifyPiece();
                }
            }
            dropCounter = 0; // Resetta il contatore per la prossima discesa
            updateUI();
        }

        function isValidMove(shape, x, y) {
            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[r].length; c++) {
                    if (shape[r][c] !== 0) { // Se è una cella del pezzo
                        let newX = x + c;
                        let newY = y + r;
                        if (newX < 0 || newX >= COLS || newY >= ROWS || (newY >= 0 && board[newY][newX] !== 0) ) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        function solidifyPiece() {
            currentPiece.shape.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        if (currentPiece.y + y < 0) { // Pezzo sopra la cima -> Game Over
                            handleGameOverCondition();
                            return;
                        }
                        board[currentPiece.y + y][currentPiece.x + x] = currentPiece.colorIndex;
                    }
                });
            });
            if (!gameRunning) return; // Se il gioco è finito durante la solidificazione

            clearLines();
            currentPiece = nextPiece;
            nextPiece = getRandomPiece();
            if (!isValidMove(currentPiece.shape, currentPiece.x, currentPiece.y)) {
                handleGameOverCondition(); // Non c'è spazio per il nuovo pezzo
            }
            drawNextPiece();
        }
        
        function handleGameOverCondition() {
            gameRunning = false;
            lives--;
            updateUI();
            if (lives > 0) {
                showMessage(`Polenta bruciata! Vite: ${lives}`, true);
                // resetBoard() sarà chiamato dal bottone
            } else {
                showMessage(`Game Over! Formaggio finito! Punteggio: ${score}`, true);
            }
        }
        
        function resetBoard() { // Chiamato quando si perde una vita ma non è game over
            hideMessage();
            gamePausedForMessage = false;
            board = createBoard();
            currentPiece = getRandomPiece();
            nextPiece = getRandomPiece();
            drawNextPiece();
            // Score e level non si resettano, si continua
            dropCounter = 0;
            lastTime = performance.now();
            gameRunning = true;
            gameLoop();
        }


        function clearLines() {
            let linesCleared = 0;
            for (let r = ROWS - 1; r >= 0; r--) {
                if (board[r].every(cell => cell !== 0)) {
                    linesCleared++;
                    board.splice(r, 1); // Rimuove la riga
                    board.unshift(Array(COLS).fill(0)); // Aggiunge una riga vuota in cima
                    r++; // Ricontrolla la stessa riga (che ora è quella sopra)
                }
            }
            if (linesCleared > 0) {
                // Punteggio Tetris
                if (linesCleared === 1) score += 40 * level;
                else if (linesCleared === 2) score += 100 * level;
                else if (linesCleared === 3) score += 300 * level;
                else if (linesCleared >= 4) score += 1200 * level; // Tetris!
                
                // Aumento di livello ogni 10 linee (esempio)
                if (Math.floor(score / (400 * level)) > level -1 ) { // Semplice, da affinare
                     level++;
                     dropInterval = Math.max(100, initialDropInterval - (level -1) * levelSpeedIncrease); // Non scendere sotto i 100ms
                }
            }
        }
        
        function showMessage(text, showRestartBtn = true) {
            messageText.textContent = text;
            restartButton.style.display = showRestartBtn ? 'inline-block' : 'none';
            messageOverlay.style.display = 'flex';
            gamePausedForMessage = true;
        }

        function hideMessage() {
            messageOverlay.style.display = 'none';
        }


        function updateUI() {
            scoreDisplay.textContent = `Score: ${score}`;
            livesDisplay.textContent = `Vite: ${lives}`;
            levelDisplay.textContent = `Livello: ${level}`;
        }

        let lastTime = 0;
        function gameLoop(time = 0) {
            if (gamePausedForMessage) {
                requestAnimationFrame(gameLoop); // Continua a chiamare per sbloccarsi
                return;
            }
            if (!gameRunning) return;

            update(); // Aggiorna la logica (discesa automatica)
            
            clearCanvas();
            drawBoard();
            if(currentPiece) {
                drawGhostPiece();
                drawPiece(currentPiece);
            }
            
            lastTime = time;
            requestAnimationFrame(gameLoop);
        }

        function initGame() {
            hideMessage();
            gamePausedForMessage = false;
            board = createBoard();
            score = 0;
            lives = initialLives;
            level = 1;
            dropInterval = initialDropInterval;
            currentPiece = getRandomPiece();
            nextPiece = getRandomPiece();
            drawNextPiece();
            updateUI();
            dropCounter = 0;
            gameRunning = true;
            lastTime = performance.now(); // Inizializza lastTime
            gameLoop();
        }
        
        // Controlli
        document.addEventListener('keydown', event => {
            if (!gameRunning || gamePausedForMessage) return;
            if (event.key === 'ArrowLeft') pieceMove(-1);
            else if (event.key === 'ArrowRight') pieceMove(1);
            else if (event.key === 'ArrowDown') pieceDrop(); // Soft drop
            else if (event.key === 'ArrowUp' || event.key === 'x') pieceRotate(); // Rotate
            else if (event.key === ' ') { // Hard drop
                 event.preventDefault(); // Previene lo scroll della pagina
                 pieceDrop(true);
            }
        });

        document.getElementById('left-btn').addEventListener('click', () => pieceMove(-1));
        document.getElementById('right-btn').addEventListener('click', () => pieceMove(1));
        document.getElementById('down-btn').addEventListener('click', () => pieceDrop()); // Soft drop
        document.getElementById('up-btn').addEventListener('click', () => pieceRotate()); // Rotate
        document.getElementById('drop-btn').addEventListener('click', () => pieceDrop(true)); // Hard drop
        
        restartButton.addEventListener('click', () => {
            if (lives > 0) { // Se ha perso una vita ma non è game over definitivo
                resetBoard(); 
            } else { // Se era game over definitivo
                initGame(); 
            }
        });

        initGame();
    </script>
</body>
</html>
