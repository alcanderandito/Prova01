<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Super Fabio bros</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #333;
            font-family: 'Arial', sans-serif;
            color: white;
            overflow: hidden; /* Evita scrollbar indesiderate */
        }
        #gameContainer {
            position: relative; /* Per posizionare pulsanti HTML sopra/sotto */
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        canvas {
            border: 2px solid #000;
            background-color: #70c5ce; /* Colore cielo di default */
            max-width: 100%;
            max-height: calc(100vh - 150px); /* Lascia spazio per UI e controlli */
            aspect-ratio: 16 / 9; /* Mantiene le proporzioni */
            display: block; /* Aiuta con alcuni problemi di layout/spazio extra */
        }
        #ui {
            display: flex;
            justify-content: space-around;
            width: 100%;
            max-width: 800px; /* Stessa larghezza max del canvas se impostata */
            padding: 10px 0;
            font-size: 1.2em;
            background-color: rgba(0,0,0,0.5);
            border-radius: 0 0 10px 10px;
        }
        .ui-element {
            margin: 0 10px;
        }
        #touchControls {
            display: none; /* Nascosti di default, mostrati via JS per mobile */
            justify-content: space-around;
            width: 100%;
            max-width: 400px;
            margin-top: 15px;
            padding: 10px;
            background-color: rgba(0,0,0,0.3);
            border-radius: 10px;
        }
        .touch-button {
            background-color: #555;
            color: white;
            border: 2px solid #ddd;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none; 
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        .touch-button:active {
            background-color: #777;
        }
        #homeButtonContainer {
            margin-top: 20px;
        }
        #homeButton {
            padding: 10px 20px;
            font-size: 1em;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            text-decoration: none;
            cursor: pointer;
        }
        #homeButton:hover {
            background-color: #0056b3;
        }

        .overlay-button {
            position: absolute;
            padding: 15px 30px;
            font-size: 1.5em;
            background-color: #4CAF50;
            color: white;
            border: 2px solid #3e8e41;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            z-index: 100; 
            display: none; /* Nascosti di default, mostrati da JS */
        }
        .overlay-button:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="ui">
            <div id="lives" class="ui-element">Vite: 5</div>
            <div id="score" class="ui-element">Punteggio: 0</div>
            <div id="powerUpTimer" class="ui-element"></div>
        </div>
        <div id="touchControls">
            <button id="leftButton" class="touch-button">‚óÄÔ∏è</button>
            <button id="jumpButton" class="touch-button">üîº</button>
            <button id="rightButton" class="touch-button">‚ñ∂Ô∏è</button>
            <button id="shootButton" class="touch-button" style="display:none;">üî•</button>
        </div>
        
        <button id="startButton" class="overlay-button">Inizia Gioco</button>
        <button id="retryButton" class="overlay-button">Riprova</button>
        <button id="playAgainButton" class="overlay-button">Gioca Ancora</button>
        <button id="nextLevelButton" class="overlay-button">Prossimo Livello</button>
    </div>

    <div id="homeButtonContainer">
        <a href="index.html" id="homeButton">Torna alla Home</a>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('gameContainer'); // Riferimento al contenitore

        const livesDisplay = document.getElementById('lives');
        const scoreDisplay = document.getElementById('score');
        const powerUpTimerDisplay = document.getElementById('powerUpTimer');
        
        const startButton = document.getElementById('startButton');
        const retryButton = document.getElementById('retryButton');
        const playAgainButton = document.getElementById('playAgainButton');
        const nextLevelButton = document.getElementById('nextLevelButton');

        const touchControlsDiv = document.getElementById('touchControls');
        const leftButton = document.getElementById('leftButton');
        const rightButton = document.getElementById('rightButton');
        const jumpButton = document.getElementById('jumpButton');
        const shootButton = document.getElementById('shootButton');

        let gameWidth = 800;
        let gameHeight = 450;
        canvas.width = gameWidth;
        canvas.height = gameHeight;

        // Pulsanti overlay
        function positionOverlayButton(button, topFactor = 0.75) {
            button.style.display = 'block'; // Assicura che sia visibile per misurazione

            const canvasRect = canvas.getBoundingClientRect();
            const gameContainerRect = gameContainer.getBoundingClientRect();

            // Posizione del canvas RELATIVA al gameContainer
            const canvasTopInContainer = canvasRect.top - gameContainerRect.top;
            const canvasLeftInContainer = canvasRect.left - gameContainerRect.left;

            const buttonLeft = canvasLeftInContainer + (canvasRect.width / 2) - (button.offsetWidth / 2);
            const buttonTop = canvasTopInContainer + (canvasRect.height * topFactor) - (button.offsetHeight / 2);

            button.style.left = `${buttonLeft}px`;
            button.style.top = `${buttonTop}px`;
        }

        function hideOverlayButtons() {
            startButton.style.display = 'none';
            retryButton.style.display = 'none';
            playAgainButton.style.display = 'none';
            nextLevelButton.style.display = 'none';
        }
        
        window.addEventListener('resize', () => {
            if (startButton.style.display === 'block') positionOverlayButton(startButton, 0.75);
            if (retryButton.style.display === 'block') positionOverlayButton(retryButton, 0.75);
            if (playAgainButton.style.display === 'block') positionOverlayButton(playAgainButton, 0.75);
            if (nextLevelButton.style.display === 'block') positionOverlayButton(nextLevelButton, 0.75);
        });


        const images = {};
        const imageSources = {
            player: 'fabiogame2.PNG',
            enemy: 'mostro.PNG',
            background: 'fabiogame.PNG' 
        };
        let imagesLoaded = 0;
        let totalImages = Object.keys(imageSources).length;

        function loadImages(callback) {
            for (let key in imageSources) {
                images[key] = new Image();
                images[key].src = imageSources[key];
                images[key].onload = () => {
                    imagesLoaded++;
                    if (imagesLoaded === totalImages) {
                        callback();
                    }
                };
                images[key].onerror = () => {
                    console.error(`Errore caricamento immagine: ${imageSources[key]}`);
                    imagesLoaded++; 
                    if (imagesLoaded === totalImages) {
                        callback(); 
                    }
                }
            }
        }

        let player;
        let platforms = [];
        let enemies = [];
        let collectibles = [];
        let projectiles = [];
        let powerUpCollectible = null;

        let score = 0;
        let lives = 5;
        let currentLevel = 0; 
        let gameState = 'LOADING'; 

        const gravity = 0.8;
        const groundFriction = 0.8;

        let powerUpActive = false;
        let powerUpDuration = 15000; 
        let powerUpTimer = 0;
        let enemiesKilledForPowerUp = 0;
        const powerUpSpawnThreshold = 6; 

        let boss = null;
        const bossMaxHealth = 10; 

        // Player object (la definizione della classe Player deve precedere l'array levels se vuoi usare player.height)
        // Sposto temporaneamente la definizione di Player qui, poi la rimetto a posto per leggibilit√†
        // e uso un valore hardcoded per l'altezza nella definizione dei livelli
        const PLAYER_DEFAULT_HEIGHT = 60; 

        // Level Data
        const levels = [
            { // Livello 1: Cielo
                scoreToAdvance: 1000,
                bgColor: '#70c5ce',
                themeName: "Cielo Sereno",
                playerStartX: 60, 
                playerStartPlatformTopY: gameHeight - 120, 
                platforms: [
                    { x: 0, y: gameHeight - 40, width: gameWidth, height: 40, color: '#8FBC8F' }, 
                    { x: 30, y: gameHeight - 120, width: 100, height: 20, color: '#A0522D' }, 
                    { x: 200, y: gameHeight - 140, width: 150, height: 20, color: '#A0522D' }, 
                    { x: 400, y: gameHeight - 200, width: 200, height: 20, color: '#A0522D' },
                    { x: 650, y: gameHeight - 100, width: 100, height: 20, color: '#A0522D' }
                ],
                enemies: [ { x: 300, y: gameHeight - 80 }, { x: 500, y: gameHeight - 80 } ],
                collectibles: [
                    { x: 230, y: gameHeight - 180 }, { x: 270, y: gameHeight - 180 }, 
                    { x: 450, y: gameHeight - 240 }, { x: 490, y: gameHeight - 240 },
                    { x: 680, y: gameHeight - 140 }, { x: 150, y: gameHeight - 80 },
                    { x: 550, y: gameHeight - 80 }, { x: 350, y: gameHeight - 80 },
                    { x: 750, y: gameHeight - 80 }, { x: 400, y: gameHeight - 80 }
                ]
            },
            { // Livello 2: Deserto
                scoreToAdvance: 2000,
                bgColor: '#F4A460',
                themeName: "Deserto Infuocato",
                playerStartX: 60,
                playerStartPlatformTopY: gameHeight - 150,
                platforms: [
                    { x: 0, y: gameHeight - 40, width: gameWidth, height: 40, color: '#D2B48C' },
                    { x: 30, y: gameHeight - 150, width: 100, height: 20, color: '#CD853F' }, 
                    { x: 200, y: gameHeight - 120, width: 100, height: 20, color: '#CD853F' }, 
                    { x: 300, y: gameHeight - 180, width: 200, height: 20, color: '#CD853F' },
                    { x: 550, y: gameHeight - 100, width: 150, height: 20, color: '#CD853F' },
                    { x: 200, y: gameHeight - 280, width: 150, height: 20, color: '#CD853F' },
                ],
                enemies: [
                    { x: 250, y: gameHeight - 80 }, { x: 450, y: gameHeight - 80 }, 
                    { x: 600, y: gameHeight - 80 }, { x: 350, y: gameHeight - 220 }
                ],
                collectibles: [
                    { x: 220, y: gameHeight - 160 }, { x: 330, y: gameHeight - 220 }, 
                    { x: 580, y: gameHeight - 140 }, { x: 230, y: gameHeight - 320 },
                    { x: 150, y: gameHeight - 80 }, { x: 350, y: gameHeight - 80 },
                    { x: 400, y: gameHeight - 80 }, { x: 650, y: gameHeight - 80 },
                    { x: 750, y: gameHeight - 80 }
                ]
            },
            { // Livello 3: Foresta (Inizio Power-up)
                scoreToAdvance: 3000,
                bgColor: '#228B22',
                themeName: "Foresta Omrbosa",
                powerUpEnabled: true,
                playerStartX: 70, 
                playerStartPlatformTopY: gameHeight - 150,
                platforms: [
                    { x: 0, y: gameHeight - 40, width: gameWidth, height: 40, color: '#556B2F' },
                    { x: 50, y: gameHeight - 150, width: 150, height: 20, color: '#8B4513' }, 
                    { x: 250, y: gameHeight - 220, width: 100, height: 20, color: '#8B4513' },
                    { x: 400, y: gameHeight - 120, width: 200, height: 20, color: '#8B4513' },
                    { x: 650, y: gameHeight - 250, width: 120, height: 20, color: '#8B4513' }
                ],
                enemies: [
                    { x: 250, y: gameHeight - 80 }, 
                    { x: 350, y: gameHeight - 80 },
                    { x: 500, y: gameHeight - 80 }, { x: 700, y: gameHeight - 80 },
                    { x: 280, y: gameHeight - 260 }, 
                    { x: 450, y: gameHeight - 160 }
                ],
                collectibles: Array.from({length: 15}, (_, i) => ({ x: 50 + i * 50, y: gameHeight - 80 - (i%3 * 50) }))
            },
            { // Livello 4: Citt√†
                scoreToAdvance: 4000,
                bgColor: '#778899',
                themeName: "Metropoli Grigia",
                powerUpEnabled: true,
                playerStartX: 40, 
                playerStartPlatformTopY: gameHeight - 180,
                platforms: [
                    { x: 0, y: gameHeight - 40, width: gameWidth, height: 40, color: '#A9A9A9' },
                    { x: 0, y: gameHeight - 180, width: 150, height: 20, color: '#696969' }, 
                    { x: gameWidth - 150, y: gameHeight - 180, width: 150, height: 20, color: '#696969' },
                    { x: 200, y: gameHeight - 120, width: 100, height: 20, color: '#696969' },
                    { x: 350, y: gameHeight - 250, width: 100, height: 20, color: '#696969' },
                    { x: 500, y: gameHeight - 120, width: 100, height: 20, color: '#696969' }
                ],
                enemies: [
                    { x: 250, y: gameHeight - 80 }, 
                    { x: 350, y: gameHeight - 80 },
                    { x: 420, y: gameHeight - 80 }, { x: 600, y: gameHeight - 80 },
                    { x: 720, y: gameHeight - 80 },
                    { x: gameWidth - 100, y: gameHeight - 220 }, 
                    { x: 400, y: gameHeight - 290 }
                ],
                collectibles: Array.from({length: 20}, (_, i) => ({ x: 30 + i * 40, y: gameHeight - 80 - (i%4 * 40) }))
            },
            { // Livello 5: Castello (Boss)
                scoreToAdvance: Infinity,
                bgColor: '#483D8B',
                themeName: "Castello Oscuro",
                powerUpEnabled: true,
                isBossLevel: true,
                playerStartX: 120, 
                playerStartPlatformTopY: gameHeight - 150,
                platforms: [
                    { x: 0, y: gameHeight - 40, width: gameWidth, height: 40, color: '#2F4F4F' },
                    { x: 100, y: gameHeight - 150, width: 150, height: 20, color: '#708090' }, 
                    { x: gameWidth - 250, y: gameHeight - 150, width: 150, height: 20, color: '#708090' },
                    { x: gameWidth/2 - 75, y: gameHeight - 250, width: 150, height: 20, color: '#708090' }
                ],
                enemies: [
                    { x: 200, y: gameHeight - 80 }, 
                    { x: gameWidth - 200, y: gameHeight - 80 }
                ],
                bossData: { x: gameWidth / 2 - 50, y: gameHeight - 120, health: bossMaxHealth }, 
                collectibles: Array.from({length: 10}, (_, i) => ({ x: 50 + i * 70, y: gameHeight - 80 - (i%2 * 60) }))
            }
        ];

        class Player {
            constructor(x, y) {
                this.width = 40;
                this.height = PLAYER_DEFAULT_HEIGHT; // Usa la costante definita prima
                this.x = x;
                this.y = y;
                this.dx = 0;
                this.dy = 0;
                this.speed = 5;
                this.jumpForce = 15;
                this.isJumping = false;
                this.onGround = false;
                this.image = images.player;
                this.shootCooldown = 0;
                this.shootDelay = 300; 
                this.lastDirection = 'right'; 
            }

            jump() {
                if (this.onGround) {
                    this.dy = -this.jumpForce;
                    this.isJumping = true;
                    this.onGround = false;
                }
            }

            shoot() {
                if (powerUpActive && this.shootCooldown <= 0) {
                    const projectileType = Math.random() < 0.5 ? 'üç¥' : 'üî™';
                    const projectileSpeed = 8;
                    let dir = (this.lastDirection === 'left') ? -1 : 1;
                    
                    projectiles.push(new Projectile(this.x + this.width / 2, this.y + this.height / 2, projectileType, dir * projectileSpeed));
                    this.shootCooldown = this.shootDelay;
                }
            }
            
            update(deltaTime) {
                if (keys.ArrowLeft || keys.KeyA || touchLeft) {
                    this.dx = -this.speed;
                    this.lastDirection = 'left';
                } else if (keys.ArrowRight || keys.KeyD || touchRight) {
                    this.dx = this.speed;
                    this.lastDirection = 'right';
                } else {
                    this.dx *= groundFriction; 
                }

                this.dy += gravity;
                this.y += this.dy;
                this.x += this.dx;

                if (this.x < 0) this.x = 0;
                if (this.x + this.width > gameWidth) this.x = gameWidth - this.width;

                if (this.y > gameHeight) {
                    loseLife();
                }
                
                if (this.shootCooldown > 0) {
                    this.shootCooldown -= deltaTime;
                }
            }

            draw() {
                if (this.image && this.image.complete && this.image.naturalWidth !== 0) {
                    ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
                } else {
                    ctx.fillStyle = 'blue'; 
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                }
            }
        }

        class Platform {
            constructor(x, y, width, height, color) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.color = color;
            }
            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }
        }

        class Enemy {
            constructor(x, y, isBoss = false, health = 1) {
                this.isBoss = isBoss;
                this.width = isBoss ? 100 : 40;
                this.height = isBoss ? 100 : 40;
                this.x = x;
                this.y = y - (this.height - 40); 
                this.dx = (Math.random() < 0.5 ? 1 : -1) * (isBoss ? 1 : 2); 
                this.image = images.enemy;
                this.health = health;
                this.maxHealth = health;
            }
            update() {
                this.x += this.dx;
                if (this.x < 0 || this.x + this.width > gameWidth) {
                    this.dx *= -1;
                }
                let onPlatform = false;
                for (const platform of platforms) {
                    if (this.x + this.width > platform.x && this.x < platform.x + platform.width &&
                        this.y + this.height >= platform.y && this.y + this.height <= platform.y + platform.height + 5) { 
                        onPlatform = true;
                        const lookAheadX = this.x + (this.dx > 0 ? this.width + 5 : -5); 
                        let groundAhead = false;
                        for (const p of platforms) {
                            if (lookAheadX + (this.dx > 0 ? 0 : this.width) > p.x && lookAheadX + (this.dx > 0 ? 0 : this.width) < p.x + p.width &&
                                this.y + this.height >= p.y && this.y + this.height <= p.y + p.height + 5) {
                                groundAhead = true;
                                break;
                            }
                        }
                        if (!groundAhead && onPlatform) { 
                             this.dx *= -1;
                        }
                        break; 
                    }
                }
            }
            draw() {
                if (this.image && this.image.complete && this.image.naturalWidth !== 0) {
                    ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
                } else {
                    ctx.fillStyle = 'red'; 
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                }
                if (this.isBoss && this.health < this.maxHealth) {
                    const barWidth = this.width; const barHeight = 10;
                    const barX = this.x; const barY = this.y - barHeight - 5;
                    ctx.fillStyle = '#555'; ctx.fillRect(barX, barY, barWidth, barHeight);
                    ctx.fillStyle = 'green'; ctx.fillRect(barX, barY, barWidth * (this.health / this.maxHealth), barHeight);
                }
            }
            takeDamage(amount) {
                this.health -= amount;
                return this.health <= 0;
            }
        }

        class Collectible {
            constructor(x, y) {
                this.x = x; this.y = y; this.width = 30; this.height = 30;
                this.emoji = 'ü•ó'; this.fontSize = 30;
            }
            draw() {
                ctx.font = `${this.fontSize}px Arial`; ctx.textAlign = "center";
                ctx.fillText(this.emoji, this.x + this.width/2, this.y + this.height - 5);
            }
        }
        
        class PowerUpCollectible {
            constructor(x, y) {
                this.x = x; this.y = y; this.width = 40; this.height = 40;
                this.emoji = 'üç≤'; this.fontSize = 40;
            }
            draw() {
                ctx.font = `${this.fontSize}px Arial`; ctx.textAlign = "center";
                ctx.fillText(this.emoji, this.x + this.width/2, this.y + this.height - 5);
            }
        }

        class Projectile {
            constructor(x, y, type, dx) {
                this.x = x; this.y = y; this.width = 20; this.height = 20;
                this.emoji = type; this.fontSize = 20; this.dx = dx;
            }
            update() { this.x += this.dx; }
            draw() {
                ctx.font = `${this.fontSize}px Arial`; ctx.textAlign = "center";
                ctx.fillText(this.emoji, this.x + this.width/2, this.y + this.height/2 + 5);
            }
        }

        const keys = {};
        let touchLeft = false, touchRight = false;

        window.addEventListener('keydown', (e) => { keys[e.code] = true; });
        window.addEventListener('keyup', (e) => { keys[e.code] = false; });
        
        function handleJumpPress() { if (gameState === 'PLAYING') player.jump(); }
        function handleShootPress() { if (gameState === 'PLAYING' && powerUpActive) player.shoot(); }

        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') { e.preventDefault(); handleJumpPress(); }
            if (e.code === 'KeyX' || e.code === 'ControlLeft') { e.preventDefault(); handleShootPress(); }
        });

        function setupTouchControls() {
            if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
                touchControlsDiv.style.display = 'flex';
                leftButton.addEventListener('touchstart', (e) => { e.preventDefault(); touchLeft = true; });
                leftButton.addEventListener('touchend', (e) => { e.preventDefault(); touchLeft = false; });
                rightButton.addEventListener('touchstart', (e) => { e.preventDefault(); touchRight = true; });
                rightButton.addEventListener('touchend', (e) => { e.preventDefault(); touchRight = false; });
                jumpButton.addEventListener('touchstart', (e) => { e.preventDefault(); handleJumpPress(); });
                shootButton.addEventListener('touchstart', (e) => { e.preventDefault(); handleShootPress(); });
            }
        }
        setupTouchControls();

        function AABB(rect1, rect2) { 
            return rect1.x < rect2.x + rect2.width && rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height && rect1.y + rect1.height > rect2.y;
        }

        function handleCollisions() {
            player.onGround = false;
            for (const platform of platforms) {
                if (AABB(player, platform)) {
                    if (player.dy > 0 && player.y + player.height - player.dy <= platform.y) { 
                        player.y = platform.y - player.height; player.dy = 0;
                        player.onGround = true; player.isJumping = false;
                    }
                    else if (player.dx > 0 && player.x + player.width - player.dx <= platform.x) { 
                        player.x = platform.x - player.width; player.dx = 0;
                    } else if (player.dx < 0 && player.x - player.dx >= platform.x + platform.width) { 
                        player.x = platform.x + platform.width; player.dx = 0;
                    }
                    else if (player.dy < 0 && player.y - player.dy >= platform.y + platform.height) {
                        player.y = platform.y + platform.height; player.dy = 0; 
                    }
                }
            }

            for (let i = collectibles.length - 1; i >= 0; i--) {
                if (AABB(player, collectibles[i])) {
                    collectibles.splice(i, 1); score += 100; updateUI();
                }
            }
            
            if (powerUpCollectible && AABB(player, powerUpCollectible)) {
                activatePowerUp(); powerUpCollectible = null;
            }

            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                if (AABB(player, enemy)) {
                    if (player.dy > 0 && (player.y + player.height - player.dy) <= enemy.y + enemy.height / 2) { 
                        enemies.splice(i, 1); score += 200;
                        player.dy = -player.jumpForce / 2; 
                        enemiesKilledForPowerUp++; checkSpawnPowerUp();
                    } else { loseLife(); }
                    updateUI();
                }
            }
            
            if (boss && AABB(player, boss)) {
                if (player.dy > 0 && (player.y + player.height - player.dy) <= boss.y + boss.height / 2) {
                    if (boss.takeDamage(1)) { defeatBoss(); } 
                    else { player.dy = -player.jumpForce / 1.5; }
                } else { loseLife(); }
            }

            for (let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i]; let projectileHit = false;
                for (let j = enemies.length - 1; j >= 0; j--) {
                    if (AABB(proj, enemies[j])) {
                        enemies.splice(j, 1); projectiles.splice(i, 1); projectileHit = true;
                        score += 250; enemiesKilledForPowerUp++; checkSpawnPowerUp(); break; 
                    }
                }
                if (projectileHit) continue;
                if (boss && AABB(proj, boss)) {
                     if (boss.takeDamage(0.2)) { defeatBoss(); }
                    projectiles.splice(i, 1);
                }
                if (proj.x < 0 || proj.x > gameWidth) projectiles.splice(i, 1);
            }
        }
        
        function defeatBoss() {
            score += 5000; boss = null; enemies = []; updateUI(); gameState = 'VICTORY';
            setTimeout(() => positionOverlayButton(playAgainButton, 0.75), 0); 
        }

        function loseLife() {
            lives--; updateUI();
            if (lives <= 0) {
                gameState = 'GAME_OVER';
                setTimeout(() => positionOverlayButton(retryButton, 0.75), 0);
            } else {
                // Ritorna alla piattaforma di partenza del livello corrente
                const levelData = levels[currentLevel];
                player.x = levelData.playerStartX;
                player.y = levelData.playerStartPlatformTopY - player.height;
                player.dx = 0; player.dy = 0;
            }
        }

        function updateUI() {
            livesDisplay.textContent = `Vite: ${lives}`;
            scoreDisplay.textContent = `Punteggio: ${score}`;
            if (powerUpActive) {
                powerUpTimerDisplay.textContent = `Chef Furioso: ${Math.ceil(powerUpTimer / 1000)}s`;
                if (currentLevel >= 2) shootButton.style.display = 'flex'; 
            } else {
                powerUpTimerDisplay.textContent = '';
                shootButton.style.display = 'none';
            }
        }

        function activatePowerUp() {
            powerUpActive = true; powerUpTimer = powerUpDuration;
            enemiesKilledForPowerUp = 0; updateUI();
        }

        function checkSpawnPowerUp() {
            const levelData = levels[currentLevel];
            if (levelData.powerUpEnabled && !powerUpActive && !powerUpCollectible && enemiesKilledForPowerUp >= powerUpSpawnThreshold) {
                let spawnX, spawnY;
                if (platforms.length > 1) {
                    const p = platforms[Math.floor(Math.random() * (platforms.length -1)) + 1]; 
                    spawnX = p.x + p.width / 2 - 20; spawnY = p.y - 50;
                } else { 
                    spawnX = gameWidth / 2; spawnY = gameHeight - 150;
                }
                powerUpCollectible = new PowerUpCollectible(spawnX, spawnY);
                enemiesKilledForPowerUp = 0; 
            }
        }

        function loadLevel(levelIndex) {
            if (levelIndex >= levels.length) {
                gameState = 'VICTORY'; 
                setTimeout(() => positionOverlayButton(playAgainButton, 0.75), 0);
                return;
            }
            currentLevel = levelIndex;
            const levelData = levels[currentLevel];

            player = new Player(levelData.playerStartX, levelData.playerStartPlatformTopY - PLAYER_DEFAULT_HEIGHT); 
            
            platforms = levelData.platforms.map(p => new Platform(p.x, p.y, p.width, p.height, p.color));
            enemies = levelData.enemies.map(e => new Enemy(e.x, e.y));
            collectibles = levelData.collectibles.map(c => new Collectible(c.x, c.y));
            projectiles = []; powerUpCollectible = null; enemiesKilledForPowerUp = 0;
            
            if (levelData.isBossLevel && levelData.bossData) {
                boss = new Enemy(levelData.bossData.x, levelData.bossData.y, true, levelData.bossData.health);
            } else { boss = null; }

            canvas.style.backgroundColor = levelData.bgColor;
            updateUI(); 
            hideOverlayButtons();
            gameState = 'PLAYING';
        }
        
        function resetGame() {
            lives = 5; score = 0; powerUpActive = false; powerUpTimer = 0;
            currentLevel = 0; loadLevel(currentLevel);
        }

        let lastTime = 0;
        let titleFabioX = 50, titleFabioDir = 1;
        let titleEnemyX = gameWidth - 100, titleEnemyDir = -1;

        function gameLoop(timestamp) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            ctx.clearRect(0, 0, gameWidth, gameHeight);

            if (gameState === 'LOADING') {
                ctx.fillStyle = 'black'; ctx.fillRect(0,0,gameWidth, gameHeight);
                ctx.fillStyle = 'white'; ctx.font = '30px Arial';
                ctx.textAlign = 'center'; ctx.fillText('Caricamento Risorse...', gameWidth / 2, gameHeight / 2);
            } else if (gameState === 'TITLE') {
                ctx.drawImage(images.background, 0, 0, gameWidth, gameHeight); 
                ctx.font = 'bold 70px Arial'; ctx.fillStyle = '#FFD700'; 
                ctx.strokeStyle = '#A0522D'; ctx.lineWidth = 5;
                ctx.textAlign = 'center'; const titleText = "Super Fabio bros";
                ctx.strokeText(titleText, gameWidth / 2, gameHeight * 0.3);
                ctx.fillText(titleText, gameWidth / 2, gameHeight * 0.3);
                if (images.player && images.player.complete) {
                    titleFabioX += titleFabioDir * 0.5;
                    if (titleFabioX > 150 || titleFabioX < 50) titleFabioDir *= -1;
                    ctx.drawImage(images.player, titleFabioX, gameHeight * 0.5, 60, PLAYER_DEFAULT_HEIGHT);
                }
                if (images.enemy && images.enemy.complete) {
                    titleEnemyX += titleEnemyDir * 0.7;
                     if (titleEnemyX > gameWidth - 100 || titleEnemyX < gameWidth - 200) titleEnemyDir *= -1;
                    ctx.drawImage(images.enemy, titleEnemyX, gameHeight * 0.55, 50, 50);
                }
                ctx.font = '40px Arial';
                ctx.fillText('ü•ó', gameWidth * 0.3, gameHeight * 0.6);
                ctx.fillText('ü•ó', gameWidth * 0.7, gameHeight * 0.4);
                
                if (startButton.style.display === 'none') { 
                     setTimeout(() => positionOverlayButton(startButton, 0.75), 0);
                }

            } else if (gameState === 'PLAYING') {
                const currentLevelData = levels[currentLevel];
                ctx.fillStyle = currentLevelData.bgColor; ctx.fillRect(0, 0, gameWidth, gameHeight);
                if (currentLevelData.themeName === "Cielo Sereno") {
                    ctx.fillStyle = "white"; 
                    ctx.beginPath(); ctx.arc(100, 100, 30, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(130, 90, 40, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(500, 120, 50, 0, Math.PI * 2); ctx.fill();
                } else if (currentLevelData.themeName === "Deserto Infuocato") {
                    ctx.fillStyle = "orange"; 
                    ctx.beginPath(); ctx.arc(gameWidth - 80, 80, 50, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = "#8B4513"; 
                    ctx.fillRect(100, gameHeight - 100, 20, 60); ctx.fillRect(80, gameHeight - 80, 60, 20);
                } 

                for (const platform of platforms) platform.draw();
                for (const collectible of collectibles) collectible.draw();
                if (powerUpCollectible) powerUpCollectible.draw();
                
                player.update(deltaTime); player.draw();
                for (const enemy of enemies) { enemy.update(); enemy.draw(); }
                if (boss) { boss.update(); boss.draw(); }
                for (const projectile of projectiles) { projectile.update(); projectile.draw(); }

                handleCollisions();

                if (powerUpActive) {
                    powerUpTimer -= deltaTime;
                    if (powerUpTimer <= 0) { powerUpActive = false; powerUpTimer = 0; }
                    updateUI();
                }
                
                const levelData = levels[currentLevel];
                if (!levelData.isBossLevel && score >= levelData.scoreToAdvance) {
                    gameState = 'LEVEL_COMPLETE';
                    setTimeout(() => positionOverlayButton(nextLevelButton, 0.75), 0);
                }

            } else if (gameState === 'LEVEL_COMPLETE') {
                ctx.fillStyle = 'rgba(0,0,0,0.7)'; ctx.fillRect(0,0,gameWidth, gameHeight);
                ctx.fillStyle = 'white'; ctx.font = '40px Arial'; ctx.textAlign = 'center';
                ctx.fillText('Livello Completato!', gameWidth / 2, gameHeight / 2 - 30);
                ctx.font = '20px Arial'; ctx.fillText(`Punteggio: ${score}`, gameWidth / 2, gameHeight / 2 + 20);
            } else if (gameState === 'GAME_OVER') {
                if (images.background && images.background.complete) {
                    ctx.drawImage(images.background, 0, 0, gameWidth, gameHeight);
                } else { ctx.fillStyle = 'black'; ctx.fillRect(0,0,gameWidth, gameHeight); }
                ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(0,0,gameWidth, gameHeight);
                ctx.fillStyle = 'red'; ctx.font = '60px Arial'; ctx.textAlign = 'center';
                ctx.fillText('GAME OVER', gameWidth / 2, gameHeight / 2 - 40);
                ctx.fillStyle = 'white'; ctx.font = '30px Arial';
                ctx.fillText(`Punteggio Finale: ${score}`, gameWidth / 2, gameHeight / 2 + 20);
            } else if (gameState === 'VICTORY') {
                 if (images.background && images.background.complete) {
                    ctx.drawImage(images.background, 0, 0, gameWidth, gameHeight);
                } else { ctx.fillStyle = '#FFD700'; ctx.fillRect(0,0,gameWidth, gameHeight); }
                ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.fillRect(0,0,gameWidth, gameHeight);
                ctx.fillStyle = 'green'; ctx.font = '60px Arial'; ctx.textAlign = 'center';
                ctx.fillText('HAI VINTO!', gameWidth / 2, gameHeight / 2 - 40);
                ctx.fillStyle = 'white'; ctx.font = '30px Arial';
                ctx.fillText(`Punteggio Finale: ${score}`, gameWidth / 2, gameHeight / 2 + 20);
            }
            requestAnimationFrame(gameLoop);
        }

        startButton.addEventListener('click', () => {
            hideOverlayButtons(); resetGame(); 
        });
        retryButton.addEventListener('click', () => {
            hideOverlayButtons(); resetGame();
        });
        playAgainButton.addEventListener('click', () => {
            hideOverlayButtons(); resetGame();
        });
        nextLevelButton.addEventListener('click', () => {
            hideOverlayButtons(); currentLevel++; loadLevel(currentLevel);
        });

        loadImages(() => {
            console.log("Immagini caricate!");
            gameState = 'TITLE';
            setTimeout(() => positionOverlayButton(startButton, 0.75), 0); 
            lastTime = performance.now();
            requestAnimationFrame(gameLoop);
        });
    </script>
</body>
</html>
