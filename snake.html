<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Snake ai Due Mori</title>
    <style>
        body {
            background-color: #0a0a1f;
            color: #fff;
            font-family: 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Allinea game-container in alto */
            min-height: 100vh;
            margin: 0;
            padding: 10px;
            box-sizing: border-box;
            overflow-x: hidden;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: rgba(10, 10, 31, 0.8);
            padding: 20px; /* Desktop */
            border-radius: 15px;
            box-shadow: 0 0 15px #ff00ff, 0 0 30px #ff00ff, inset 0 0 10px #ff00ff;
            width: 100%;
            max-width: 450px; /* Adattato per canvas più piccolo */
            box-sizing: border-box;
        }

        h1 {
            font-size: 2.5em; /* Desktop */
            margin-bottom: 10px; /* Desktop */
            color: #00ffff;
            text-shadow: 0 0 5px #00ffff, 0 0 10px #00ffff, 0 0 15px #00ffff, 0 0 20px #0ff, 0 0 30px #0ff, 0 0 40px #0ff;
            text-align: center;
        }

        .info-panel {
            display: flex;
            justify-content: space-around;
            width: 100%;
            max-width: 380px; /* Desktop, adattato */
            margin-bottom: 15px; /* Desktop */
            font-size: 1.2em; /* Desktop */
        }

        .info-panel span {
            color: #f0f;
            text-shadow: 0 0 3px #f0f, 0 0 5px #f0f, 0 0 7px #f0f;
        }

        #gameCanvas {
            border: 2px solid #00ff00; /* Bordo più sottile */
            box-shadow: 0 0 8px #00ff00, 0 0 15px #00ff00; /* Ombra ridotta */
            background-color: #000500;
            border-radius: 4px; /* Raggio ridotto */
            display: block; /* Per centrarlo se necessario con margin: auto */
            margin-left: auto; /* Centra il canvas se il contenitore è più largo */
            margin-right: auto;
        }

        .message-overlay {
            position: absolute; /* Rispetto a game-container se position:relative o fixed/absolute parente */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0,0,0,0.85);
            color: #fff;
            padding: 20px; /* Desktop/Default */
            border-radius: 10px;
            text-align: center;
            z-index: 100;
            font-size: 1.3em; /* Desktop/Default */
            box-shadow: 0 0 10px #fff, 0 0 20px #fff;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 15px; /* Desktop/Default */
            min-width: 250px; /* Desktop/Default */
            max-width: 90%;
        }
        .message-overlay p {
            margin: 0;
            line-height: 1.4;
        }
        .message-overlay button {
            margin-top: 0;
            font-size: 0.7em !important; /* Default, per essere più piccolo del normale .control-btn */
            padding: 10px 18px !important; /* Default */
        }


        .controls {
            margin-top: 20px; /* Desktop */
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 10px; /* Desktop */
            width: 150px;  /* Adattato per tileSize ridotto. Es: 12 * 12.5 */
            height: 150px; /* Adattato */
        }

        .control-btn {
            background-color: rgba(0, 255, 255, 0.1);
            border: 2px solid #00ffff;
            color: #00ffff;
            font-size: 1.8em; /* Desktop, frecce */
            border-radius: 10px; /* Desktop */
            cursor: pointer;
            user-select: none;
            box-shadow: 0 0 5px #00ffff, 0 0 10px #00ffff, inset 0 0 5px rgba(0,255,255,0.5);
            transition: background-color 0.2s, box-shadow 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .control-btn:active {
            background-color: rgba(0, 255, 255, 0.3);
            box-shadow: 0 0 8px #00ffff, 0 0 15px #00ffff, inset 0 0 8px rgba(0,255,255,0.7);
        }

        #up-btn    { grid-column: 2; grid-row: 1; }
        #left-btn  { grid-column: 1; grid-row: 2; }
        #right-btn { grid-column: 3; grid-row: 2; }
        #down-btn  { grid-column: 2; grid-row: 3; }

        .center-fill { grid-column: 2; grid-row: 2; visibility: hidden; }


        .home-btn {
            margin-top: 25px; /* Desktop */
            padding: 10px 20px; /* Desktop */
            font-size: 1em; /* Desktop */
            background-color: rgba(255, 0, 255, 0.2);
            border: 2px solid #ff00ff;
            color: #ff00ff;
            text-decoration: none;
            border-radius: 8px; /* Desktop */
            box-shadow: 0 0 5px #ff00ff, 0 0 10px #ff00ff;
            transition: background-color 0.2s, box-shadow 0.2s;
        }
        .home-btn:hover, .home-btn:active {
            background-color: rgba(255, 0, 255, 0.4);
            box-shadow: 0 0 8px #ff00ff, 0 0 15px #ff00ff;
        }

        /* Media query per layout su schermi piccoli */
        @media (max-width: 480px) {
            body {
                padding: 5px;
                justify-content: flex-start; /* Assicura che il contenuto parta dall'alto */
            }
            .game-container {
                padding: 10px;
                /* Se necessario, per forzare tutto dentro la viewport
                max-height: calc(100vh - 10px);
                overflow-y: auto; */
            }
            h1 {
                font-size: 1.7em;
                margin-bottom: 8px;
            }
            .info-panel {
                font-size: 0.9em;
                margin-bottom: 10px;
                flex-wrap: wrap; /* Permette agli elementi di andare a capo se necessario */
                justify-content: center; /* Centra gli elementi se vanno a capo */
                gap: 10px; /* Spazio tra gli elementi info se vanno a capo */
            }
            .info-panel span {
                white-space: nowrap; /* Evita che "Score: 0" vada a capo */
            }

            .controls {
                width: 130px; /* Ridotto ulteriormente per mobile */
                height: 130px;/* Ridotto ulteriormente per mobile */
                gap: 6px;
                margin-top: 10px;
            }
            .control-btn {
                font-size: 1.5em; /* Frecce più piccole */
                border-radius: 6px;
                border-width: 1px;
            }
            .home-btn {
                font-size: 0.85em;
                padding: 7px 14px;
                margin-top: 15px;
                border-radius: 6px;
            }
            .message-overlay {
                font-size: 1em;
                padding: 15px;
                gap: 10px;
                min-width: 200px;
            }
            .message-overlay button {
                font-size: 0.7em !important;
                padding: 8px 15px !important;
            }
        }
        /* Media query specifica per schermi molto bassi */
        @media (max-height: 680px) and (max-width: 480px) {
             h1 { font-size: 1.5em; margin-bottom: 5px;}
            .info-panel { font-size: 0.8em; margin-bottom: 8px;}
            .controls { width: 120px; height: 120px; gap: 5px; margin-top: 8px;}
            .control-btn { font-size: 1.4em; }
            .home-btn { font-size: 0.8em; padding: 6px 12px; margin-top: 10px;}
            .game-container { padding-top: 5px; padding-bottom: 5px; }
        }

    </style>
</head>
<body>
    <div class="game-container">
        <h1>Snake ai Due Mori</h1>
        <div class="info-panel">
            <span id="lives">Vite: 5</span>
            <span id="score">Score: 0</span>
        </div>
        <canvas id="gameCanvas"></canvas>
        <div id="messageOverlay" class="message-overlay">
            <p id="messageText"></p>
            <button id="restartButton" class="control-btn">Ricomincia</button>
        </div>
        <div class="controls">
            <div></div>
            <button id="up-btn" class="control-btn">▲</button>
            <div></div>
            <button id="left-btn" class="control-btn">◄</button>
            <div class="center-fill"></div>
            <button id="right-btn" class="control-btn">►</button>
            <div></div>
            <button id="down-btn" class="control-btn">▼</button>
            <div></div>
        </div>
        <a href="index.html" class="home-btn">Torna alla Home</a>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const livesDisplay = document.getElementById('lives');
        const scoreDisplay = document.getElementById('score');

        const messageOverlay = document.getElementById('messageOverlay');
        const messageText = document.getElementById('messageText');
        const restartButton = document.getElementById('restartButton');

        const gridSize = 20;
        const tileSize = 12; // << RIDOTTO TILESIZE PER COMPATTEZZA MOBILE (era 400/gridSize = 20)
        const canvasSize = gridSize * tileSize; // Di conseguenza canvasSize diventa 240

        canvas.width = canvasSize;
        canvas.height = canvasSize;

        let snake;
        let food;
        let dx = tileSize; // Velocità iniziale basata sul nuovo tileSize
        let dy = 0;
        let score;
        let lives;
        let gameRunning;
        let changingDirection;
        let gamePausedForMessage = false;

        const foodEmojis = [
            '🍎', '🍓', '🍒', '🍉', '🍇', '🍌', '🥭', '🍍', '🍑', '🥝', '🍕', '🍔', '🍟', '🍩', '🍪',
            '🍊', '🍋', '🍐', '🥥', '🍅', '🍆', '🥑', '🥦', '🥬', '🥒', '🌶️', '🌽', '🥕', '🧄', '🧅',
            '🥔', '🍠', '🥐', '🥯', '🍞', '🥖', '🥨', '🧀', '🥚', '🍳', '🥞', '🧇', '🥓', '🥩', '🍗',
            '🍖', '🌭', '🌮', '🌯', '🥙', '🧆', '🥗', '🍲', '🍜', '🍝', '🍣', '🍱', '🍛', '🍙', // ' Spaghetti' -> '🍝'
            '🍚', '🍘', '🍥', '🥠', '🥮', '🍢', '🍡', '🍧', '🍨', '🍦', '🥧', '🧁', '🍰', '🎂', '🍮',
            '🍭', '🍬', '🍫', '🍿', '🌰', '🥜', '🍯', '🥛', '☕', '🍵', '🧃', '🥤', '🧋', '🧉'
        ];
        let currentFoodEmoji;

        let lastFrameTime = 0;
        const initialFrameInterval = 180; // Millisecondi tra i frame (più basso = più veloce)
        let frameInterval = initialFrameInterval;

        const upBtn = document.getElementById('up-btn');
        const downBtn = document.getElementById('down-btn');
        const leftBtn = document.getElementById('left-btn');
        const rightBtn = document.getElementById('right-btn');

        function getRandomFoodEmoji() {
            return foodEmojis[Math.floor(Math.random() * foodEmojis.length)];
        }

        function initSnake() {
            snake = [
                { x: tileSize * Math.floor(gridSize / 2), y: tileSize * Math.floor(gridSize / 2) },
                { x: tileSize * (Math.floor(gridSize / 2) - 1), y: tileSize * Math.floor(gridSize / 2) },
                { x: tileSize * (Math.floor(gridSize / 2) - 2), y: tileSize * Math.floor(gridSize / 2) }
            ];
            dx = tileSize; // Assicura che la direzione iniziale sia corretta col nuovo tileSize
            dy = 0;
            frameInterval = initialFrameInterval; // Resetta velocità ad ogni nuova vita/inizio
        }

        function spawnFood() {
            currentFoodEmoji = getRandomFoodEmoji();
            food = {
                x: Math.floor(Math.random() * gridSize) * tileSize,
                y: Math.floor(Math.random() * gridSize) * tileSize
            };
            // Assicura che il cibo non spawni sul serpente
            snake.forEach(part => {
                if (part.x === food.x && part.y === food.y) {
                    spawnFood();
                }
            });
        }

        function initGame() {
            hideMessage();
            gamePausedForMessage = false;
            score = 0;
            lives = 5;
            initSnake();
            spawnFood();
            updateUI();
            gameRunning = true;
            changingDirection = false;
            lastFrameTime = 0;
            if (animationFrameId) cancelAnimationFrame(animationFrameId); // Cancella vecchio loop
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function resetLevel() { // Chiamato quando si perde una vita ma ci sono ancora vite
            hideMessage();
            gamePausedForMessage = false;
            initSnake(); // Resetta posizione serpente e velocità
            spawnFood(); // Nuovo cibo
            updateUI(); // Aggiorna vite (già fatto da handleDeath, ma per sicurezza)
            gameRunning = true;
            changingDirection = false;
            lastFrameTime = 0; // Resetta il tempo per il game loop
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            animationFrameId = requestAnimationFrame(gameLoop);
        }


        function drawSnakePart(part, index) {
            const isHead = index === 0;
            ctx.shadowColor = '#00ff00';
            ctx.shadowBlur = isHead ? Math.max(5, tileSize * 0.75) : Math.max(3, tileSize * 0.5); // Adattato
            ctx.fillStyle = isHead ? '#33ff33' : '#00cc00';

            ctx.fillRect(part.x, part.y, tileSize, tileSize);
            ctx.strokeStyle = '#003300';
            ctx.lineWidth = 1; // Mantenere 1 per leggibilità con tileSize piccolo
            ctx.strokeRect(part.x + 0.5, part.y + 0.5, tileSize -1, tileSize -1);


            if (isHead) {
                ctx.fillStyle = '#000';
                ctx.shadowBlur = 0;
                let eye1X, eye1Y, eye2X, eye2Y;
                const eyeSize = Math.max(1, tileSize / 5); // Occhi proporzionati

                if (dx > 0) { // Destra
                    eye1X = part.x + tileSize * 0.7 - eyeSize / 2; eye1Y = part.y + tileSize * 0.25 - eyeSize / 2; // Leggermente aggiustato 0.2 -> 0.25
                    eye2X = part.x + tileSize * 0.7 - eyeSize / 2; eye2Y = part.y + tileSize * 0.75 - eyeSize / 2; // Leggermente aggiustato 0.8 -> 0.75
                } else if (dx < 0) { // Sinistra
                    eye1X = part.x + tileSize * 0.3 - eyeSize / 2; eye1Y = part.y + tileSize * 0.25 - eyeSize / 2;
                    eye2X = part.x + tileSize * 0.3 - eyeSize / 2; eye2Y = part.y + tileSize * 0.75 - eyeSize / 2;
                } else if (dy > 0) { // Giù
                    eye1X = part.x + tileSize * 0.25 - eyeSize / 2; eye1Y = part.y + tileSize * 0.7 - eyeSize / 2;
                    eye2X = part.x + tileSize * 0.75 - eyeSize / 2; eye2Y = part.y + tileSize * 0.7 - eyeSize / 2;
                } else { // Su
                    eye1X = part.x + tileSize * 0.25 - eyeSize / 2; eye1Y = part.y + tileSize * 0.3 - eyeSize / 2;
                    eye2X = part.x + tileSize * 0.75 - eyeSize / 2; eye2Y = part.y + tileSize * 0.3 - eyeSize / 2;
                }
                ctx.fillRect(eye1X, eye1Y, eyeSize, eyeSize);
                ctx.fillRect(eye2X, eye2Y, eyeSize, eyeSize);
            }
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
        }

        function drawSnake() {
            snake.forEach(drawSnakePart);
        }

        function drawFood() {
            // Usa un font size leggermente più grande del tileSize per emoji più visibili
            // ma assicurati che si adatti al tileSize più piccolo
            const fontSize = Math.max(tileSize, tileSize * 0.8 + 4); // Es. se tileSize è 12, font è ~13.6
            ctx.font = `${fontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            ctx.shadowColor = '#ffcc00';
            ctx.shadowBlur = Math.max(3, tileSize * 0.4); // Ombra cibo adattata
            ctx.fillStyle = '#fff'; // Emoji di solito hanno i loro colori

            // Aggiustamento verticale per emoji più preciso
            ctx.fillText(currentFoodEmoji, food.x + tileSize / 2, food.y + tileSize / 2 + tileSize * 0.1);

            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
        }

        function updateSnake() {
            // gameRunning è già controllato in gameLoop
            const head = { x: snake[0].x + dx, y: snake[0].y + dy };

            // Wrap around
            if (head.x >= canvasSize) head.x = 0;
            if (head.x < 0) head.x = canvasSize - tileSize;
            if (head.y >= canvasSize) head.y = 0;
            if (head.y < 0) head.y = canvasSize - tileSize;

            snake.unshift(head);

            const ateFood = head.x === food.x && head.y === food.y;
            if (ateFood) {
                score += 10;
                spawnFood();
                if (score % 50 === 0 && frameInterval > 60) { // Limite velocità più basso
                    frameInterval -= 10; // Aumenta velocità
                }
            } else {
                snake.pop();
            }

            checkCollision(); // Controlla collisione dopo aver mosso la testa
        }

        function showMessage(text, showRestartBtn = true) {
            messageText.textContent = text;
            restartButton.style.display = showRestartBtn ? 'inline-block' : 'none';
            messageOverlay.style.display = 'flex';
            gamePausedForMessage = true;
        }

        function hideMessage() {
            messageOverlay.style.display = 'none';
        }

        function checkCollision() {
            const head = snake[0];
            for (let i = 1; i < snake.length; i++) {
                if (head.x === snake[i].x && head.y === snake[i].y) {
                    handleDeath();
                    return; // Esce dalla funzione dopo la morte
                }
            }
        }

        function handleDeath() {
            // gameRunning è già false se questo viene chiamato
            lives--;
            updateUI(); // Aggiorna UI subito
            if (lives > 0) {
                gameRunning = false; // Ferma il gioco per mostrare il messaggio
                showMessage(`Hai perso una vita! Vite rimanenti: ${lives}.`, true);
            } else {
                gameOver();
            }
        }

        function gameOver() {
            gameRunning = false; // Assicura che il gioco sia fermo
            showMessage(`Game Over! Punteggio Finale: ${score}.`, true);
        }


        function clearCanvas() {
            ctx.shadowColor = "rgba(0, 255, 0, 0.2)"; // Ombra più sottile
            ctx.shadowBlur = Math.max(10, tileSize * 0.8); // Adattato
            ctx.fillStyle = '#000500';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
        }

        function updateUI() {
            scoreDisplay.textContent = `Score: ${score}`;
            livesDisplay.textContent = `Vite: ${lives}`;
        }

        function changeDirection(event) {
            if (changingDirection || !gameRunning || gamePausedForMessage) return;
            changingDirection = true;

            const keyPressed = event.key;
            const buttonId = event.target ? event.target.id : null;

            const goingUp = dy === -tileSize;
            const goingDown = dy === tileSize;
            const goingLeft = dx === -tileSize;
            const goingRight = dx === tileSize;

            if ((keyPressed === 'ArrowUp' || buttonId === 'up-btn') && !goingDown) {
                dx = 0; dy = -tileSize;
            } else if ((keyPressed === 'ArrowDown' || buttonId === 'down-btn') && !goingUp) {
                dx = 0; dy = tileSize;
            } else if ((keyPressed === 'ArrowLeft' || buttonId === 'left-btn') && !goingRight) {
                dx = -tileSize; dy = 0;
            } else if ((keyPressed === 'ArrowRight' || buttonId === 'right-btn') && !goingLeft) {
                dx = tileSize; dy = 0;
            } else {
                changingDirection = false; // Se nessuna direzione valida è stata scelta
            }
        }

        let animationFrameId = null; // Per poter cancellare il loop
        function gameLoop(currentTime) {
            if (gamePausedForMessage) {
                 animationFrameId = requestAnimationFrame(gameLoop); // Continua a richiedere frame per sbloccarsi
                 return;
            }
            if (!gameRunning) {
                // Se il gioco non è in esecuzione (es. dopo game over o prima dell'inizio), non fare nulla
                // Ma se c'è un messaggio di "hai perso una vita", gameRunning sarà false
                // Non cancellare l'animationFrameId qui, altrimenti non riparte con resetLevel/initGame
                return;
            }

            const deltaTime = currentTime - lastFrameTime;

            if (deltaTime > frameInterval) {
                lastFrameTime = currentTime - (deltaTime % frameInterval); // Sincronizza meglio il tempo
                changingDirection = false;

                clearCanvas();
                drawFood();
                updateSnake(); // Qui dentro c'è checkCollision, che può settare gameRunning = false
                if (gameRunning) { // Disegna il serpente solo se il gioco è ancora attivo dopo updateSnake
                    drawSnake();
                }
                updateUI();
            }

            if(gameRunning) { // Richiedi il prossimo frame solo se il gioco deve continuare
               animationFrameId = requestAnimationFrame(gameLoop);
            }
        }

        document.addEventListener('keydown', changeDirection);
        upBtn.addEventListener('click', changeDirection);
        downBtn.addEventListener('click', changeDirection);
        leftBtn.addEventListener('click', changeDirection);
        rightBtn.addEventListener('click', changeDirection);

        restartButton.addEventListener('click', () => {
            // gamePausedForMessage sarà true qui
            if (lives > 0) { // Se ha perso una vita ma il gioco era in pausa (o game over ma con vite)
                resetLevel(); // Questo imposta gameRunning = true e chiama gameLoop
            } else { // Se era game over definitivo (lives <= 0)
                initGame(); // Questo imposta gameRunning = true e chiama gameLoop
            }
        });

        initGame();

    </script>
</body>
</html>
