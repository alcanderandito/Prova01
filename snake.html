<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Snake ai Due Mori</title>
    <style>
        body {
            background-color: #0a0a1f;
            color: #fff;
            font-family: 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 10px;
            box-sizing: border-box;
            overflow-x: hidden;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: rgba(10, 10, 31, 0.8);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 0 15px #ff00ff, 0 0 30px #ff00ff, inset 0 0 10px #ff00ff;
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #00ffff;
            text-shadow: 0 0 5px #00ffff, 0 0 10px #00ffff, 0 0 15px #00ffff, 0 0 20px #0ff, 0 0 30px #0ff, 0 0 40px #0ff;
            text-align: center;
        }

        .info-panel {
            display: flex;
            justify-content: space-around;
            width: 100%;
            max-width: 400px;
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        .info-panel span {
            color: #f0f;
            text-shadow: 0 0 3px #f0f, 0 0 5px #f0f, 0 0 7px #f0f;
        }

        #gameCanvas {
            border: 3px solid #00ff00;
            box-shadow: 0 0 10px #00ff00, 0 0 20px #00ff00;
            background-color: #000500;
            border-radius: 5px;
        }
        
        .message-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0,0,0,0.85); /* Leggermente pi√π opaco */
            color: #fff;
            padding: 25px; /* Aumentato padding per pi√π spazio */
            border-radius: 10px;
            text-align: center;
            /* display: none; Nascosto di default, gestito da JS */
            z-index: 100;
            font-size: 1.4em; /* Leggermente ridotto per messaggi lunghi */
            box-shadow: 0 0 10px #fff, 0 0 20px #fff;
            
            /* Modifiche per layout del contenuto dell'overlay */
            display: none; /* Mantenuto per la logica JS di show/hide */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 20px; /* Spazio tra il testo e il bottone */
            min-width: 280px; /* Larghezza minima per evitare che sia troppo stretto */
        }
        .message-overlay p {
            margin: 0; /* Rimuove margini default del paragrafo */
            line-height: 1.4; /* Migliore leggibilit√† per testo multi-linea */
        }
        .message-overlay button {
            margin-top: 0; /* Rimosso, ora gestito da 'gap' del flex container */
            /* Stile ereditato da .control-btn, ma possiamo sovrascrivere se necessario */
            font-size: 0.8em !important; /* Ridimensionato per essere meno invasivo nell'overlay */
            padding: 12px 20px !important;
        }


        .controls {
            margin-top: 20px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 10px;
            width: 180px;
            height: 180px;
        }

        .control-btn {
            background-color: rgba(0, 255, 255, 0.1);
            border: 2px solid #00ffff;
            color: #00ffff;
            font-size: 2em;
            border-radius: 10px;
            cursor: pointer;
            user-select: none;
            box-shadow: 0 0 5px #00ffff, 0 0 10px #00ffff, inset 0 0 5px rgba(0,255,255,0.5);
            transition: background-color 0.2s, box-shadow 0.2s;
        }
        .control-btn:active {
            background-color: rgba(0, 255, 255, 0.3);
            box-shadow: 0 0 8px #00ffff, 0 0 15px #00ffff, inset 0 0 8px rgba(0,255,255,0.7);
        }

        #up-btn    { grid-column: 2; grid-row: 1; }
        #left-btn  { grid-column: 1; grid-row: 2; }
        #right-btn { grid-column: 3; grid-row: 2; }
        #down-btn  { grid-column: 2; grid-row: 3; }
        
        .center-fill { grid-column: 2; grid-row: 2; visibility: hidden; }


        .home-btn {
            margin-top: 25px;
            padding: 10px 20px;
            font-size: 1em;
            background-color: rgba(255, 0, 255, 0.2);
            border: 2px solid #ff00ff;
            color: #ff00ff;
            text-decoration: none;
            border-radius: 8px;
            box-shadow: 0 0 5px #ff00ff, 0 0 10px #ff00ff;
            transition: background-color 0.2s, box-shadow 0.2s;
        }
        .home-btn:hover, .home-btn:active {
            background-color: rgba(255, 0, 255, 0.4);
            box-shadow: 0 0 8px #ff00ff, 0 0 15px #ff00ff;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>Snake ai Due Mori</h1>
        <div class="info-panel">
            <span id="lives">Vite: 5</span>
            <span id="score">Score: 0</span>
        </div>
        <canvas id="gameCanvas"></canvas>
        <div id="messageOverlay" class="message-overlay"> <!-- display:flex sar√† applicato da JS -->
            <p id="messageText"></p>
            <button id="restartButton" class="control-btn">Ricomincia</button>
        </div>
        <div class="controls">
            <div></div> 
            <button id="up-btn" class="control-btn">‚ñ≤</button>
            <div></div> 
            <button id="left-btn" class="control-btn">‚óÑ</button>
            <div class="center-fill"></div>
            <button id="right-btn" class="control-btn">‚ñ∫</button>
            <div></div> 
            <button id="down-btn" class="control-btn">‚ñº</button>
            <div></div> 
        </div>
        <a href="index.html" class="home-btn">Torna alla Home</a>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const livesDisplay = document.getElementById('lives');
        const scoreDisplay = document.getElementById('score');
        
        const messageOverlay = document.getElementById('messageOverlay');
        const messageText = document.getElementById('messageText');
        const restartButton = document.getElementById('restartButton');

        const gridSize = 20; 
        const canvasSize = 400; 
        canvas.width = canvasSize;
        canvas.height = canvasSize;
        const tileSize = canvas.width / gridSize;

        let snake;
        let food;
        let dx = tileSize; 
        let dy = 0;       
        let score;
        let lives;
        let gameRunning;
        let changingDirection; 
        let gamePausedForMessage = false;

        // Array di emoji di cibo espanso
        const foodEmojis = [
            'üçé', 'üçì', 'üçí', 'üçâ', 'üçá', 'üçå', 'ü•≠', 'üçç', 'üçë', 'ü•ù', 'üçï', 'üçî', 'üçü', 'üç©', 'üç™',
            'üçä', 'üçã', 'üçê', 'ü••', 'üçÖ', 'üçÜ', 'ü•ë', 'ü•¶', 'ü•¨', 'ü•í', 'üå∂Ô∏è', 'üåΩ', 'ü•ï', 'üßÑ', 'üßÖ',
            'ü•î', 'üç†', 'ü•ê', 'ü•Ø', 'üçû', 'ü•ñ', 'ü•®', 'üßÄ', 'ü•ö', 'üç≥', 'ü•û', 'üßá', 'ü•ì', 'ü•©', 'üçó',
            'üçñ', 'üå≠', 'üåÆ', 'üåØ', 'ü•ô', 'üßÜ', 'ü•ó', 'üç≤', 'üçú', ' Spaghetti', 'üç£', 'üç±', 'üçõ', 'üçô',
            'üçö', 'üçò', 'üç•', 'ü•†', 'ü•Æ', 'üç¢', 'üç°', 'üçß', 'üç®', 'üç¶', 'ü•ß', 'üßÅ', 'üç∞', 'üéÇ', 'üçÆ',
            'üç≠', 'üç¨', 'üç´', 'üçø', 'üå∞', 'ü•ú', 'üçØ', 'ü•õ', '‚òï', 'üçµ', 'üßÉ', 'ü•§', 'üßã', 'üßâ' 
        ];
        let currentFoodEmoji;

        let lastFrameTime = 0;
        const initialFrameInterval = 180; 
        let frameInterval = initialFrameInterval; 

        const upBtn = document.getElementById('up-btn');
        const downBtn = document.getElementById('down-btn');
        const leftBtn = document.getElementById('left-btn');
        const rightBtn = document.getElementById('right-btn');

        function getRandomFoodEmoji() {
            return foodEmojis[Math.floor(Math.random() * foodEmojis.length)];
        }

        function initSnake() {
            snake = [
                { x: tileSize * Math.floor(gridSize / 2), y: tileSize * Math.floor(gridSize / 2) },
                { x: tileSize * (Math.floor(gridSize / 2) - 1), y: tileSize * Math.floor(gridSize / 2) },
                { x: tileSize * (Math.floor(gridSize / 2) - 2), y: tileSize * Math.floor(gridSize / 2) }
            ];
            dx = tileSize;
            dy = 0;
            frameInterval = initialFrameInterval;
        }

        function spawnFood() {
            currentFoodEmoji = getRandomFoodEmoji();
            food = {
                x: Math.floor(Math.random() * gridSize) * tileSize,
                y: Math.floor(Math.random() * gridSize) * tileSize
            };
            snake.forEach(part => {
                if (part.x === food.x && part.y === food.y) {
                    spawnFood();
                }
            });
        }

        function initGame() {
            hideMessage();
            gamePausedForMessage = false;
            score = 0;
            lives = 5;
            initSnake();
            spawnFood();
            updateUI();
            gameRunning = true;
            changingDirection = false;
            lastFrameTime = 0; 
            gameLoop();
        }
        
        function resetLevel() {
            hideMessage();
            gamePausedForMessage = false;
            initSnake();
            spawnFood(); 
            updateUI();
            gameRunning = true;
            changingDirection = false;
            lastFrameTime = 0; 
            gameLoop();
        }

        function drawSnakePart(part, index) {
            const isHead = index === 0;
            ctx.shadowColor = '#00ff00'; 
            ctx.shadowBlur = isHead ? 15 : 10;
            ctx.fillStyle = isHead ? '#33ff33' : '#00cc00'; 
            
            ctx.fillRect(part.x, part.y, tileSize, tileSize);
            ctx.strokeStyle = '#003300'; 
            ctx.strokeRect(part.x, part.y, tileSize, tileSize);

            if (isHead) {
                ctx.fillStyle = '#000'; 
                ctx.shadowBlur = 0; 
                let eye1X, eye1Y, eye2X, eye2Y;
                const eyeSize = tileSize / 5;

                if (dx > 0) { 
                    eye1X = part.x + tileSize * 0.7 - eyeSize / 2; eye1Y = part.y + tileSize * 0.2 - eyeSize / 2;
                    eye2X = part.x + tileSize * 0.7 - eyeSize / 2; eye2Y = part.y + tileSize * 0.8 - eyeSize / 2;
                } else if (dx < 0) { 
                    eye1X = part.x + tileSize * 0.3 - eyeSize / 2; eye1Y = part.y + tileSize * 0.2 - eyeSize / 2;
                    eye2X = part.x + tileSize * 0.3 - eyeSize / 2; eye2Y = part.y + tileSize * 0.8 - eyeSize / 2;
                } else if (dy > 0) { 
                    eye1X = part.x + tileSize * 0.2 - eyeSize / 2; eye1Y = part.y + tileSize * 0.7 - eyeSize / 2;
                    eye2X = part.x + tileSize * 0.8 - eyeSize / 2; eye2Y = part.y + tileSize * 0.7 - eyeSize / 2;
                } else { 
                    eye1X = part.x + tileSize * 0.2 - eyeSize / 2; eye1Y = part.y + tileSize * 0.3 - eyeSize / 2;
                    eye2X = part.x + tileSize * 0.8 - eyeSize / 2; eye2Y = part.y + tileSize * 0.3 - eyeSize / 2;
                }
                ctx.fillRect(eye1X, eye1Y, eyeSize, eyeSize);
                ctx.fillRect(eye2X, eye2Y, eyeSize, eyeSize);
            }
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
        }

        function drawSnake() {
            snake.forEach(drawSnakePart);
        }

        function drawFood() {
            ctx.font = `${tileSize * 0.8}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            ctx.shadowColor = '#ffcc00'; 
            ctx.shadowBlur = 8;
            ctx.fillStyle = '#fff'; 

            ctx.fillText(currentFoodEmoji, food.x + tileSize / 2, food.y + tileSize / 2 + tileSize*0.05); 

            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
        }

        function updateSnake() {
            if (!gameRunning) return;

            const head = { x: snake[0].x + dx, y: snake[0].y + dy };

            if (head.x >= canvas.width) head.x = 0;
            if (head.x < 0) head.x = canvas.width - tileSize;
            if (head.y >= canvas.height) head.y = 0;
            if (head.y < 0) head.y = canvas.height - tileSize;

            snake.unshift(head); 

            const ateFood = head.x === food.x && head.y === food.y;
            if (ateFood) {
                score += 10;
                spawnFood();
                if (score % 50 === 0 && frameInterval > 80) { 
                    frameInterval -= 10;
                }
            } else {
                snake.pop(); 
            }

            checkCollision();
        }
        
        function showMessage(text, showRestartBtn = true) {
            messageText.textContent = text;
            restartButton.style.display = showRestartBtn ? 'inline-block' : 'none';
            messageOverlay.style.display = 'flex'; // Modificato per usare flex
            gamePausedForMessage = true;
        }

        function hideMessage() {
            messageOverlay.style.display = 'none';
        }

        function checkCollision() {
            const head = snake[0];
            for (let i = 1; i < snake.length; i++) {
                if (head.x === snake[i].x && head.y === snake[i].y) {
                    handleDeath();
                    return;
                }
            }
        }
        
        function handleDeath() {
            gameRunning = false;
            lives--;
            if (lives > 0) {
                showMessage(`Hai perso una vita! Vite rimanenti: ${lives}.`, true);
            } else {
                gameOver();
            }
            updateUI();
        }

        function gameOver() {
            gameRunning = false;
            showMessage(`Game Over! Punteggio Finale: ${score}.`, true);
        }


        function clearCanvas() {
            ctx.shadowColor = "rgba(0, 255, 0, 0.3)"; 
            ctx.shadowBlur = 20;
            ctx.fillStyle = '#000500'; 
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
        }

        function updateUI() {
            scoreDisplay.textContent = `Score: ${score}`;
            livesDisplay.textContent = `Vite: ${lives}`;
        }

        function changeDirection(event) {
            if (changingDirection || !gameRunning || gamePausedForMessage) return; // Aggiunto gamePausedForMessage
            changingDirection = true;

            const keyPressed = event.key; 
            const buttonId = event.target ? event.target.id : null; 

            const goingUp = dy === -tileSize;
            const goingDown = dy === tileSize;
            const goingLeft = dx === -tileSize;
            const goingRight = dx === tileSize;

            if ((keyPressed === 'ArrowUp' || buttonId === 'up-btn') && !goingDown) {
                dx = 0; dy = -tileSize;
            } else if ((keyPressed === 'ArrowDown' || buttonId === 'down-btn') && !goingUp) {
                dx = 0; dy = tileSize;
            } else if ((keyPressed === 'ArrowLeft' || buttonId === 'left-btn') && !goingRight) {
                dx = -tileSize; dy = 0;
            } else if ((keyPressed === 'ArrowRight' || buttonId === 'right-btn') && !goingLeft) {
                dx = tileSize; dy = 0;
            } else {
                changingDirection = false; 
            }
        }

        function gameLoop(currentTime) {
            if (gamePausedForMessage) {
                 // Se il messaggio √® attivo, non si fa nulla tranne aspettare che l'utente lo chiuda
                 // Potremmo richiedere un altro frame per non bloccare completamente, ma non √® strettamente necessario
                 requestAnimationFrame(gameLoop); // Chiamiamo comunque per non interrompere il loop se il messaggio viene chiuso
                 return;
            }
            if (!gameRunning) {
                return;
            }

            const deltaTime = currentTime - lastFrameTime;

            if (deltaTime > frameInterval) {
                lastFrameTime = currentTime;
                changingDirection = false; 

                clearCanvas();
                drawFood(); 
                updateSnake(); 
                drawSnake();   
                updateUI();    
            }
            
            requestAnimationFrame(gameLoop);
        }

        document.addEventListener('keydown', changeDirection);
        upBtn.addEventListener('click', changeDirection);
        downBtn.addEventListener('click', changeDirection);
        leftBtn.addEventListener('click', changeDirection);
        rightBtn.addEventListener('click', changeDirection);
        
        restartButton.addEventListener('click', () => {
            if (lives > 0 && !gameRunning) { // Se ha perso una vita ma il gioco era in pausa
                resetLevel();
            } else if (lives <= 0) { // Se era game over
                initGame(); 
            }
            // Se il gioco era in corso e si clicca (improbabile), non fa nulla di speciale
        });

        initGame();

    </script>
</body>
</html>
