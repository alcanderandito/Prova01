<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tetris Polenta e Formai</title>
    <style>
        body {
            background-color: #4a3b31; 
            color: #fff;
            font-family: 'Georgia', serif; 
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; 
            min-height: 100vh;
            margin: 0;
            padding: 10px; /* Ridotto padding generale */
            box-sizing: border-box;
            overflow-x: hidden;
        }

        .game-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: rgba(60, 45, 35, 0.85); 
            padding: 15px; /* Ridotto padding */
            border-radius: 15px; /* Ridotto raggio */
            box-shadow: 0 0 15px #ffcc66, 0 0 30px #ffcc66, inset 0 0 10px #ffcc66; 
            width: 100%;
            max-width: 500px; /* Limita la larghezza massima su desktop */
        }

        h1 {
            font-size: 2.2em; /* Ridotto */
            margin-bottom: 10px; /* Ridotto */
            color: #FFD700; 
            text-shadow: 0 0 4px #DAA520, 0 0 8px #DAA520, 0 0 12px #DAA520, 0 0 16px #FFBF00, 0 0 24px #FFBF00;
            text-align: center;
            font-variant: small-caps;
        }

        .main-content {
            display: flex;
            /* flex-direction: row; Default per schermi larghi */
            align-items: flex-start;
            gap: 15px; /* Ridotto */
            flex-wrap: wrap; 
            justify-content: center;
            width: 100%;
        }
        
        .game-board-container {
            /* Contenitore per il canvas principale */
        }

        #gameCanvas {
            border: 3px solid #DAA520; /* Ridotto spessore */
            box-shadow: 0 0 8px #DAA520, 0 0 12px #DAA520;
            background-color: #2a1f17; 
            border-radius: 6px; /* Ridotto */
        }
        
        .info-and-next {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px; /* Ridotto */
            min-width: 120px; /* Ridotto */
            flex-grow: 1; /* Permette di occupare spazio disponibile */
        }

        .info-panel {
            display: flex;
            flex-direction: column; 
            align-items: center;
            gap: 8px; /* Ridotto */
            font-size: 1.1em; /* Ridotto */
            background-color: rgba(90, 70, 55, 0.7); 
            padding: 10px; /* Ridotto */
            border-radius: 8px; /* Ridotto */
            box-shadow: 0 0 6px #FFA500, inset 0 0 4px #FFA500; 
            width: 100%;
            max-width: 200px; /* Limita larghezza del pannello info */
        }

        .info-panel span {
            color: #FFFACD; 
            text-shadow: 0 0 2px #F0E68C, 0 0 4px #F0E68C; 
        }
        
        .next-piece-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .next-piece-container p {
            margin: 0 0 5px 0;
            font-size: 1em; /* Ridotto */
            color: #FFA500; 
            text-shadow: 0 0 2px #DAA520;
        }
        #nextCanvas {
            border: 2px solid #F0E68C; 
            background-color: rgba(42, 31, 23, 0.8); 
            border-radius: 4px; /* Ridotto */
            box-shadow: 0 0 4px #F0E68C;
        }
        
        .message-overlay {
            position: fixed; /* Cambiato a fixed per essere sempre centrato nella viewport */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(42, 31, 23, 0.9);
            color: #FFFACD;
            padding: 20px; /* Ridotto */
            border-radius: 10px;
            text-align: center;
            z-index: 100;
            font-size: 1.2em; /* Ridotto */
            box-shadow: 0 0 8px #FFFACD, 0 0 15px #FFFACD;
            display: none; 
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 15px; /* Ridotto */
            min-width: 250px; /* Ridotto */
            max-width: 90%; /* Limita larghezza su schermi piccoli */
        }
        .message-overlay p { margin: 0; line-height: 1.3; }
        .message-overlay button {
            margin-top: 0;
            font-size: 0.7em !important; 
            padding: 10px 18px !important; /* Ridotto */
        }

        .controls {
            margin-top: 20px; /* Ridotto */
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr); 
            gap: 8px; /* Ridotto */
            width: 180px; /* Ridotto */
            height: 230px; /* Ridotto */
        }

        .control-btn {
            background-color: rgba(255, 215, 0, 0.15); 
            border: 2px solid #FFD700;
            color: #FFD700;
            font-size: 1.1em; /* Ridotto per testo più lungo */
            border-radius: 8px; /* Ridotto */
            cursor: pointer;
            user-select: none;
            box-shadow: 0 0 4px #FFD700, 0 0 8px #FFD700, inset 0 0 4px rgba(255,215,0,0.5);
            transition: background-color 0.2s, box-shadow 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 5px; /* Aggiunto padding interno */
        }
        .control-btn:active {
            background-color: rgba(255, 215, 0, 0.3);
            box-shadow: 0 0 6px #FFD700, 0 0 12px #FFD700, inset 0 0 6px rgba(255,215,0,0.7);
        }

        #up-btn    { grid-column: 2; grid-row: 1; } 
        #left-btn  { grid-column: 1; grid-row: 2; }
        #right-btn { grid-column: 3; grid-row: 2; }
        #down-btn  { grid-column: 2; grid-row: 2; } 
        #drop-btn  { grid-column: 2; grid-row: 3; } 
        
        .empty-dpad-tl { grid-column: 1; grid-row: 1; visibility: hidden;}
        .empty-dpad-tr { grid-column: 3; grid-row: 1; visibility: hidden;}
        .empty-dpad-bl { grid-column: 1; grid-row: 3; visibility: hidden;}
        .empty-dpad-br { grid-column: 3; grid-row: 3; visibility: hidden;}


        .home-btn {
            margin-top: 20px; /* Ridotto */
            padding: 10px 20px; /* Ridotto */
            font-size: 1em; /* Ridotto */
            background-color: rgba(218, 165, 32, 0.3); 
            border: 2px solid #DAA520;
            color: #DAA520;
            text-decoration: none;
            border-radius: 8px; 
            box-shadow: 0 0 4px #DAA520, 0 0 8px #DAA520;
            transition: background-color 0.2s, box-shadow 0.2s;
        }
        .home-btn:hover, .home-btn:active {
            background-color: rgba(218, 165, 32, 0.5);
            box-shadow: 0 0 6px #DAA520, 0 0 12px #DAA520;
        }
        
        /* Media query per layout su schermi piccoli */
        @media (max-width: 520px) { /* Punto di interruzione basato sulla larghezza del game-area */
            .main-content {
                flex-direction: column;
                align-items: center; /* Centra gli elementi quando sono in colonna */
            }
            .info-and-next {
                order: -1; /* Mette info e next prima del canvas se vanno in colonna */
                width: 100%; /* Occupa tutta la larghezza */
                flex-direction: row; /* Info e next affiancati */
                justify-content: space-around; /* Distribuisce lo spazio */
                align-items: flex-start;
            }
            .info-panel {
                 max-width: none; /* Permette al pannello info di espandersi */
                 flex-basis: 150px; /* Base per flessibilità */
            }
            .next-piece-container{
                 flex-basis: 120px; /* Base per flessibilità */
            }
             h1 {
                font-size: 1.8em;
            }
        }

    </style>
</head>
<body>
    <div class="game-area">
        <h1>Tetris Polenta e Formai</h1>
        <div class="main-content">
            <div class="game-board-container">
                <canvas id="gameCanvas"></canvas>
            </div>
            <div class="info-and-next">
                <div class="info-panel">
                    <span id="score">Score: 0</span>
                    <span id="lives">Vite: 3</span>
                    <span id="level">Livello: 1</span>
                </div>
                <div class="next-piece-container">
                    <p>Prossimo:</p>
                    <canvas id="nextCanvas"></canvas>
                </div>
            </div>
        </div>
         <div id="messageOverlay" class="message-overlay">
            <p id="messageText"></p>
            <button id="restartButton" class="control-btn">Ricomincia</button>
        </div>
        <div class="controls">
            <div class="empty-dpad-tl"></div>
            <button id="up-btn" class="control-btn">GIRA</button> 
            <div class="empty-dpad-tr"></div>

            <button id="left-btn" class="control-btn">◄</button>
            <button id="down-btn" class="control-btn">▼</button> 
            <button id="right-btn" class="control-btn">►</button>
            
            <div class="empty-dpad-bl"></div>
            <button id="drop-btn" class="control-btn">CADE</button> 
            <div class="empty-dpad-br"></div>
        </div>
        <a href="index.html" class="home-btn">Torna alla Home</a>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const nextCanvas = document.getElementById('nextCanvas');
        const nextCtx = nextCanvas.getContext('2d');

        const scoreDisplay = document.getElementById('score');
        const livesDisplay = document.getElementById('lives');
        const levelDisplay = document.getElementById('level');
        
        const messageOverlay = document.getElementById('messageOverlay');
        const messageText = document.getElementById('messageText');
        const restartButton = document.getElementById('restartButton');

        const COLS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = 24; // << RIDOTTO BLOCK_SIZE
        const NEXT_CANVAS_GRID_SIZE = 4; 

        canvas.width = COLS * BLOCK_SIZE;
        canvas.height = ROWS * BLOCK_SIZE;
        nextCanvas.width = NEXT_CANVAS_GRID_SIZE * BLOCK_SIZE;
        nextCanvas.height = NEXT_CANVAS_GRID_SIZE * BLOCK_SIZE;

        const COLORS = [ null, '#FFD700', '#FFFACD', '#FFA500', '#F0E68C', '#DAA520', '#FFFFE0', '#FFBF00' ];
        const SHADOW_COLORS = [ null, '#DAA520', '#F0E68C', '#E69500', '#D8C970', '#B8860B', '#E0DDB0', '#D9A300' ];

        const TETROMINOES = {
            'I': { shape: [[1,1,1,1]], colorIndex: 1 }, 
            'O': { shape: [[2,2],[2,2]], colorIndex: 2 }, 
            'T': { shape: [[0,3,0],[3,3,3]], colorIndex: 3 }, 
            'S': { shape: [[0,4,4],[4,4,0]], colorIndex: 4 }, 
            'Z': { shape: [[5,5,0],[0,5,5]], colorIndex: 5 }, 
            'J': { shape: [[6,0,0],[6,6,6]], colorIndex: 6 }, 
            'L': { shape: [[0,0,7],[7,7,7]], colorIndex: 7 }  
        };
        const PIECE_KEYS = 'IOTZSLJ';

        let board = createBoard();
        let currentPiece;
        let nextPiece;
        let score;
        let lives;
        let level;
        let dropCounter;
        let dropInterval; 
        let gameRunning;
        let gamePausedForMessage = false;

        const initialLives = 3;
        const initialDropInterval = 1000; 
        const levelSpeedIncrease = 100; 

        function createBoard() {
            return Array.from({ length: ROWS }, () => Array(COLS).fill(0));
        }

        function getRandomPiece() {
            const rand = Math.floor(Math.random() * PIECE_KEYS.length);
            const key = PIECE_KEYS[rand];
            const pieceData = TETROMINOES[key];
            return {
                shape: pieceData.shape.map(row => row.slice()), 
                colorIndex: pieceData.colorIndex,
                x: Math.floor(COLS / 2) - Math.floor(pieceData.shape[0].length / 2),
                y: 0  // Per i pezzi a T,S,Z,J,L a volte iniziano parzialmente fuori se y=-1
            };
        }

        function drawBlock(ctxInstance, x, y, colorIndex, bs = BLOCK_SIZE, isGhost = false) {
            if (colorIndex === 0) return;
            ctxInstance.fillStyle = COLORS[colorIndex];
            if (isGhost) {
                ctxInstance.globalAlpha = 0.25; // Più trasparente
                ctxInstance.strokeStyle = COLORS[colorIndex];
                ctxInstance.lineWidth = 1; // Bordo più sottile per ghost
                ctxInstance.strokeRect(x * bs + 0.5, y * bs + 0.5, bs -1, bs -1); // Leggermente indentato
            } else {
                ctxInstance.globalAlpha = 1.0;
                ctxInstance.shadowColor = SHADOW_COLORS[colorIndex];
                ctxInstance.shadowBlur = 6; // Ridotto blur
                ctxInstance.fillRect(x * bs, y * bs, bs, bs);
                
                ctxInstance.shadowBlur = 0;
                ctxInstance.strokeStyle = 'rgba(0,0,0,0.2)'; // Bordo più leggero
                ctxInstance.lineWidth = 1;
                ctxInstance.strokeRect(x * bs + 0.5, y * bs + 0.5, bs-1, bs-1); // Aggiunge un bordo interno
            }
             ctxInstance.globalAlpha = 1.0; 
        }

        function drawBoard() {
            board.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        drawBlock(ctx, x, y, value);
                    }
                });
            });
        }
        
        // MODIFICATA: drawPiece per gestire correttamente il disegno su nextCtx
        function drawPiece(piece, ctxInstance = ctx, customOffsetX = 0, customOffsetY = 0, bs = BLOCK_SIZE) {
            piece.shape.forEach((row, yRel) => { // yRel è y relativa alla forma del pezzo
                row.forEach((value, xRel) => { // xRel è x relativa alla forma del pezzo
                    if (value !== 0) {
                        let drawX, drawY;
                        if (ctxInstance === nextCtx) {
                            // Per nextCanvas, le coordinate sono relative all'angolo del nextCanvas + customOffset
                            drawX = xRel + customOffsetX;
                            drawY = yRel + customOffsetY;
                        } else {
                            // Per il canvas principale, le coordinate sono quelle del pezzo sul tabellone
                            // customOffsetX e Y non vengono usati qui, ma passati come 0 di default
                            drawX = piece.x + xRel; 
                            drawY = piece.y + yRel; 
                        }
                        drawBlock(ctxInstance, drawX, drawY, piece.colorIndex, bs);
                    }
                });
            });
        }
        
        function drawGhostPiece() {
            if (!currentPiece || !gameRunning) return; // Non disegnare se non c'è pezzo o gioco non attivo
            let ghostY = currentPiece.y;
            // Crea una copia temporanea del pezzo per non modificarne la y originale
            const ghostPieceShape = currentPiece.shape; 
            const ghostPieceX = currentPiece.x;

            while (isValidMove(ghostPieceShape, ghostPieceX, ghostY + 1)) {
                ghostY++;
            }
            ghostPieceShape.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        drawBlock(ctx, ghostPieceX + x, ghostY + y, currentPiece.colorIndex, BLOCK_SIZE, true);
                    }
                });
            });
        }


        function drawNextPiece() {
            nextCtx.fillStyle = 'rgba(42, 31, 23, 0.8)'; // Sfondo canvas next come da CSS
            nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
            if (nextPiece && nextPiece.shape) { // Assicurati che nextPiece e la sua forma esistano
                const shape = nextPiece.shape;
                const offsetX = Math.floor((NEXT_CANVAS_GRID_SIZE - shape[0].length) / 2);
                const offsetY = Math.floor((NEXT_CANVAS_GRID_SIZE - shape.length) / 2);
                // Chiama drawPiece con customOffsetX e customOffsetY specifici per nextCtx
                drawPiece(nextPiece, nextCtx, offsetX, offsetY, BLOCK_SIZE); 
            }
        }
        
        function clearCanvas() {
            ctx.fillStyle = '#2a1f17'; 
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function update() { 
            if (!gameRunning || gamePausedForMessage) return;
            
            dropCounter += (performance.now() - lastTime); 
            lastTime = performance.now();

            if (dropCounter > dropInterval) {
                pieceDrop();
            }
        }

        function pieceMove(dir) {
            if (!gameRunning || gamePausedForMessage || !currentPiece) return;
            if (isValidMove(currentPiece.shape, currentPiece.x + dir, currentPiece.y)) {
                currentPiece.x += dir;
            }
        }

        function pieceRotate() {
            if (!gameRunning || gamePausedForMessage || !currentPiece) return;
            const originalShape = currentPiece.shape;
            const rotated = [];
            for (let y = 0; y < originalShape[0].length; y++) {
                rotated[y] = [];
                for (let x = 0; x < originalShape.length; x++) {
                    rotated[y][x] = originalShape[originalShape.length - 1 - x][y];
                }
            }
            if (isValidMove(rotated, currentPiece.x, currentPiece.y)) {
                currentPiece.shape = rotated;
            } else {
                if (isValidMove(rotated, currentPiece.x + 1, currentPiece.y)) {
                    currentPiece.x += 1; currentPiece.shape = rotated;
                } else if (isValidMove(rotated, currentPiece.x - 1, currentPiece.y)) {
                    currentPiece.x -= 1; currentPiece.shape = rotated;
                } else if (currentPiece.shape[0].length > 2 && isValidMove(rotated, currentPiece.x - 2, currentPiece.y)) { 
                    currentPiece.x -= 2; currentPiece.shape = rotated;
                } else if (currentPiece.shape[0].length > 2 && isValidMove(rotated, currentPiece.x + 2, currentPiece.y)) { 
                    currentPiece.x += 2; currentPiece.shape = rotated;
                }
            }
        }

        function pieceDrop(isHardDrop = false) {
            if (!gameRunning || gamePausedForMessage || !currentPiece) return;
            if (isHardDrop) {
                let moved = 0;
                while (isValidMove(currentPiece.shape, currentPiece.x, currentPiece.y + 1)) {
                    currentPiece.y++;
                    moved++;
                }
                if (moved > 0) score += Math.min(moved, 5); // Punti per hard drop, max 5 per evitare farming
                solidifyPiece(); 
            } else { 
                if (isValidMove(currentPiece.shape, currentPiece.x, currentPiece.y + 1)) {
                    currentPiece.y++;
                } else {
                    solidifyPiece();
                }
            }
            dropCounter = 0; 
            updateUI();
        }

        function isValidMove(shape, x, y) {
            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[r].length; c++) {
                    if (shape[r][c] !== 0) { 
                        let newX = x + c;
                        let newY = y + r;
                        if (newX < 0 || newX >= COLS || newY >= ROWS || (newY >= 0 && board[newY][newX] !== 0) ) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        function solidifyPiece() {
            if(!currentPiece) return; // Sicurezza
            currentPiece.shape.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        // Verifica se il pezzo è sopra la cima (game over)
                        if (currentPiece.y + y < 0) { 
                            handleGameOverCondition(); 
                            return; // Esce dal loop forEach se game over
                        }
                        board[currentPiece.y + y][currentPiece.x + x] = currentPiece.colorIndex;
                    }
                });
            });

            if (!gameRunning) return; // Se handleGameOverCondition ha settato gameRunning a false

            clearLines();
            
            currentPiece = nextPiece;
            nextPiece = getRandomPiece();
            drawNextPiece(); // << AGGIORNAMENTO ESPLICITO DELL'ANTEPRIMA

            if (currentPiece && !isValidMove(currentPiece.shape, currentPiece.x, currentPiece.y)) {
                handleGameOverCondition(); 
            }
        }
        
        function handleGameOverCondition() {
            gameRunning = false;
            lives--;
            updateUI();
            if (lives > 0) {
                showMessage(`Polenta bruciata! Vite: ${lives}`, true);
            } else {
                showMessage(`Game Over! Formaggio finito! Punteggio: ${score}`, true);
            }
        }
        
        function resetBoard() { 
            hideMessage();
            gamePausedForMessage = false;
            board = createBoard();
            currentPiece = getRandomPiece(); // Prende il primo pezzo
            nextPiece = getRandomPiece();    // Prepara il successivo
            drawNextPiece();                 // Disegna il successivo
            dropCounter = 0;
            lastTime = performance.now();
            gameRunning = true;
            if (animationFrameId) cancelAnimationFrame(animationFrameId); // Cancella vecchio loop se esiste
            gameLoop();
        }


        function clearLines() {
            let linesCleared = 0;
            for (let r = ROWS - 1; r >= 0; r--) {
                if (board[r].every(cell => cell !== 0)) {
                    linesCleared++;
                    board.splice(r, 1); 
                    board.unshift(Array(COLS).fill(0)); 
                    r++; 
                }
            }
            if (linesCleared > 0) {
                if (linesCleared === 1) score += 40 * level;
                else if (linesCleared === 2) score += 100 * level;
                else if (linesCleared === 3) score += 300 * level;
                else if (linesCleared >= 4) score += 1200 * level; 
                
                let newLevel = Math.floor(score / 800) + 1; // Aumenta livello ogni 800 punti
                if (newLevel > level) {
                    level = newLevel;
                    dropInterval = Math.max(150, initialDropInterval - (level -1) * levelSpeedIncrease); 
                }
            }
        }
        
        function showMessage(text, showRestartBtn = true) {
            messageText.textContent = text;
            restartButton.style.display = showRestartBtn ? 'inline-block' : 'none';
            messageOverlay.style.display = 'flex';
            gamePausedForMessage = true;
        }

        function hideMessage() {
            messageOverlay.style.display = 'none';
        }


        function updateUI() {
            scoreDisplay.textContent = `Score: ${score}`;
            livesDisplay.textContent = `Vite: ${lives}`;
            levelDisplay.textContent = `Livello: ${level}`;
        }

        let lastTime = 0;
        let animationFrameId = null; // Per poter cancellare il loop
        function gameLoop(time = 0) {
            if (gamePausedForMessage) {
                animationFrameId = requestAnimationFrame(gameLoop); 
                return;
            }
            if (!gameRunning) {
                 if (animationFrameId) cancelAnimationFrame(animationFrameId);
                 animationFrameId = null;
                return;
            }

            update(); 
            
            clearCanvas();
            drawBoard();
            if(currentPiece) {
                drawGhostPiece();
                drawPiece(currentPiece); // Usa i parametri di default per il canvas principale
            }
            
            lastTime = time;
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function initGame() {
            hideMessage();
            gamePausedForMessage = false;
            board = createBoard();
            score = 0;
            lives = initialLives;
            level = 1;
            dropInterval = initialDropInterval;
            currentPiece = getRandomPiece();
            nextPiece = getRandomPiece();
            drawNextPiece(); // << CHIAMATA ESPLICITA ALL'INIZIO
            updateUI();
            dropCounter = 0;
            gameRunning = true;
            lastTime = performance.now(); 
            if (animationFrameId) cancelAnimationFrame(animationFrameId); // Cancella vecchio loop
            gameLoop();
        }
        
        document.addEventListener('keydown', event => {
            if (!gameRunning || gamePausedForMessage || !currentPiece) return; // Aggiunto !currentPiece
            if (event.key === 'ArrowLeft' || event.key === 'a') pieceMove(-1);
            else if (event.key === 'ArrowRight' || event.key === 'd') pieceMove(1);
            else if (event.key === 'ArrowDown' || event.key === 's') pieceDrop(); 
            else if (event.key === 'ArrowUp' || event.key === 'w' || event.key === 'x') pieceRotate(); 
            else if (event.key === ' ') { 
                 event.preventDefault(); 
                 pieceDrop(true);
            }
        });

        document.getElementById('left-btn').addEventListener('click', () => pieceMove(-1));
        document.getElementById('right-btn').addEventListener('click', () => pieceMove(1));
        document.getElementById('down-btn').addEventListener('click', () => pieceDrop()); 
        document.getElementById('up-btn').addEventListener('click', () => pieceRotate()); 
        document.getElementById('drop-btn').addEventListener('click', () => pieceDrop(true)); 
        
        restartButton.addEventListener('click', () => {
            if (lives > 0 && !gameRunning) { 
                resetBoard(); 
            } else if (lives <= 0) { 
                initGame(); 
            }
        });

        initGame();
    </script>
</body>
</html>
