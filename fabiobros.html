<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Super Fabio bros</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #333;
            font-family: 'Arial', sans-serif;
            color: white;
            overflow: hidden; /* Evita scrollbar indesiderate */
        }
        #gameContainer {
            position: relative; /* Per posizionare pulsanti HTML sopra/sotto */
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        canvas {
            border: 2px solid #000;
            background-color: #70c5ce; /* Colore cielo di default */
            max-width: 100%;
            max-height: calc(100vh - 150px); /* Lascia spazio per UI e controlli */
            aspect-ratio: 16 / 9; /* Mantiene le proporzioni */
            display: block; /* Aiuta con alcuni problemi di layout/spazio extra */
        }
        #ui {
            display: flex;
            justify-content: space-around;
            width: 100%;
            max-width: 800px; /* Stessa larghezza max del canvas se impostata */
            padding: 10px 0;
            font-size: 1.2em;
            background-color: rgba(0,0,0,0.5);
            border-radius: 0 0 10px 10px;
        }
        .ui-element {
            margin: 0 10px;
        }
        #touchControls {
            display: none; /* Nascosti di default, mostrati via JS per mobile */
            justify-content: space-around;
            width: 100%;
            max-width: 400px;
            margin-top: 15px;
            padding: 10px;
            background-color: rgba(0,0,0,0.3);
            border-radius: 10px;
        }
        .touch-button {
            background-color: #555;
            color: white;
            border: 2px solid #ddd;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        .touch-button:active {
            background-color: #777;
        }
        #homeButtonContainer {
            margin-top: 20px;
        }
        #homeButton {
            padding: 10px 20px;
            font-size: 1em;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            text-decoration: none;
            cursor: pointer;
        }
        #homeButton:hover {
            background-color: #0056b3;
        }

        .overlay-button {
            position: absolute;
            padding: 15px 30px;
            font-size: 1.5em;
            background-color: #4CAF50;
            color: white;
            border: 2px solid #3e8e41;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            z-index: 100;
            display: none; /* Nascosti di default, mostrati da JS */
        }
        .overlay-button:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="ui">
            <div id="lives" class="ui-element">Vite: 5</div>
            <div id="score" class="ui-element">Punteggio: 0</div>
            <div id="powerUpTimer" class="ui-element"></div>
        </div>
        <div id="touchControls">
            <button id="leftButton" class="touch-button">‚óÄÔ∏è</button>
            <button id="jumpButton" class="touch-button">üîº</button>
            <button id="rightButton" class="touch-button">‚ñ∂Ô∏è</button>
            <button id="shootButton" class="touch-button" style="display:none;">üî•</button>
        </div>

        <button id="startButton" class="overlay-button">Inizia Gioco</button>
        <button id="retryButton" class="overlay-button">Riprova</button>
        <button id="playAgainButton" class="overlay-button">Gioca Ancora</button>
        <button id="nextLevelButton" class="overlay-button">Prossimo Livello</button>
    </div>

    <div id="homeButtonContainer">
        <a href="index.html" id="homeButton">Torna alla Home</a>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('gameContainer'); // Riferimento al contenitore

        const livesDisplay = document.getElementById('lives');
        const scoreDisplay = document.getElementById('score');
        const powerUpTimerDisplay = document.getElementById('powerUpTimer');

        const startButton = document.getElementById('startButton');
        const retryButton = document.getElementById('retryButton');
        const playAgainButton = document.getElementById('playAgainButton');
        const nextLevelButton = document.getElementById('nextLevelButton');

        const touchControlsDiv = document.getElementById('touchControls');
        const leftButton = document.getElementById('leftButton');
        const rightButton = document.getElementById('rightButton');
        const jumpButton = document.getElementById('jumpButton');
        const shootButton = document.getElementById('shootButton');

        // <<< AGGIUNTA MUSICA: Inizializzazione dell'oggetto Audio >>>
        const backgroundMusic = new Audio('fabiosong.mp3');
        backgroundMusic.loop = true; // Per far ripetere la musica
        backgroundMusic.onerror = () => {
            console.error("Errore nel caricamento del file audio: fabiosong.mp3. Assicurati che il file sia presente nella stessa cartella dell'HTML o che il percorso sia corretto.");
        };
        // <<< FINE AGGIUNTA MUSICA >>>

        let gameWidth = 800;
        let gameHeight = 450;
        canvas.width = gameWidth;
        canvas.height = gameHeight;

        // Pulsanti overlay
        function positionOverlayButton(button, topFactor = 0.75) {
            button.style.display = 'block'; // Assicura che sia visibile per misurazione

            const canvasRect = canvas.getBoundingClientRect();
            const gameContainerRect = gameContainer.getBoundingClientRect();

            // Posizione del canvas RELATIVA al gameContainer
            const canvasTopInContainer = canvasRect.top - gameContainerRect.top;
            const canvasLeftInContainer = canvasRect.left - gameContainerRect.left;

            const buttonLeft = canvasLeftInContainer + (canvasRect.width / 2) - (button.offsetWidth / 2);
            const buttonTop = canvasTopInContainer + (canvasRect.height * topFactor) - (button.offsetHeight / 2);

            button.style.left = `${buttonLeft}px`;
            button.style.top = `${buttonTop}px`;
        }

        function hideOverlayButtons() {
            startButton.style.display = 'none';
            retryButton.style.display = 'none';
            playAgainButton.style.display = 'none';
            nextLevelButton.style.display = 'none';
        }

        window.addEventListener('resize', () => {
            // Ricalcola gameWidth e gameHeight in base alla dimensione effettiva del canvas
            const canvasStyle = window.getComputedStyle(canvas);
            const actualCanvasWidth = parseInt(canvasStyle.width, 10);
            const actualCanvasHeight = parseInt(canvasStyle.height, 10);

            // Se le dimensioni del canvas sono cambiate significativamente (es. per rotazione schermo)
            // Potrebbe essere necessario aggiornare gameWidth/Height e ridisegnare
            // Per ora, ci limitiamo a riposizionare i pulsanti
            // gameWidth = actualCanvasWidth; // Queste linee potrebbero essere necessarie se il layout del gioco
            // gameHeight = actualCanvasHeight; // dovesse adattarsi dinamicamente alle dimensioni reali del canvas
            // canvas.width = gameWidth;       // e non solo all'aspect ratio.
            // canvas.height = gameHeight;

            if (startButton.style.display === 'block') positionOverlayButton(startButton, 0.70); // Aggiornato topFactor
            if (retryButton.style.display === 'block') positionOverlayButton(retryButton, 0.75);
            if (playAgainButton.style.display === 'block') positionOverlayButton(playAgainButton, 0.75);
            if (nextLevelButton.style.display === 'block') positionOverlayButton(nextLevelButton, 0.75);
        });


        const images = {};
        const imageSources = {
            player: 'fabiogame2.PNG',
            enemy: 'mostro.PNG',
            background: 'fabiogame.PNG'
        };
        let imagesLoaded = 0;
        let totalImages = Object.keys(imageSources).length;

        function loadImages(callback) {
            for (let key in imageSources) {
                images[key] = new Image();
                images[key].src = imageSources[key];
                images[key].onload = () => {
                    imagesLoaded++;
                    if (imagesLoaded === totalImages) {
                        callback();
                    }
                };
                images[key].onerror = () => {
                    console.error(`Errore caricamento immagine: ${imageSources[key]}`);
                    imagesLoaded++; // Incrementa comunque per non bloccare il caricamento
                    if (imagesLoaded === totalImages) {
                        callback(); // Chiama il callback anche se un'immagine fallisce, per evitare stallo
                    }
                }
            }
        }

        let player;
        let platforms = [];
        let enemies = [];
        let collectibles = [];
        let projectiles = [];
        let powerUpCollectible = null;

        let score = 0;
        let lives = 5;
        let currentLevel = 0;
        let gameState = 'LOADING';

        const gravity = 0.8;
        const groundFriction = 0.8;

        let powerUpActive = false;
        let powerUpDuration = 15000;
        let powerUpTimer = 0;
        let enemiesKilledForPowerUp = 0;
        const powerUpSpawnThreshold = 6;

        let boss = null;
        const bossMaxHealth = 10;

        const PLAYER_DEFAULT_HEIGHT = 60; // Altezza di riferimento per il player sprite

        const levels = [
            { // Livello 1: Cielo
                scoreToAdvance: 1000,
                bgColor: '#70c5ce',
                themeName: "Cielo Sereno",
                playerStartX: 60,
                playerStartPlatformTopY: gameHeight - 120,
                platforms: [
                    { x: 0, y: gameHeight - 40, width: gameWidth, height: 40, color: '#8FBC8F' },
                    { x: 30, y: gameHeight - 120, width: 100, height: 20, color: '#A0522D' },
                    { x: 200, y: gameHeight - 140, width: 150, height: 20, color: '#A0522D' },
                    { x: 400, y: gameHeight - 200, width: 200, height: 20, color: '#A0522D' },
                    { x: 650, y: gameHeight - 100, width: 100, height: 20, color: '#A0522D' }
                ],
                enemies: [ { x: 300, y: gameHeight - 80 }, { x: 500, y: gameHeight - 80 } ],
                collectibles: [
                    { x: 230, y: gameHeight - 180 }, { x: 270, y: gameHeight - 180 },
                    { x: 450, y: gameHeight - 240 }, { x: 490, y: gameHeight - 240 },
                    { x: 680, y: gameHeight - 140 }, { x: 150, y: gameHeight - 80 },
                    { x: 550, y: gameHeight - 80 }, { x: 350, y: gameHeight - 80 },
                    { x: 750, y: gameHeight - 80 }, { x: 400, y: gameHeight - 80 }
                ]
            },
            { // Livello 2: Deserto
                scoreToAdvance: 2000,
                bgColor: '#F4A460',
                themeName: "Deserto Infuocato",
                playerStartX: 60,
                playerStartPlatformTopY: gameHeight - 150,
                platforms: [
                    { x: 0, y: gameHeight - 40, width: gameWidth, height: 40, color: '#D2B48C' },
                    { x: 30, y: gameHeight - 150, width: 100, height: 20, color: '#CD853F' },
                    { x: 200, y: gameHeight - 120, width: 100, height: 20, color: '#CD853F' },
                    { x: 300, y: gameHeight - 180, width: 200, height: 20, color: '#CD853F' },
                    { x: 550, y: gameHeight - 100, width: 150, height: 20, color: '#CD853F' },
                    { x: 200, y: gameHeight - 280, width: 150, height: 20, color: '#CD853F' },
                ],
                enemies: [
                    { x: 250, y: gameHeight - 80 }, { x: 450, y: gameHeight - 80 },
                    { x: 600, y: gameHeight - 80 }, { x: 350, y: gameHeight - 220 }
                ],
                collectibles: [
                    { x: 220, y: gameHeight - 160 }, { x: 330, y: gameHeight - 220 },
                    { x: 580, y: gameHeight - 140 }, { x: 230, y: gameHeight - 320 },
                    { x: 150, y: gameHeight - 80 }, { x: 350, y: gameHeight - 80 },
                    { x: 400, y: gameHeight - 80 }, { x: 650, y: gameHeight - 80 },
                    { x: 750, y: gameHeight - 80 }
                ]
            },
            { // Livello 3: Foresta (Inizio Power-up)
                scoreToAdvance: 3000,
                bgColor: '#228B22',
                themeName: "Foresta Omrbosa",
                powerUpEnabled: true,
                playerStartX: 70,
                playerStartPlatformTopY: gameHeight - 150,
                platforms: [
                    { x: 0, y: gameHeight - 40, width: gameWidth, height: 40, color: '#556B2F' },
                    { x: 50, y: gameHeight - 150, width: 150, height: 20, color: '#8B4513' },
                    { x: 250, y: gameHeight - 220, width: 100, height: 20, color: '#8B4513' },
                    { x: 400, y: gameHeight - 120, width: 200, height: 20, color: '#8B4513' },
                    { x: 650, y: gameHeight - 250, width: 120, height: 20, color: '#8B4513' }
                ],
                enemies: [
                    { x: 250, y: gameHeight - 80 },
                    { x: 350, y: gameHeight - 80 },
                    { x: 500, y: gameHeight - 80 }, { x: 700, y: gameHeight - 80 },
                    { x: 280, y: gameHeight - 260 },
                    { x: 450, y: gameHeight - 160 }
                ],
                collectibles: Array.from({length: 15}, (_, i) => ({ x: 50 + i * 50, y: gameHeight - 80 - (i%3 * 50) }))
            },
            { // Livello 4: Citt√†
                scoreToAdvance: 4000,
                bgColor: '#778899',
                themeName: "Metropoli Grigia",
                powerUpEnabled: true,
                playerStartX: 40,
                playerStartPlatformTopY: gameHeight - 180,
                platforms: [
                    { x: 0, y: gameHeight - 40, width: gameWidth, height: 40, color: '#A9A9A9' },
                    { x: 0, y: gameHeight - 180, width: 150, height: 20, color: '#696969' },
                    { x: gameWidth - 150, y: gameHeight - 180, width: 150, height: 20, color: '#696969' },
                    { x: 200, y: gameHeight - 120, width: 100, height: 20, color: '#696969' },
                    { x: 350, y: gameHeight - 250, width: 100, height: 20, color: '#696969' },
                    { x: 500, y: gameHeight - 120, width: 100, height: 20, color: '#696969' }
                ],
                enemies: [
                    { x: 250, y: gameHeight - 80 },
                    { x: 350, y: gameHeight - 80 },
                    { x: 420, y: gameHeight - 80 }, { x: 600, y: gameHeight - 80 },
                    { x: 720, y: gameHeight - 80 },
                    { x: gameWidth - 100, y: gameHeight - 220 },
                    { x: 400, y: gameHeight - 290 }
                ],
                collectibles: Array.from({length: 20}, (_, i) => ({ x: 30 + i * 40, y: gameHeight - 80 - (i%4 * 40) }))
            },
            { // Livello 5: Castello (Boss)
                scoreToAdvance: Infinity,
                bgColor: '#483D8B',
                themeName: "Castello Oscuro",
                powerUpEnabled: true,
                isBossLevel: true,
                playerStartX: 120,
                playerStartPlatformTopY: gameHeight - 150,
                platforms: [
                    { x: 0, y: gameHeight - 40, width: gameWidth, height: 40, color: '#2F4F4F' },
                    { x: 100, y: gameHeight - 150, width: 150, height: 20, color: '#708090' },
                    { x: gameWidth - 250, y: gameHeight - 150, width: 150, height: 20, color: '#708090' },
                    { x: gameWidth/2 - 75, y: gameHeight - 250, width: 150, height: 20, color: '#708090' }
                ],
                enemies: [
                    { x: 200, y: gameHeight - 80 },
                    { x: gameWidth - 200, y: gameHeight - 80 }
                ],
                bossData: { x: gameWidth / 2 - 50, y: gameHeight - 120, health: bossMaxHealth },
                collectibles: Array.from({length: 10}, (_, i) => ({ x: 50 + i * 70, y: gameHeight - 80 - (i%2 * 60) }))
            }
        ];

        class Player {
            constructor(x, y) {
                this.width = 40;
                this.height = PLAYER_DEFAULT_HEIGHT;
                this.x = x;
                this.y = y;
                this.dx = 0;
                this.dy = 0;
                this.speed = 5;
                this.jumpForce = 15;
                this.isJumping = false;
                this.onGround = false;
                this.image = images.player;
                this.shootCooldown = 0;
                this.shootDelay = 300;
                this.lastDirection = 'right';
            }

            jump() {
                if (this.onGround) {
                    this.dy = -this.jumpForce;
                    this.isJumping = true;
                    this.onGround = false;
                }
            }

            shoot() {
                if (powerUpActive && this.shootCooldown <= 0) {
                    const projectileType = Math.random() < 0.5 ? 'üç¥' : 'üî™';
                    const projectileSpeed = 8;
                    let dir = (this.lastDirection === 'left') ? -1 : 1;

                    projectiles.push(new Projectile(this.x + this.width / 2, this.y + this.height / 2, projectileType, dir * projectileSpeed));
                    this.shootCooldown = this.shootDelay;
                }
            }

            update(deltaTime) {
                if (keys.ArrowLeft || keys.KeyA || touchLeft) {
                    this.dx = -this.speed;
                    this.lastDirection = 'left';
                } else if (keys.ArrowRight || keys.KeyD || touchRight) {
                    this.dx = this.speed;
                    this.lastDirection = 'right';
                } else {
                    this.dx *= groundFriction;
                }

                this.dy += gravity;
                this.y += this.dy;
                this.x += this.dx;

                if (this.x < 0) this.x = 0;
                if (this.x + this.width > gameWidth) this.x = gameWidth - this.width;

                if (this.y > gameHeight) { // Se il giocatore cade fuori dallo schermo
                    loseLife();
                }

                if (this.shootCooldown > 0) {
                    this.shootCooldown -= deltaTime;
                }
            }

            draw() {
                if (this.image && this.image.complete && this.image.naturalWidth !== 0) {
                    ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
                } else {
                    ctx.fillStyle = 'blue';
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                }
            }
        }

        class Platform {
            constructor(x, y, width, height, color) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.color = color;
            }
            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }
        }

        class Enemy {
            constructor(x, y, isBoss = false, health = 1) {
                this.isBoss = isBoss;
                this.width = isBoss ? 100 : 40;
                this.height = isBoss ? 100 : 40;
                this.x = x;
                this.y = y - (this.height - 40); // Allinea la base del nemico con y (se hanno altezze diverse dal riferimento 40)
                this.dx = (Math.random() < 0.5 ? 1 : -1) * (isBoss ? 1 : 2);
                this.image = images.enemy;
                this.health = health;
                this.maxHealth = health;
            }
            update() {
                this.x += this.dx;
                if (this.x < 0 || this.x + this.width > gameWidth) {
                    this.dx *= -1;
                }
                // Logica per non cadere dalle piattaforme (semplificata)
                let onPlatform = false;
                for (const platform of platforms) {
                    // Controlla se il nemico √® sopra una piattaforma
                    if (this.x + this.width > platform.x && this.x < platform.x + platform.width &&
                        this.y + this.height >= platform.y && this.y + this.height <= platform.y + platform.height + 5) { // +5 per tolleranza
                        onPlatform = true;
                        // Controlla se c'√® terreno davanti
                        const lookAheadX = this.x + (this.dx > 0 ? this.width + 5 : -5); // Guarda un po' avanti
                        let groundAhead = false;
                        for (const p of platforms) { // Controlla su tutte le piattaforme
                            if (lookAheadX + (this.dx > 0 ? 0 : this.width) > p.x && lookAheadX + (this.dx > 0 ? 0 : this.width) < p.x + p.width &&
                                this.y + this.height >= p.y && this.y + this.height <= p.y + p.height + 5) {
                                groundAhead = true;
                                break;
                            }
                        }
                        if (!groundAhead && onPlatform) { // Se √® su una piattaforma ma non c'√® terreno davanti
                             this.dx *= -1; // Inverte la direzione
                        }
                        break; // Trovata la piattaforma su cui √®, non serve controllare le altre per questo
                    }
                }
            }
            draw() {
                if (this.image && this.image.complete && this.image.naturalWidth !== 0) {
                    ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
                } else {
                    ctx.fillStyle = 'red';
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                }
                if (this.isBoss && this.health < this.maxHealth) {
                    const barWidth = this.width; const barHeight = 10;
                    const barX = this.x; const barY = this.y - barHeight - 5;
                    ctx.fillStyle = '#555'; ctx.fillRect(barX, barY, barWidth, barHeight);
                    ctx.fillStyle = 'green'; ctx.fillRect(barX, barY, barWidth * (this.health / this.maxHealth), barHeight);
                }
            }
            takeDamage(amount) {
                this.health -= amount;
                return this.health <= 0;
            }
        }

        class Collectible {
            constructor(x, y) {
                this.x = x; this.y = y; this.width = 30; this.height = 30;
                this.emoji = 'ü•ó'; this.fontSize = 30;
            }
            draw() {
                ctx.font = `${this.fontSize}px Arial`; ctx.textAlign = "center";
                ctx.fillText(this.emoji, this.x + this.width/2, this.y + this.height - 5); // Aggiustato per centrare meglio l'emoji
            }
        }

        class PowerUpCollectible {
            constructor(x, y) {
                this.x = x; this.y = y; this.width = 40; this.height = 40;
                this.emoji = 'üç≤'; this.fontSize = 40;
            }
            draw() {
                ctx.font = `${this.fontSize}px Arial`; ctx.textAlign = "center";
                ctx.fillText(this.emoji, this.x + this.width/2, this.y + this.height - 5); // Aggiustato
            }
        }

        class Projectile {
            constructor(x, y, type, dx) {
                this.x = x; this.y = y; this.width = 20; this.height = 20;
                this.emoji = type; this.fontSize = 20; this.dx = dx;
            }
            update() { this.x += this.dx; }
            draw() {
                ctx.font = `${this.fontSize}px Arial`; ctx.textAlign = "center";
                ctx.fillText(this.emoji, this.x + this.width/2, this.y + this.height/2 + 5); // Aggiustato per centrare meglio
            }
        }

        const keys = {};
        let touchLeft = false, touchRight = false;

        window.addEventListener('keydown', (e) => { keys[e.code] = true; });
        window.addEventListener('keyup', (e) => { keys[e.code] = false; });

        function handleJumpPress() { if (gameState === 'PLAYING') player.jump(); }
        function handleShootPress() { if (gameState === 'PLAYING' && powerUpActive) player.shoot(); }

        // Gestione input da tastiera
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') { e.preventDefault(); handleJumpPress(); }
            if (e.code === 'KeyX' || e.code === 'ControlLeft') { e.preventDefault(); handleShootPress(); }
        });

        // Setup controlli touch
        function setupTouchControls() {
            if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
                touchControlsDiv.style.display = 'flex'; // Mostra i controlli touch
                leftButton.addEventListener('touchstart', (e) => { e.preventDefault(); touchLeft = true; });
                leftButton.addEventListener('touchend', (e) => { e.preventDefault(); touchLeft = false; });
                rightButton.addEventListener('touchstart', (e) => { e.preventDefault(); touchRight = true; });
                rightButton.addEventListener('touchend', (e) => { e.preventDefault(); touchRight = false; });
                jumpButton.addEventListener('touchstart', (e) => { e.preventDefault(); handleJumpPress(); });
                shootButton.addEventListener('touchstart', (e) => { e.preventDefault(); handleShootPress(); });
            }
        }
        setupTouchControls(); // Chiama la funzione per attivare i controlli touch se disponibili

        // Funzione di collisione AABB
        function AABB(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width && rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height && rect1.y + rect1.height > rect2.y;
        }

        function handleCollisions() {
            player.onGround = false; // Resetta lo stato onGround all'inizio di ogni frame
            // Collisioni con le piattaforme
            for (const platform of platforms) {
                if (AABB(player, platform)) {
                    // Collisione dall'alto (atterraggio)
                    if (player.dy > 0 && player.y + player.height - player.dy <= platform.y) { // player.dy vecchio per confronto
                        player.y = platform.y - player.height;
                        player.dy = 0;
                        player.onGround = true;
                        player.isJumping = false;
                    }
                    // Collisione laterale da destra verso sinistra
                    else if (player.dx > 0 && player.x + player.width - player.dx <= platform.x) {
                        player.x = platform.x - player.width;
                        player.dx = 0;
                    }
                    // Collisione laterale da sinistra verso destra
                    else if (player.dx < 0 && player.x - player.dx >= platform.x + platform.width) {
                        player.x = platform.x + platform.width;
                        player.dx = 0;
                    }
                    // Collisione dal basso (colpisce la piattaforma con la testa)
                    else if (player.dy < 0 && player.y - player.dy >= platform.y + platform.height) {
                        player.y = platform.y + platform.height;
                        player.dy = 0; // Ferma il movimento verticale
                    }
                }
            }

            // Collisioni con i collezionabili
            for (let i = collectibles.length - 1; i >= 0; i--) {
                if (AABB(player, collectibles[i])) {
                    collectibles.splice(i, 1); // Rimuove il collezionabile
                    score += 100;
                    updateUI();
                }
            }

            // Collisione con il PowerUpCollectible
            if (powerUpCollectible && AABB(player, powerUpCollectible)) {
                activatePowerUp();
                powerUpCollectible = null; // Rimuove il power-up dalla mappa
            }

            // Collisioni con i nemici
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                if (AABB(player, enemy)) {
                    // Se il giocatore salta sopra il nemico
                    if (player.dy > 0 && (player.y + player.height - player.dy) <= enemy.y + enemy.height / 2) { // Controlla se il piede del giocatore √® sopra la met√† superiore del nemico
                        enemies.splice(i, 1); // Rimuove il nemico
                        score += 200;
                        player.dy = -player.jumpForce / 2; // Piccolo balzo
                        enemiesKilledForPowerUp++;
                        checkSpawnPowerUp();
                    } else { // Altrimenti, il giocatore viene colpito
                        loseLife();
                    }
                    updateUI();
                }
            }
             // Collisione con il Boss
            if (boss && AABB(player, boss)) {
                if (player.dy > 0 && (player.y + player.height - player.dy) <= boss.y + boss.height / 2) { // Salto sul boss
                    if (boss.takeDamage(1)) { // Il boss prende 1 danno
                        defeatBoss();
                    } else {
                        player.dy = -player.jumpForce / 1.5; // Balzo pi√π alto dal boss
                    }
                } else { // Collisione laterale o dal basso con il boss
                    loseLife();
                }
            }

            // Collisioni dei proiettili
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];
                let projectileHit = false; // Flag per indicare se il proiettile ha colpito qualcosa

                // Contro i nemici normali
                for (let j = enemies.length - 1; j >= 0; j--) {
                    if (AABB(proj, enemies[j])) {
                        enemies.splice(j, 1); // Rimuove il nemico
                        projectiles.splice(i, 1); // Rimuove il proiettile
                        projectileHit = true;
                        score += 250; // Punteggio extra per uccisione con proiettile
                        enemiesKilledForPowerUp++;
                        checkSpawnPowerUp();
                        break; // Esce dal ciclo dei nemici, il proiettile √® sparito
                    }
                }
                if (projectileHit) continue; // Se il proiettile ha colpito un nemico, passa al prossimo proiettile

                // Contro il Boss
                if (boss && AABB(proj, boss)) {
                     if (boss.takeDamage(0.2)) { // Il boss prende meno danno dai proiettili
                        defeatBoss();
                    }
                    projectiles.splice(i, 1); // Rimuove il proiettile
                    // Non impostare projectileHit a true qui, per permettere di controllare uscita schermo
                }

                // Rimuovi proiettili fuori schermo
                if (proj.x < 0 || proj.x > gameWidth) {
                    projectiles.splice(i, 1);
                }
            }
        }

        function defeatBoss() {
            score += 5000; // Punteggio bonus per aver sconfitto il boss
            boss = null; enemies = []; // Rimuovi boss e altri nemici
            updateUI();
            gameState = 'VICTORY';
            setTimeout(() => positionOverlayButton(playAgainButton, 0.75), 0); // Mostra il pulsante per giocare ancora
        }

        function loseLife() {
            lives--;
            updateUI();
            if (lives <= 0) {
                gameState = 'GAME_OVER';
                setTimeout(() => positionOverlayButton(retryButton, 0.75), 0);
            } else {
                // Resetta la posizione del giocatore all'inizio del livello corrente
                const levelData = levels[currentLevel];
                player.x = levelData.playerStartX;
                player.y = levelData.playerStartPlatformTopY - player.height; // Posiziona sopra la piattaforma di partenza
                player.dx = 0; player.dy = 0;
            }
        }

        function updateUI() {
            livesDisplay.textContent = `Vite: ${lives}`;
            scoreDisplay.textContent = `Punteggio: ${score}`;
            if (powerUpActive) {
                powerUpTimerDisplay.textContent = `Chef Furioso: ${Math.ceil(powerUpTimer / 1000)}s`;
                // Mostra il pulsante di sparo solo se il power-up √® attivo e se il livello lo permette (es. livello 3+)
                if (currentLevel >= 2 && ('ontouchstart' in window || navigator.maxTouchPoints > 0)) { // Livello 3 √® indice 2
                    shootButton.style.display = 'flex';
                }
            } else {
                powerUpTimerDisplay.textContent = '';
                shootButton.style.display = 'none';
            }
        }

        function activatePowerUp() {
            powerUpActive = true;
            powerUpTimer = powerUpDuration;
            enemiesKilledForPowerUp = 0; // Resetta il contatore per il prossimo power-up
            updateUI();
        }

        function checkSpawnPowerUp() {
            const levelData = levels[currentLevel];
            // Controlla se il power-up √® abilitato per il livello, non √® gi√† attivo, non c'√® gi√† un power-up da raccogliere
            // e il giocatore ha ucciso abbastanza nemici
            if (levelData.powerUpEnabled && !powerUpActive && !powerUpCollectible && enemiesKilledForPowerUp >= powerUpSpawnThreshold) {
                let spawnX, spawnY;
                // Cerca di spawnare su una piattaforma esistente (non quella base)
                if (platforms.length > 1) { // Assicurati ci siano piattaforme oltre quella base
                    // Scegli una piattaforma a caso, escludendo la prima (di solito il terreno)
                    const p = platforms[Math.floor(Math.random() * (platforms.length -1)) + 1];
                    spawnX = p.x + p.width / 2 - 20; // Centra il power-up sulla piattaforma
                    spawnY = p.y - 50; // Posiziona sopra la piattaforma
                } else { // Fallback se ci sono poche piattaforme
                    spawnX = gameWidth / 2;
                    spawnY = gameHeight - 150;
                }
                powerUpCollectible = new PowerUpCollectible(spawnX, spawnY);
                enemiesKilledForPowerUp = 0; // Resetta il contatore
            }
        }

        function loadLevel(levelIndex) {
            if (levelIndex >= levels.length) { // Se si supera l'ultimo livello
                gameState = 'VICTORY';
                setTimeout(() => positionOverlayButton(playAgainButton, 0.75), 0);
                return;
            }
            currentLevel = levelIndex;
            const levelData = levels[currentLevel];

            player = new Player(levelData.playerStartX, levelData.playerStartPlatformTopY - PLAYER_DEFAULT_HEIGHT); // Usa costante per altezza

            platforms = levelData.platforms.map(p => new Platform(p.x, p.y, p.width, p.height, p.color));
            enemies = levelData.enemies.map(e => new Enemy(e.x, e.y));
            collectibles = levelData.collectibles.map(c => new Collectible(c.x, c.y));
            projectiles = []; // Resetta i proiettili
            powerUpCollectible = null; // Resetta il power-up
            enemiesKilledForPowerUp = 0; // Resetta contatore uccisioni per power-up

            if (levelData.isBossLevel && levelData.bossData) {
                boss = new Enemy(levelData.bossData.x, levelData.bossData.y, true, levelData.bossData.health);
            } else {
                boss = null;
            }

            canvas.style.backgroundColor = levelData.bgColor;
            updateUI();
            hideOverlayButtons();
            gameState = 'PLAYING';
        }

        function resetGame() {
            lives = 5;
            score = 0;
            powerUpActive = false;
            powerUpTimer = 0;
            currentLevel = 0; // Inizia dal primo livello
            loadLevel(currentLevel);
        }

        let lastTime = 0;
        // Variabili per l'animazione degli sprite nella schermata titolo (posizioni iniziali)
        let titleFabioX = gameWidth * 0.1, titleFabioDir = 1; // Adattato a gameWidth
        let titleEnemyX = gameWidth * 0.8, titleEnemyDir = -1; // Adattato a gameWidth


        function gameLoop(timestamp) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            ctx.clearRect(0, 0, gameWidth, gameHeight);

            if (gameState === 'LOADING') {
                ctx.fillStyle = 'black'; ctx.fillRect(0,0,gameWidth, gameHeight);
                ctx.fillStyle = 'white'; ctx.font = '30px Arial';
                ctx.textAlign = 'center'; ctx.fillText('Caricamento Risorse...', gameWidth / 2, gameHeight / 2);
            } else if (gameState === 'TITLE') {
                // ======== INIZIO SEZIONE MODIFICATA PER TITLE SCREEN ========

                // 1. Riempire lo sfondo del canvas con un colore cielo
                ctx.fillStyle = '#70c5ce'; // Colore cielo di base
                ctx.fillRect(0, 0, gameWidth, gameHeight);

                // 2. Disegnare l'immagine di sfondo (personaggio principale) abbassata e scalata
                const bgImg = images.background;
                if (bgImg && bgImg.complete && bgImg.naturalWidth !== 0) {
                    const aspectRatio = bgImg.naturalWidth / bgImg.naturalHeight;
                    let drawWidth = gameWidth;
                    let drawHeight = drawWidth / aspectRatio;

                    if (drawHeight > gameHeight) {
                        drawHeight = gameHeight;
                        drawWidth = drawHeight * aspectRatio;
                    }
                    
                    const drawX = (gameWidth - drawWidth) / 2; 
                    const drawY = gameHeight - drawHeight;     

                    ctx.drawImage(bgImg, drawX, drawY, drawWidth, drawHeight);
                }

                // 3. & 4. Disegnare il titolo con effetto 3D, posizionato in alto
                ctx.textAlign = 'center';
                const titleY1 = gameHeight * 0.12; 
                const titleOffset3D = Math.max(2, Math.floor(gameHeight * 0.007)); 
                
                const mainTextColor = '#FFD700';     
                const strokeColor = '#A0522D';      
                const extrusionColor = '#502D0D';   
                const shadowColor = 'rgba(0, 0, 0, 0.6)'; 

                function drawEpicText(text, x, y, font, lineWidth) {
                    ctx.font = font;
                    
                    ctx.shadowColor = 'transparent'; 
                    ctx.fillStyle = extrusionColor;
                    ctx.fillText(text, x + titleOffset3D, y + titleOffset3D);

                    ctx.shadowColor = shadowColor;
                    ctx.shadowBlur = 7;
                    ctx.shadowOffsetX = titleOffset3D > 2 ? 3 : 2; 
                    ctx.shadowOffsetY = titleOffset3D > 2 ? 3 : 2;

                    ctx.strokeStyle = strokeColor;
                    ctx.lineWidth = lineWidth;
                    ctx.strokeText(text, x, y);
                    ctx.fillStyle = mainTextColor;
                    ctx.fillText(text, x, y);
                }

                let fontSize1 = Math.max(30, Math.min(65, Math.floor(gameHeight * 0.13))); 
                drawEpicText("Super Fabio", gameWidth / 2, titleY1, `bold ${fontSize1}px Arial`, 4);

                let fontSize2 = Math.max(25, Math.floor(fontSize1 * 0.85)); 
                const titleY2 = titleY1 + Math.floor(fontSize1 * 0.9); 
                drawEpicText("bros", gameWidth / 2, titleY2, `bold ${fontSize2}px Arial`, 4);

                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;

                // 5. Mini-personaggi animati e insalate decorative
                if (images.player && images.player.complete) {
                    titleFabioX += titleFabioDir * 0.5 * (deltaTime / 16); // Movimento basato su deltaTime
                    if (titleFabioX > gameWidth * 0.25 || titleFabioX < gameWidth * 0.05) titleFabioDir *= -1; 
                    let playerSpriteHeight = PLAYER_DEFAULT_HEIGHT * (gameHeight / 450); 
                    let playerSpriteWidth = (images.player.naturalWidth / images.player.naturalHeight * playerSpriteHeight); // Mantieni aspect ratio
                    ctx.drawImage(images.player, titleFabioX, gameHeight * 0.5, playerSpriteWidth, playerSpriteHeight);
                }
                if (images.enemy && images.enemy.complete) {
                    titleEnemyX += titleEnemyDir * 0.7 * (deltaTime / 16); // Movimento basato su deltaTime
                    if (titleEnemyX > gameWidth * 0.95 || titleEnemyX < gameWidth * 0.75) titleEnemyDir *= -1; 
                    let enemySpriteSize = 40 * (gameHeight / 450); 
                    ctx.drawImage(images.enemy, titleEnemyX, gameHeight * 0.55, enemySpriteSize, enemySpriteSize);
                }

                let saladFontSize = Math.max(20, Math.min(40, Math.floor(gameHeight * 0.08)));
                ctx.font = `${saladFontSize}px Arial`;
                ctx.fillText('ü•ó', gameWidth * 0.3, gameHeight * 0.6);
                ctx.fillText('ü•ó', gameWidth * 0.7, gameHeight * 0.4);
                
                // ======== FINE SEZIONE MODIFICATA PER TITLE SCREEN ========

                if (startButton.style.display === 'none') {
                     setTimeout(() => positionOverlayButton(startButton, 0.70), 0); // Alzato leggermente il bottone
                }

            } else if (gameState === 'PLAYING') {
                const currentLevelData = levels[currentLevel];
                ctx.fillStyle = currentLevelData.bgColor; ctx.fillRect(0, 0, gameWidth, gameHeight);
                // Elementi grafici specifici per livello (nuvole, sole, etc.)
                if (currentLevelData.themeName === "Cielo Sereno") {
                    ctx.fillStyle = "white";
                    // Nuvola 1
                    ctx.beginPath(); ctx.arc(100, 100, 30, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(130, 90, 40, 0, Math.PI * 2); ctx.fill();
                    // Nuvola 2
                    ctx.beginPath(); ctx.arc(500, 120, 50, 0, Math.PI * 2); ctx.fill();
                } else if (currentLevelData.themeName === "Deserto Infuocato") {
                    // Sole
                    ctx.fillStyle = "orange";
                    ctx.beginPath(); ctx.arc(gameWidth - 80, 80, 50, 0, Math.PI * 2); ctx.fill();
                    // Cactus (esempio)
                    ctx.fillStyle = "#8B4513"; // Marrone per il tronco del cactus
                    ctx.fillRect(100, gameHeight - 100, 20, 60); // Tronco
                    ctx.fillRect(80, gameHeight - 80, 60, 20);  // "Braccia"
                }

                for (const platform of platforms) platform.draw();
                for (const collectible of collectibles) collectible.draw();
                if (powerUpCollectible) powerUpCollectible.draw();

                player.update(deltaTime); player.draw();
                for (const enemy of enemies) { enemy.update(); enemy.draw(); }
                if (boss) { boss.update(); boss.draw(); }
                for (const projectile of projectiles) { projectile.update(); projectile.draw(); }

                handleCollisions();

                if (powerUpActive) {
                    powerUpTimer -= deltaTime;
                    if (powerUpTimer <= 0) {
                        powerUpActive = false;
                        powerUpTimer = 0;
                    }
                    updateUI();
                }

                const levelData = levels[currentLevel];
                if (!levelData.isBossLevel && score >= levelData.scoreToAdvance) {
                    gameState = 'LEVEL_COMPLETE';
                    setTimeout(() => positionOverlayButton(nextLevelButton, 0.75), 0);
                }

            } else if (gameState === 'LEVEL_COMPLETE') {
                ctx.fillStyle = 'rgba(0,0,0,0.7)'; ctx.fillRect(0,0,gameWidth, gameHeight);
                ctx.fillStyle = 'white'; ctx.font = '40px Arial'; ctx.textAlign = 'center';
                ctx.fillText('Livello Completato!', gameWidth / 2, gameHeight / 2 - 30);
                ctx.font = '20px Arial';
                ctx.fillText(`Punteggio: ${score}`, gameWidth / 2, gameHeight / 2 + 20);
            } else if (gameState === 'GAME_OVER') {
                if (images.background && images.background.complete) { // Usa immagine di sfondo se disponibile
                    ctx.drawImage(images.background, 0, 0, gameWidth, gameHeight);
                } else { ctx.fillStyle = 'black'; ctx.fillRect(0,0,gameWidth, gameHeight); }
                ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(0,0,gameWidth, gameHeight); // Overlay scuro
                ctx.fillStyle = 'red'; ctx.font = '60px Arial'; ctx.textAlign = 'center';
                ctx.fillText('GAME OVER', gameWidth / 2, gameHeight / 2 - 40);
                ctx.fillStyle = 'white'; ctx.font = '30px Arial';
                ctx.fillText(`Punteggio Finale: ${score}`, gameWidth / 2, gameHeight / 2 + 20);
            } else if (gameState === 'VICTORY') {
                 if (images.background && images.background.complete) { // Usa immagine di sfondo se disponibile
                    ctx.drawImage(images.background, 0, 0, gameWidth, gameHeight);
                } else { ctx.fillStyle = '#FFD700'; ctx.fillRect(0,0,gameWidth, gameHeight); } // Sfondo dorato di vittoria
                ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.fillRect(0,0,gameWidth, gameHeight); // Overlay leggero
                ctx.fillStyle = 'green'; ctx.font = '60px Arial'; ctx.textAlign = 'center';
                ctx.fillText('HAI VINTO!', gameWidth / 2, gameHeight / 2 - 40);
                ctx.fillStyle = 'white'; ctx.font = '30px Arial';
                ctx.fillText(`Punteggio Finale: ${score}`, gameWidth / 2, gameHeight / 2 + 20);
            }
            requestAnimationFrame(gameLoop);
        }

        startButton.addEventListener('click', () => {
            hideOverlayButtons();
            resetGame();
            if (backgroundMusic.paused) {
                backgroundMusic.play().catch(error => {
                    console.warn("La riproduzione automatica della musica potrebbe essere stata bloccata dal browser:", error);
                });
            }
        });
        retryButton.addEventListener('click', () => {
            hideOverlayButtons();
            resetGame();
        });
        playAgainButton.addEventListener('click', () => {
            hideOverlayButtons();
            resetGame();
        });
        nextLevelButton.addEventListener('click', () => {
            hideOverlayButtons();
            currentLevel++;
            loadLevel(currentLevel);
        });

        loadImages(() => {
            console.log("Immagini caricate!");
            gameState = 'TITLE';
            setTimeout(() => {
                // Forzo un resize iniziale per calcolare le dimensioni effettive del canvas
                // e posizionare correttamente il bottone start
                // Questo √® utile se il canvas ha max-width/max-height che lo rendono pi√π piccolo di gameWidth/Height
                window.dispatchEvent(new Event('resize')); 
                positionOverlayButton(startButton, 0.70);
            }, 0);
            lastTime = performance.now();
            requestAnimationFrame(gameLoop);
        });
    </script>
</body>
</html>
