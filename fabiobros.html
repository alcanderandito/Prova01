<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Super Fabio bros</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #333;
            font-family: 'Arial', sans-serif;
            color: white;
            overflow: hidden; /* Per evitare scrollbar indesiderate */
        }
        #gameContainer {
            position: relative;
            /* Le dimensioni verranno impostate da JS in base al canvas e allo scale */
            /* border: 2px solid #fff; */ /* Rimosso per non interferire con lo scaling */
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
            transform-origin: top left; /* Cruciale per lo scaling corretto */
        }
        canvas {
            display: block;
            background-color: #70c5ce;
        }
        #uiLayer {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            font-size: 24px; /* Potrebbe necessitare di adattamento se lo scale √® molto piccolo */
            color: white;
            text-shadow: 2px 2px 4px #000000;
            pointer-events: none;
            z-index: 5; /* Sopra il canvas ma sotto i messaggi */
        }
        #homeButton {
            margin-top: 20px; /* Aumentato un po' per dare spazio se il gioco √® scalato */
            padding: 10px 20px;
            font-size: 18px;
            color: white;
            background-color: #007bff;
            border: none;
            border-radius: 5px;
            text-decoration: none;
            cursor: pointer;
            /* position: relative; z-index: 1; // Per assicurarsi che sia cliccabile */
        }
        #homeButton:hover {
            background-color: #0056b3;
        }

        .gameMessage {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%; /* Prender√† le dimensioni del gameContainer */
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: rgba(0,0,0,0.7);
            background-size: contain; /* o cover, a seconda dell'effetto desiderato */
            background-repeat: no-repeat;
            background-position: center;
            color: white;
            text-align: center;
            z-index: 10;
            box-sizing: border-box; /* Importante se si aggiunge padding */
        }
        .gameMessage h1 {
            font-size: clamp(24px, 5vw, 48px); /* Font responsivo */
            margin-bottom: 20px;
            text-shadow: 3px 3px 6px #000;
        }
        .gameMessage p {
            font-size: clamp(16px, 3vw, 24px);
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px #000;
        }
        .gameMessage button {
            padding: clamp(10px, 2vw, 15px) clamp(20px, 4vw, 30px);
            font-size: clamp(16px, 2.5vw, 20px);
            color: white;
            background-color: #28a745;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        .gameMessage button:hover {
            background-color: #1e7e34;
        }
        #startScreen, #gameOverScreen, #winScreen, #levelCompleteScreen {
            display: none;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="uiLayer">
            <div id="livesDisplay">Vite: 5</div>
            <div id="scoreDisplay">Score: 0</div>
        </div>
        <div id="startScreen" class="gameMessage">
            <h1>Super Fabio bros</h1>
            <p>Premi il pulsante per iniziare!</p>
            <button id="startButton">Inizia Gioco</button>
        </div>
        <div id="gameOverScreen" class="gameMessage">
            <h1>GAME OVER</h1>
            <p id="finalScore"></p>
            <button id="restartButton">Riprova</button>
        </div>
        <div id="winScreen" class="gameMessage">
            <h1>HAI VINTO!</h1>
            <p>Complimenti, Super Fabio!</p>
            <p id="winFinalScore"></p>
            <button id="playAgainButton">Gioca Ancora</button>
        </div>
         <div id="levelCompleteScreen" class="gameMessage">
            <h1>LIVELLO COMPLETATO!</h1>
            <p id="levelCompleteScore"></p>
            <button id="nextLevelButton">Prossimo Livello</button>
        </div>
    </div>
    <a id="homeButton" href="index.html">Torna alla Home</a>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('gameContainer');

        // ... (altre variabili UI come prima)
        const livesDisplay = document.getElementById('livesDisplay');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const winScreen = document.getElementById('winScreen');
        const levelCompleteScreen = document.getElementById('levelCompleteScreen');
        const startButton = document.getElementById('startButton');
        const restartButton = document.getElementById('restartButton');
        const playAgainButton = document.getElementById('playAgainButton');
        const nextLevelButton = document.getElementById('nextLevelButton');
        const finalScoreDisplay = document.getElementById('finalScore');
        const winFinalScoreDisplay = document.getElementById('winFinalScore');
        const levelCompleteScoreDisplay = document.getElementById('levelCompleteScore');

        let player, enemies, collectibles, platforms, camera;
        let score = 0;
        let lives = 5;
        let currentLevelIndex = 0;
        const NUM_LEVELS = 5;
        const INITIAL_LIVES = 5;
        let gameState = 'START';

        const images = { player: new Image(), enemy: new Image(), mainScreen: new Image() };
        let imagesLoaded = 0;
        const TOTAL_IMAGES = 3;
        images.player.src = 'fabiogame2.PNG';
        images.enemy.src = 'mostro.PNG';
        images.mainScreen.src = 'fabiogame.PNG';
        images.player.onload = images.enemy.onload = images.mainScreen.onload = () => {
            imagesLoaded++;
            if (imagesLoaded === TOTAL_IMAGES) {
                console.log("Immagini caricate");
                resizeCanvas(); // Chiamare resize DOPO che le immagini (soprattutto mainScreen) sono caricate se influenzano il layout
                showStartScreen();
            }
        };
        
        const GRAVITY = 0.6;
        const PLAYER_SPEED = 4;
        const PLAYER_JUMP_FORCE = 13; // Abbassato leggermente per altezze fisse
        const ENEMY_SPEED = 1;
        const TILE_SIZE = 40;

        const levelBackgroundColors = ['#70c5ce', '#e6994b', '#5d943c', '#8c8c8c', '#4b0082'];

        // ----- NUOVA GESTIONE RESPONSIVITA' -----
        const GAME_WIDTH = 800; // Larghezza fissa interna del gioco
        const GAME_HEIGHT = 450; // Altezza fissa interna del gioco
        let scaleFactor = 1;

        function resizeCanvas() {
            canvas.width = GAME_WIDTH;
            canvas.height = GAME_HEIGHT;

            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight - document.getElementById('homeButton').offsetHeight - 40; // Spazio per home button e margini

            const scaleX = windowWidth / GAME_WIDTH;
            const scaleY = windowHeight / GAME_HEIGHT;
            scaleFactor = Math.min(scaleX, scaleY, 1); // Non scalare oltre 1:1 per default, o rimuovi ,1 se vuoi ingrandire su schermi grandi

            gameContainer.style.width = GAME_WIDTH * scaleFactor + 'px';
            gameContainer.style.height = GAME_HEIGHT * scaleFactor + 'px';
            gameContainer.style.transform = `scale(${scaleFactor})`;
            
            // Aggiorna UI layer font size in base allo scaleFactor se necessario
            const baseFontSize = 24;
            // uiLayer.style.fontSize = Math.max(12, baseFontSize * scaleFactor * 0.8) + 'px'; // Esempio di adattamento font

            // Setup controlli touch (le loro dimensioni interne sono fisse rispetto a GAME_WIDTH/HEIGHT)
            const controlSize = GAME_HEIGHT * 0.20; 
            const controlPadding = GAME_WIDTH * 0.05;

            touchControls.left.w = touchControls.left.h = controlSize;
            touchControls.left.x = controlPadding;
            touchControls.left.y = GAME_HEIGHT - controlSize - controlPadding;
            
            touchControls.right.w = touchControls.right.h = controlSize;
            touchControls.right.x = controlPadding + controlSize + controlPadding / 2;
            touchControls.right.y = GAME_HEIGHT - controlSize - controlPadding;

            touchControls.jump.w = touchControls.jump.h = controlSize;
            touchControls.jump.x = GAME_WIDTH - controlSize - controlPadding;
            touchControls.jump.y = GAME_HEIGHT - controlSize - controlPadding;

            for (const key in touchControls) {
                if (touchControls.hasOwnProperty(key) && typeof touchControls[key] === 'object') {
                    const control = touchControls[key];
                    control.path = new Path2D();
                    // Usare ctx.roundRect se disponibile e desiderato
                    if (ctx.roundRect) {
                        control.path.roundRect(control.x, control.y, control.w, control.h, [10]);
                    } else {
                        control.path.rect(control.x, control.y, control.w, control.h);
                    }
                }
            }
             if (gameState === 'PLAYING' || gameState === 'START') { // Ridisegna se il gioco √® in corso o in start
                draw();
            }
        }
        window.addEventListener('resize', resizeCanvas);
        // ----- FINE NUOVA GESTIONE RESPONSIVITA' -----


        class Camera {
            constructor(x, y, width, height, worldWidth, worldHeight) {
                this.x = x;
                this.y = y; // y sar√† sempre 0 per questo tipo di platform
                this.width = width; // GAME_WIDTH
                this.height = height; // GAME_HEIGHT
                this.worldWidth = worldWidth;
                this.worldHeight = worldHeight; // Coincide con GAME_HEIGHT
            }

            follow(target) {
                let targetX = target.x + target.width / 2 - this.width / 2;
                this.x = Math.max(0, Math.min(targetX, this.worldWidth - this.width));
                this.y = 0; // Camera Y fissa
            }

            apply(ctx) { ctx.translate(-this.x, -this.y); }
            reset(ctx) { ctx.translate(this.x, this.y); }
        }
        
        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = TILE_SIZE * 0.8;
                this.height = TILE_SIZE * 1.4;
                this.dx = 0;
                this.dy = 0;
                this.onGround = false;
                this.image = images.player;
                this.facingRight = true;
            }

            jump() {
                if (this.onGround) {
                    this.dy = -PLAYER_JUMP_FORCE;
                    this.onGround = false;
                }
            }
            move(direction) {
                this.dx = direction * PLAYER_SPEED;
                if (direction !== 0) this.facingRight = direction > 0;
            }

            // ----- LOGICA COLLISIONE GIOCATORE MIGLIORATA -----
            update(platforms) {
                // Movimento X e collisioni X
                this.x += this.dx;
                platforms.forEach(platform => {
                    if (this.collidesWith(platform)) { // AABB check
                        if (this.dx > 0 && this.x + this.width > platform.x && this.x < platform.x) { // Collisione da sinistra
                            this.x = platform.x - this.width;
                            this.dx = 0;
                        } else if (this.dx < 0 && this.x < platform.x + platform.width && this.x + this.width > platform.x + platform.width) { // Collisione da destra
                            this.x = platform.x + platform.width;
                            this.dx = 0;
                        }
                    }
                });

                // Movimento Y e collisioni Y
                this.dy += GRAVITY;
                this.y += this.dy;
                this.onGround = false;

                platforms.forEach(platform => {
                    if (this.collidesWith(platform)) { // AABB check
                        if (this.dy > 0 && this.y + this.height > platform.y && (this.y + this.height - this.dy) <= platform.y) { // Atterraggio
                             this.y = platform.y - this.height;
                             this.dy = 0;
                             this.onGround = true;
                        } else if (this.dy < 0 && this.y < platform.y + platform.height && (this.y - this.dy) >= platform.y + platform.height) { // Testata
                            this.y = platform.y + platform.height;
                            this.dy = 0;
                        }
                    }
                });
                
                // Limiti del mondo
                if (this.x < 0) this.x = 0;
                // La X a destra √® gestita dalla camera e dalla fine del livello
                
                // Caduta fuori dal mondo (sotto)
                if (this.y > GAME_HEIGHT) { // GAME_HEIGHT √® il fondo del mondo
                    loseLife();
                }
            }
            // ----- FINE LOGICA COLLISIONE GIOCATORE -----


            draw(ctx) { /* ... come prima ... */ 
                ctx.save();
                if (!this.facingRight) {
                    ctx.translate(this.x + this.width, this.y);
                    ctx.scale(-1, 1);
                    ctx.drawImage(this.image, 0, 0, this.width, this.height);
                } else {
                    ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
                }
                ctx.restore();
            }
            collidesWith(other) { /* ... come prima ... */
                return this.x < other.x + other.width &&
                       this.x + this.width > other.x &&
                       this.y < other.y + other.height &&
                       this.y + this.height > other.y;
            }
        }

        class Enemy { /* ... come prima ... */ 
            constructor(x, y, isBoss = false) {
                this.x = x;
                this.y = y;
                this.isBoss = isBoss;
                this.width = isBoss ? TILE_SIZE * 2.5 : TILE_SIZE;
                this.height = isBoss ? TILE_SIZE * 2.5 : TILE_SIZE;
                this.image = images.enemy;
                this.dx = -ENEMY_SPEED; 
                this.active = true;
                this.bossHealth = isBoss ? 3 : 1; 
            }

            update(platforms) {
                if (!this.active) return;
                this.x += this.dx;

                let hitWall = false;
                let onSolidGround = false; // Per evitare che i nemici fluttuino invertendo direzione a mezz'aria
                
                platforms.forEach(platform => {
                    // Controllo se il nemico √® sopra una piattaforma
                    const enemyBottom = this.y + this.height;
                    if (enemyBottom >= platform.y && enemyBottom <= platform.y + TILE_SIZE && // Vicino alla superficie
                        this.x + this.width > platform.x && this.x < platform.x + platform.width) {
                        onSolidGround = true;
                    }

                    // Collisione laterale con piattaforma
                    if (this.y + this.height > platform.y && this.y < platform.y + platform.height) { // Allineato verticalmente
                         if ((this.dx < 0 && this.x <= platform.x + platform.width && this.x + this.width >= platform.x + platform.width && this.x > platform.x ) ||
                            (this.dx > 0 && this.x + this.width >= platform.x && this.x <= platform.x  && this.x + this.width < platform.x+platform.width)) {
                           hitWall = true;
                        }
                    }
                });
                
                // Inverti direzione se colpisci un muro o il bordo del mondo O se non c'√® terreno davanti (semplificato)
                // Questa logica di "non cadere" √® ancora base
                if (hitWall || this.x < 0 || this.x + this.width > camera.worldWidth) {
                    this.dx *= -1;
                }
            }

            draw(ctx) { /* ... come prima ... */ 
                if (!this.active) return;
                ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
                if(this.isBoss && this.bossHealth > 0) { // Mostra HP finch√© > 0
                    ctx.fillStyle = 'red';
                    ctx.font = '12px Arial';
                    ctx.fillText(`HP: ${this.bossHealth}`, this.x + this.width / 2, this.y - 5);
                    ctx.textAlign = 'center';
                }
            }
            collidesWith(other) { /* ... come prima ... */ 
                return this.x < other.x + other.width &&
                       this.x + this.width > other.x &&
                       this.y < other.y + other.height &&
                       this.y + this.height > other.y;
            }
            stomp() { /* ... come prima ... */ 
                this.bossHealth--;
                if(this.bossHealth <= 0) {
                    this.active = false;
                    score += this.isBoss ? 500 : 100;
                    updateScoreDisplay();
                } else {
                    this.y -= 10; 
                }
            }
        }

        class Collectible { /* ... come prima ... */
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = TILE_SIZE * 0.7;
                this.height = TILE_SIZE * 0.7;
                this.text = 'ü•ó'; 
                this.active = true;
                this.value = 50;
            }
            draw(ctx) {
                if (!this.active) return;
                ctx.font = `${this.height}px Arial`;
                ctx.textAlign = "left"; // Resetta per emoji
                ctx.fillText(this.text, this.x, this.y + this.height * 0.8);
            }
        }
        class Platform { /* ... come prima ... */
             constructor(x, y, width, height, color = '#654321') {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.color = color; 
            }
            draw(ctx) {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }
        }

        // I dati dei livelli ora sono definiti rispetto a GAME_HEIGHT (450px)
        // Esempio: piattaforma a y=400 significa 400px dall'alto del canvas 800x450
        const levels = [
            // Livello 1 (Y sono rispetto a un canvas 800x450)
            {
                playerStart: { x: 50, y: GAME_HEIGHT - TILE_SIZE * 2.5 }, // Spawn sopra la prima piattaforma
                worldWidth: 1600,
                platforms: [
                    { x: 0, y: GAME_HEIGHT - TILE_SIZE, width: 600, height: TILE_SIZE },
                    { x: 700, y: GAME_HEIGHT - TILE_SIZE * 2, width: 200, height: TILE_SIZE },
                    { x: 1000, y: GAME_HEIGHT - TILE_SIZE * 3, width: 250, height: TILE_SIZE },
                    { x: 1300, y: GAME_HEIGHT - TILE_SIZE, width: 300, height: TILE_SIZE, goal: true }
                ],
                enemies: [
                    { x: 400, y: GAME_HEIGHT - TILE_SIZE*2 }, // y √® la cima del nemico
                    { x: 800, y: GAME_HEIGHT - TILE_SIZE*3 },
                    { x: 1100, y: GAME_HEIGHT - TILE_SIZE*4 },
                ],
                collectibles: [
                    { x: 200, y: GAME_HEIGHT - TILE_SIZE*3 }, { x: 750, y: GAME_HEIGHT - TILE_SIZE*4 }, { x: 1050, y: GAME_HEIGHT - TILE_SIZE*5 }
                ]
            },
            // Livello 2
             {
                playerStart: { x: 50, y: GAME_HEIGHT - TILE_SIZE * 4 }, // Un po' pi√π in alto
                worldWidth: 2000,
                platforms: [
                    { x: 0, y: GAME_HEIGHT - TILE_SIZE, width: 300, height: TILE_SIZE },
                    { x: 400, y: GAME_HEIGHT - TILE_SIZE * 2, width: 150, height: TILE_SIZE },
                    { x: 600, y: GAME_HEIGHT - TILE_SIZE * 3, width: 150, height: TILE_SIZE },
                    { x: 800, y: GAME_HEIGHT - TILE_SIZE * 2, width: 150, height: TILE_SIZE },
                    { x: 1000, y: GAME_HEIGHT - TILE_SIZE, width: 300, height: TILE_SIZE },
                    { x: 1400, y: GAME_HEIGHT - TILE_SIZE * 3.5, width: 200, height: TILE_SIZE },
                    { x: 1700, y: GAME_HEIGHT - TILE_SIZE * 5, width: 150, height: TILE_SIZE },
                    { x: 1850, y: GAME_HEIGHT - TILE_SIZE, width: 150, height: TILE_SIZE, goal: true }
                ],
                enemies: [
                    { x: 250, y: GAME_HEIGHT - TILE_SIZE*2 }, { x: 700, y: GAME_HEIGHT - TILE_SIZE*4 },
                    { x: 1150, y: GAME_HEIGHT - TILE_SIZE*2 }, { x: 1500, y: GAME_HEIGHT - TILE_SIZE*4.5 }
                ],
                collectibles: [
                    { x: 150, y: GAME_HEIGHT - TILE_SIZE*2.5 }, { x: 450, y: GAME_HEIGHT - TILE_SIZE*3.5 }, 
                    { x: 900, y: GAME_HEIGHT - TILE_SIZE*3.5 }, { x: 1450, y: GAME_HEIGHT - TILE_SIZE*5 }, 
                    { x: 1750, y: GAME_HEIGHT - TILE_SIZE*6 }
                ]
            },
            // Livello 3
            {
                playerStart: { x: 50, y: GAME_HEIGHT - TILE_SIZE * 8 }, // Inizia molto in alto
                worldWidth: 2200,
                platforms: [
                    { x: 0, y: GAME_HEIGHT - TILE_SIZE, width: 200, height: TILE_SIZE },
                    { x: 150, y: GAME_HEIGHT - TILE_SIZE * 4, width: 50, height: TILE_SIZE },
                    { x: 300, y: GAME_HEIGHT - TILE_SIZE * 5, width: 200, height: TILE_SIZE },
                    { x: 600, y: GAME_HEIGHT - TILE_SIZE * 2.5, width: 300, height: TILE_SIZE },
                    { x: 700, y: GAME_HEIGHT - TILE_SIZE * 6, width: 100, height: TILE_SIZE }, 
                    { x: 1000, y: GAME_HEIGHT - TILE_SIZE, width: 400, height: TILE_SIZE },
                    { x: 1200, y: GAME_HEIGHT - TILE_SIZE * 4, width: 150, height: TILE_SIZE },
                    { x: 1500, y: GAME_HEIGHT - TILE_SIZE * 6, width: 200, height: TILE_SIZE },
                    { x: 1800, y: GAME_HEIGHT - TILE_SIZE * 2.5, width: 100, height: TILE_SIZE },
                    { x: 2000, y: GAME_HEIGHT - TILE_SIZE, width: 200, height: TILE_SIZE, goal: true }
                ],
                enemies: [
                     { x: 400, y: GAME_HEIGHT - TILE_SIZE*6 }, { x: 750, y: GAME_HEIGHT - TILE_SIZE*3.5 }, 
                     { x: 1100, y: GAME_HEIGHT - TILE_SIZE*2 }, { x: 1300, y: GAME_HEIGHT - TILE_SIZE*5 }, 
                     { x: 1600, y: GAME_HEIGHT - TILE_SIZE*7 }, { x: 1850, y: GAME_HEIGHT - TILE_SIZE*3.5 }
                ],
                collectibles: [
                    { x: 100, y: GAME_HEIGHT - TILE_SIZE*2 }, { x: 350, y: GAME_HEIGHT - TILE_SIZE*6 }, 
                    { x: 720, y: GAME_HEIGHT - TILE_SIZE*7 }, {x: 1050, y: GAME_HEIGHT - TILE_SIZE*2.5}, 
                    {x: 1550, y: GAME_HEIGHT - TILE_SIZE*7.5}, {x: 2050, y: GAME_HEIGHT - TILE_SIZE*2}
                ]
            },
            // Livello 4
            {
                playerStart: { x: 50, y: GAME_HEIGHT - TILE_SIZE * 2.5 },
                worldWidth: 2500,
                platforms: [
                    { x: 0, y: GAME_HEIGHT - TILE_SIZE, width: 150, height: TILE_SIZE },
                    { x: 250, y: GAME_HEIGHT - TILE_SIZE * 2.5, width: 80, height: TILE_SIZE },
                    { x: 400, y: GAME_HEIGHT - TILE_SIZE * 4, width: 80, height: TILE_SIZE },
                    { x: 550, y: GAME_HEIGHT - TILE_SIZE * 5.5, width: 80, height: TILE_SIZE },
                    { x: 700, y: GAME_HEIGHT - TILE_SIZE * 4, width: 80, height: TILE_SIZE },
                    { x: 850, y: GAME_HEIGHT - TILE_SIZE * 2.5, width: 80, height: TILE_SIZE },
                    { x: 1000, y: GAME_HEIGHT - TILE_SIZE, width: 300, height: TILE_SIZE },
                    { x: 1400, y: GAME_HEIGHT - TILE_SIZE * 4, width: 100, height: TILE_SIZE },
                    { x: 1450, y: GAME_HEIGHT - TILE_SIZE * 6.5, width: 50, height: TILE_SIZE }, 
                    { x: 1600, y: GAME_HEIGHT - TILE_SIZE * 2.5, width: 200, height: TILE_SIZE },
                    { x: 1900, y: GAME_HEIGHT - TILE_SIZE * 4.5, width: 150, height: TILE_SIZE },
                    { x: 2200, y: GAME_HEIGHT - TILE_SIZE * 6.5, width: 100, height: TILE_SIZE },
                    { x: 2350, y: GAME_HEIGHT - TILE_SIZE, width: 150, height: TILE_SIZE, goal: true }
                ],
                enemies: [
                    { x: 100, y: GAME_HEIGHT - TILE_SIZE*2 }, { x: 600, y: GAME_HEIGHT - TILE_SIZE*6.5 }, 
                    { x: 1150, y: GAME_HEIGHT - TILE_SIZE*2 }, { x: 1700, y: GAME_HEIGHT - TILE_SIZE*3.5 }, 
                    { x: 2000, y: GAME_HEIGHT - TILE_SIZE*5.5 }, { x: 2250, y: GAME_HEIGHT - TILE_SIZE*7.5 }
                ],
                collectibles: [
                    { x: 280, y: GAME_HEIGHT - TILE_SIZE*3.5 }, { x: 430, y: GAME_HEIGHT - TILE_SIZE*5 }, 
                    { x: 580, y: GAME_HEIGHT - TILE_SIZE*6.5 }, { x: 730, y: GAME_HEIGHT - TILE_SIZE*5 }, 
                    { x: 880, y: GAME_HEIGHT - TILE_SIZE*3.5 }, { x: 1420, y: GAME_HEIGHT - TILE_SIZE*5 }, 
                    { x: 1950, y: GAME_HEIGHT - TILE_SIZE*5.5 }
                ]
            },
            // Livello 5 (Boss)
            {
                playerStart: { x: 50, y: GAME_HEIGHT - TILE_SIZE*2.5 },
                worldWidth: 1200, 
                platforms: [
                    { x: 0, y: GAME_HEIGHT - TILE_SIZE, width: 500, height: TILE_SIZE },
                    { x: 600, y: GAME_HEIGHT - TILE_SIZE * 4, width: 150, height: TILE_SIZE }, 
                    { x: 700, y: GAME_HEIGHT - TILE_SIZE, width: 500, height: TILE_SIZE, goal: true }
                ],
                enemies: [
                    { x: 200, y: GAME_HEIGHT - TILE_SIZE*2 }, 
                    { x: 900, y: GAME_HEIGHT - TILE_SIZE - (TILE_SIZE * 2.5), isBoss: true } // Boss Y relativo al pavimento
                ],
                collectibles: [
                    { x: 100, y: GAME_HEIGHT - TILE_SIZE*2 }, { x: 300, y: GAME_HEIGHT - TILE_SIZE*2 }, 
                    {x: 650, y: GAME_HEIGHT - TILE_SIZE*5}
                ]
            }
        ];

        function loadLevel(levelIndex) {
            const levelData = levels[levelIndex];
            canvas.style.backgroundColor = levelBackgroundColors[levelIndex];

            player = new Player(levelData.playerStart.x, levelData.playerStart.y);
            platforms = levelData.platforms.map(p => new Platform(p.x, p.y, p.width, p.height, p.color || '#654321'));
            platforms.forEach(p => p.isGoal = p.goal || false);
            enemies = levelData.enemies.map(e => new Enemy(e.x, e.y, e.isBoss || false));
            collectibles = levelData.collectibles.map(c => new Collectible(c.x, c.y));
            
            // Camera usa GAME_WIDTH e GAME_HEIGHT
            camera = new Camera(0, 0, GAME_WIDTH, GAME_HEIGHT, levelData.worldWidth, GAME_HEIGHT);
        }
        
        function resetGame(startLevelZero = true) { /* ... come prima ... */
            score = 0;
            lives = INITIAL_LIVES;
            currentLevelIndex = startLevelZero ? 0 : currentLevelIndex;
            updateScoreDisplay();
            updateLivesDisplay();
            loadLevel(currentLevelIndex);
            gameState = 'PLAYING';
            hideAllScreens();
            // gameLoop(); // Non necessario, √® gi√† in esecuzione
        }
        function startGameFlow() { resetGame(true); }
        function retryLevelFlow() { /* ... come prima (ma potrebbe essere rimosso se gameover ti fa ricominciare) ... */
            resetGame(false); // Riprova lo stesso livello, ma con vite piene e score azzerato
        }

        function loseLife() { /* ... come prima ... */
            lives--;
            updateLivesDisplay();
            if (lives <= 0) {
                setGameOver();
            } else {
                const levelData = levels[currentLevelIndex];
                player.x = levelData.playerStart.x;
                player.y = levelData.playerStart.y;
                player.dx = 0;
                player.dy = 0;
                camera.x = 0; 
            }
        }
        function completeLevel() { /* ... come prima ... */
            gameState = 'LEVEL_COMPLETE';
            levelCompleteScoreDisplay.textContent = `Score: ${score}`;
            levelCompleteScreen.style.backgroundImage = `url('${images.mainScreen.src}')`;
            showScreen(levelCompleteScreen);
        }
        function proceedToNextLevel() { /* ... come prima ... */
             currentLevelIndex++;
            if (currentLevelIndex >= NUM_LEVELS) {
                setGameWin();
            } else {
                loadLevel(currentLevelIndex);
                gameState = 'PLAYING';
                hideAllScreens();
            }
        }
        function setGameOver() { /* ... come prima ... */
            gameState = 'GAME_OVER';
            finalScoreDisplay.textContent = `Score Finale: ${score}`;
            gameOverScreen.style.backgroundImage = `url('${images.mainScreen.src}')`;
            showScreen(gameOverScreen);
        }
        function setGameWin() { /* ... come prima ... */
             gameState = 'WIN';
            winFinalScoreDisplay.textContent = `Score Finale: ${score}`;
            winScreen.style.backgroundImage = `url('${images.mainScreen.src}')`;
            showScreen(winScreen);
        }
        function updateScoreDisplay() { /* ... come prima ... */ scoreDisplay.textContent = `Score: ${score}`; }
        function updateLivesDisplay() { /* ... come prima ... */ livesDisplay.textContent = `Vite: ${lives}`; }
        function hideAllScreens() { /* ... come prima ... */ 
            startScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';
            winScreen.style.display = 'none';
            levelCompleteScreen.style.display = 'none';
        }
        function showScreen(screenElement) { /* ... come prima ... */
            hideAllScreens();
            screenElement.style.display = 'flex';
        }
        function showStartScreen() { /* ... come prima ... */
            startScreen.style.backgroundImage = `url('${images.mainScreen.src}')`;
            showScreen(startScreen);
             // Assicurati che il canvas sia disegnato anche nella schermata di start se serve uno sfondo
            if (imagesLoaded === TOTAL_IMAGES) draw();
        }

        const keys = {};
        window.addEventListener('keydown', (e) => keys[e.code] = true);
        window.addEventListener('keyup', (e) => keys[e.code] = false);

        function handleInput() { /* ... come prima ... */
            let moveDirection = 0;
            if (keys['ArrowLeft'] || keys['KeyA'] || touchControls.left.active) moveDirection = -1;
            else if (keys['ArrowRight'] || keys['KeyD'] || touchControls.right.active) moveDirection = 1;
            player.move(moveDirection);

            if ((keys['Space'] || keys['ArrowUp'] || keys['KeyW'] || touchControls.jump.active) && player.onGround) {
                player.jump();
                if (touchControls.jump.active) touchControls.jump.active = false;
            }
        }
        
        // ----- GESTIONE TOUCH CON SCALING -----
        const touchControls = { /* ... come prima, ma i path verranno creati in resizeCanvas ... */
            left: { x: 0, y: 0, w: 0, h: 0, active: false, path: null },
            right: { x: 0, y: 0, w: 0, h: 0, active: false, path: null },
            jump: { x: 0, y: 0, w: 0, h: 0, active: false, path: null }
        };

        function handleTouch(e, isStart) {
            e.preventDefault();
            const touches = e.changedTouches;
            const rect = canvas.getBoundingClientRect(); // Questo d√† le coordinate scalate del canvas sullo schermo

            for (let i = 0; i < touches.length; i++) {
                const touch = touches[i];
                // De-scala le coordinate del tocco per mapparle alle coordinate interne del canvas
                const touchX = (touch.clientX - rect.left) / scaleFactor;
                const touchY = (touch.clientY - rect.top) / scaleFactor;

                for (const key in touchControls) {
                    if (touchControls.hasOwnProperty(key) && typeof touchControls[key] === 'object' && touchControls[key].path) {
                        const control = touchControls[key];
                         if (ctx.isPointInPath(control.path, touchX, touchY)) {
                            control.active = isStart;
                        } else if (!isStart && control.active) { 
                            // Se il dito viene rilasciato fuori da un pulsante che era attivo, disattivalo
                            // Questo √® importante se il dito scivola fuori dal pulsante prima del touchend
                            // if (ctx.isPointInPath(control.path, touchX, touchY) === false) { // Questa condizione √® ridondante con l'else if
                            //    control.active = false; // Disattiva solo se il rilascio √® fuori
                            // }
                        }
                    }
                }
            }
             // Se √® un touchend, e nessun pulsante √® stato premuto (es. tocco su area vuota),
             // assicurati di disattivare tutti i pulsanti (in caso di trascinamento e rilascio fuori).
            if (!isStart) {
                 let activeControlFound = false;
                 for (const key in touchControls) {
                    if (touchControls.hasOwnProperty(key) && typeof touchControls[key] === 'object' && touchControls[key].path) {
                        const control = touchControls[key];
                        const touch = touches[i]; // Usa lo stesso touch per il check
                        const touchX = (touch.clientX - rect.left) / scaleFactor;
                        const touchY = (touch.clientY - rect.top) / scaleFactor;
                        if (ctx.isPointInPath(control.path, touchX, touchY)) {
                            activeControlFound = true;
                            break;
                        }
                    }
                 }
                 if(!activeControlFound) { // Se il touchend √® avvenuto fuori da ogni controllo
                    touchControls.left.active = false;
                    touchControls.right.active = false;
                    // Non resettare jump.active qui, perch√© √® un'azione singola e si resetta da solo in handleInput
                 }
            }
        }
        canvas.addEventListener('touchstart', (e) => handleTouch(e, true));
        canvas.addEventListener('touchend', (e) => handleTouch(e, false));
        canvas.addEventListener('touchcancel', (e) => handleTouch(e, false));
        // ----- FINE GESTIONE TOUCH -----

        function update() { /* ... come prima, ma verifica collisioni nemici ... */
            if (gameState !== 'PLAYING') return;

            handleInput();
            player.update(platforms);
            enemies.forEach(enemy => { if(enemy.active) enemy.update(platforms); });
            camera.follow(player);

            enemies.forEach((enemy) => {
                if (enemy.active && player.collidesWith(enemy)) {
                    if (player.dy > 0 && (player.y + player.height - player.dy) <= enemy.y && !player.onGround) { // Il !player.onGround √® un check in pi√π
                        enemy.stomp();
                        player.dy = -PLAYER_JUMP_FORCE / 1.5; // Balzo pi√π controllato
                        player.onGround = false; // Assicura che non possa saltare subito
                    } else if (player.y + player.height > enemy.y + 10) { // Evita danno se il giocatore sta appena sopra o scivola di lato
                        loseLife(); 
                    }
                }
            });
            enemies = enemies.filter(enemy => enemy.active || (enemy.isBoss && enemy.bossHealth > 0) );


            collectibles.forEach((collectible) => {
                if (collectible.active && player.collidesWith(collectible)) {
                    collectible.active = false;
                    score += collectible.value;
                    updateScoreDisplay();
                }
            });
            collectibles = collectibles.filter(collectible => collectible.active);

            const goalPlatform = platforms.find(p => p.isGoal);
            if (goalPlatform && player.collidesWith(goalPlatform) && player.x + player.width / 2 > goalPlatform.x ) {
                const activeBosses = enemies.filter(e => e.isBoss && e.active);
                if (activeBosses.length === 0) {
                    completeLevel();
                }
            }
        }

        function draw() {
            // Pulisci canvas con il colore di sfondo del canvas (che pu√≤ essere il colore del livello)
            // o un colore di base se non in gioco.
            ctx.fillStyle = canvas.style.backgroundColor || '#333';
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

            if (gameState === 'START' || gameState === 'GAME_OVER' || gameState === 'WIN' || gameState === 'LEVEL_COMPLETE') {
                // Le schermate HTML sono sopra, ma potremmo voler disegnare l'immagine di sfondo sul canvas
                // se l'HTML non la gestisce (ma lo fa con background-image).
                if (images.mainScreen.complete && images.mainScreen.naturalHeight !== 0) {
                     // Non disegno l'immagine qui perch√© √® gi√† sfondo del div .gameMessage
                     // Se si volesse, sarebbe: ctx.drawImage(images.mainScreen, 0, 0, GAME_WIDTH, GAME_HEIGHT);
                }
                // Disegna comunque i controlli touch se siamo su START per vederli prima di iniziare
                if (gameState === 'START') drawTouchControls();
                return; 
            }
            
            ctx.save();
            camera.apply(ctx);
            platforms.forEach(p => p.draw(ctx));
            collectibles.forEach(c => c.draw(ctx));
            enemies.forEach(e => e.draw(ctx));
            player.draw(ctx);
            ctx.restore(); 
            drawTouchControls();
        }

        function drawTouchControls() { /* ... come prima, ma usa ctx.roundRect se disponibile ... */
            ctx.fillStyle = "rgba(128, 128, 128, 0.5)";
            ctx.strokeStyle = "rgba(255, 255, 255, 0.7)";
            ctx.lineWidth = 2;
            ctx.font = `${touchControls.left.h * 0.4}px Arial`; // Riduci un po' la dimensione del font
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";

            ['left', 'right', 'jump'].forEach(key => {
                const control = touchControls[key];
                ctx.beginPath(); // Inizia un nuovo path per ogni controllo
                if (control.path) { // Assicurati che il path sia stato creato
                    // Ridisegna il path perch√© fill/stroke consumano il path corrente.
                    // Oppure usa il path memorizzato se ctx.fill(control.path) √® supportato.
                    if (ctx.roundRect) { // Per consistenza con la creazione del path
                        ctx.roundRect(control.x, control.y, control.w, control.h, [10]);
                    } else {
                        ctx.rect(control.x, control.y, control.w, control.h);
                    }
                }
                ctx.fill(); 
                ctx.stroke();
                ctx.fillStyle = "white";
                let symbol = '';
                if (key === 'left') symbol = '‚óÄ';
                else if (key === 'right') symbol = '‚ñ∂';
                else if (key === 'jump') symbol = '‚ñ≤';
                ctx.fillText(symbol, control.x + control.w / 2, control.y + control.h / 2);
                ctx.fillStyle = "rgba(128, 128, 128, 0.5)"; // Reimposta per il prossimo controllo
            });
        }

        let lastTime = 0;
        function gameLoop(timestamp) {
            const deltaTime = (timestamp - lastTime) || 0; // Evita NaN al primo frame
            lastTime = timestamp;

            if (gameState === 'PLAYING') {
                update(deltaTime);
            }
            draw(); 
            requestAnimationFrame(gameLoop);
        }

        startButton.addEventListener('click', startGameFlow);
        restartButton.addEventListener('click', startGameFlow); 
        playAgainButton.addEventListener('click', startGameFlow); 
        nextLevelButton.addEventListener('click', proceedToNextLevel);

        // Chiamata iniziale a resizeCanvas e avvio loop
        // resizeCanvas sar√† chiamato di nuovo dall'onload delle immagini se non sono ancora pronte.
        // Se le immagini sono gi√† caricate (da cache), showStartScreen le usa.
        resizeCanvas(); 
        if (imagesLoaded < TOTAL_IMAGES) {
            // Le immagini non sono ancora tutte caricate, showStartScreen sar√† chiamato dall'ultimo onload
            // Potremmo mostrare un messaggio "Caricamento..."
            ctx.fillStyle = "black";
            ctx.fillRect(0,0, GAME_WIDTH, GAME_HEIGHT);
            ctx.fillStyle = "white";
            ctx.font = "20px Arial";
            ctx.textAlign = "center";
            ctx.fillText("Caricamento gioco...", GAME_WIDTH/2, GAME_HEIGHT/2);
        } else {
            showStartScreen(); // Se immagini gi√† pronte, mostra subito start
        }
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
